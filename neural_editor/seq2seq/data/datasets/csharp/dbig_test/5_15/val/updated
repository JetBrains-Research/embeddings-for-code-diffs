var VAR0 = await GetError ( VAR1 , VAR2 ) . ConfigureAwait ( false ) ; var VAR3 = Current . User ; var VAR4 = VAR5 . Actions . Find ( VAR6 => VAR6 . Id == VAR7 ) ; var VAR8 = new JiraClient ( VAR5 ) ; var VAR9 = await VAR8 . CreateIssueAsync ( VAR4 , VAR0 , VAR3 == null ? LITERAL : VAR3 . AccountName ) . ConfigureAwait ( false ) ;
VAR0 = true ; VAR2 = LITERAL ; await VAR3 ( ) ; VAR2 = LITERAL ; VAR4 = false ; Interlocked . Increment ( ref VAR1 ) ;
int VAR0 = VAR1 ? . GetHashCode ( ) ?? 0 ; VAR0 = ( VAR0 * LITERAL ) ^ ( VAR2 ? . GetHashCode ( ) ?? 0 ) ; VAR0 = ( VAR0 * LITERAL ) ^ VAR3 . GetHashCode ( ) ; VAR0 = ( VAR0 * LITERAL ) ^ VAR4 ; VAR0 = ( VAR0 * LITERAL ) ^ ( VAR5 ? . GetHashCode ( ) ?? 0 ) ;
int VAR0 = VAR1 ? . GetHashCode ( ) ?? 0 ; VAR0 = ( VAR0 * LITERAL ) ^ VAR2 . GetHashCode ( ) ; VAR0 = ( VAR0 * LITERAL ) ^ ( VAR3 ? . GetHashCode ( ) ?? 0 ) ; VAR0 = ( VAR0 * LITERAL ) ^ ( VAR4 ? . GetHashCode ( ) ?? 0 ) ; VAR0 = ( VAR0 * LITERAL ) ^ ( VAR5 ? . GetHashCode ( ) ?? 0 ) ; VAR0 = ( VAR0 * LITERAL ) ^ ( VAR6 ? . GetHashCode ( ) ?? 0 ) ;
VAR0 = ( VAR0 * LITERAL ) ^ ( VAR1 ? . GetHashCode ( ) ?? 0 ) ; VAR0 = ( VAR0 * LITERAL ) ^ ( VAR2 ? . GetHashCode ( ) ?? 0 ) ; VAR0 = ( VAR0 * LITERAL ) ^ ( VAR3 ? . GetHashCode ( ) ?? 0 ) ; VAR0 = ( VAR0 * LITERAL ) ^ ( VAR4 ? . GetHashCode ( ) ?? 0 ) ; VAR0 = ( VAR0 * LITERAL ) ^ ( VAR5 ? . GetHashCode ( ) ?? 0 ) ; VAR0 = ( VAR0 * LITERAL ) ^ ( VAR6 ? . GetHashCode ( ) ?? 0 ) ; VAR0 = ( VAR0 * LITERAL ) ^ ( VAR7 ? . GetHashCode ( ) ?? 0 ) ;
VAR0 . Append ( string . Join ( LITERAL , VAR1 . Select ( VAR2 => EscapeLiteral ( VAR2 . Table ) ) ) ) ; VAR0 . Append ( LITERAL ) ; VAR0 . Append ( VAR3 ) ; VAR0 . Append ( LITERAL ) ; VAR0 . Append ( VAR4 ) ; VAR0 . Append ( LITERAL ) ; VAR0 . Append ( string . Join ( LITERAL , VAR1 . Select ( VAR2 => EscapeLiteral ( LITERAL ) ) ) ) ;
VAR0 . AddEntry ( VAR1 , true ) ; var VAR2 = VAR3 . GetOrCreateEntry ( new object ( ) ) ; VAR2 [ VAR4 ] = VAR5 ; VAR2 . SetEntityState ( EntityState . Modified ) ; var VAR6 = new ModificationCommand ( LITERAL , null , new ParameterNameGenerator ( ) . GenerateNext , false , null ) ; VAR6 . AddEntry ( VAR2 , true ) ; var VAR7 = new ModificationCommand ( LITERAL , null , new ParameterNameGenerator ( ) . GenerateNext , false , null ) ; VAR7 . AddEntry ( VAR1 , true ) ;
Assert . Empty ( VAR0 ) ; var VAR1 = new Driver { Id = - 1 , Name = LITERAL , TeamId = Team . Ferrari , CarNumber = LITERAL } ; VAR0 . Add ( VAR1 ) ; Assert . Same ( VAR1 , VAR2 . Drivers . Find ( - 1 ) ) ; Assert . Equal ( EntityState . Added , VAR2 . Entry ( VAR1 ) . State ) ; Assert . Single ( VAR0 ) ; Assert . Single ( VAR3 ) ; Assert . Single ( VAR4 ) ;
Assert . Single ( VAR0 . OptionalChildren ) ; Assert . DoesNotContain ( VAR1 , VAR0 . OptionalChildren . Select ( VAR2 => VAR2 . Id ) ) ; Assert . Empty ( VAR3 . Set < Optional1 > ( ) . Where ( VAR2 => VAR2 . Id == VAR1 ) ) ; var VAR4 = VAR3 . Set < Optional2 > ( ) . Where ( VAR2 => VAR5 . Contains ( VAR2 . Id ) ) . ToList ( ) ; Assert . Equal ( VAR5 . Count , VAR4 . Count ) ; Assert . True ( VAR4 . All ( VAR2 => VAR2 . ParentId == null ) ) ; Assert . Same ( VAR0 , VAR6 . Parent ) ; Assert . Empty ( VAR6 . Children ) ;
Assert . Contains ( VAR0 , VAR1 => VAR1 == LITERAL ) ; Assert . Contains ( VAR0 , VAR1 => VAR1 == LITERAL ) ; Assert . Contains ( VAR0 , VAR1 => VAR1 == LITERAL ) ; Assert . Contains ( VAR0 , VAR1 => VAR1 == LITERAL ) ; Assert . Contains ( VAR0 , VAR1 => VAR1 == LITERAL ) ; Assert . Contains ( VAR0 , VAR1 => VAR1 == LITERAL ) ; Assert . Contains ( VAR0 , VAR1 => VAR1 == LITERAL ) ; Assert . Contains ( VAR0 , VAR1 => VAR1 == LITERAL ) ; Assert . Contains ( VAR0 , VAR1 => VAR1 == LITERAL ) ; Assert . Contains ( VAR0 , VAR1 => VAR1 == LITERAL ) ; Assert . Contains ( VAR0 , VAR1 => VAR1 == LITERAL ) ; Assert . Contains ( VAR0 , VAR1 => VAR1 == LITERAL ) ; Assert . Contains ( VAR0 , VAR1 => VAR1 == LITERAL ) ; Assert . Contains ( VAR0 , VAR1 => VAR1 == LITERAL ) ;
var VAR0 = VAR1 . VAR2 . ToList ( ) ; Assert . Equal ( VAR0 . Count , VAR0 . Count ( VAR3 => VAR3 . VAR4 == LITERAL ) * LITERAL ) ; Assert . Equal ( LITERAL , VAR0 . Single ( VAR3 => VAR3 . VAR5 == VAR6 [ 0 ] ) . VAR4 ) ; Assert . Equal ( LITERAL , VAR0 . Single ( VAR3 => VAR3 . VAR5 == VAR6 [ 1 ] ) . VAR4 ) ; Assert . Equal ( LITERAL , VAR0 . Single ( VAR3 => VAR3 . VAR5 == VAR6 [ LITERAL ] ) . VAR4 ) ; VAR0 . Single ( VAR3 => VAR3 . VAR5 == VAR6 [ 1 ] ) . VAR4 = LITERAL ;
VAR0 . Property < int > ( LITERAL ) . IsConcurrencyToken ( ) ; VAR0 . Property < string > ( LITERAL ) . IsConcurrencyToken ( false ) ; VAR0 . Property < int > ( LITERAL ) . IsConcurrencyToken ( ) ; VAR0 . Property < string > ( LITERAL ) . IsConcurrencyToken ( false ) ; VAR0 . HasChangeTrackingStrategy ( ChangeTrackingStrategy . ChangingAndChangedNotifications ) ;
VAR0 = new EnumerableToQueryableMethodConvertingExpressionVisitor ( ) . Visit ( VAR0 ) ; VAR0 = new QueryMetadataExtractingExpressionVisitor ( VAR1 ) . Visit ( VAR0 ) ; VAR0 = new AllAnyToContainsRewritingExpressionVisitor ( ) . Visit ( VAR0 ) ; VAR0 = new GroupJoinFlatteningExpressionVisitor ( ) . Visit ( VAR0 ) ; VAR0 = new NullCheckRemovingExpressionVisitor ( ) . Visit ( VAR0 ) ; VAR0 = new EntityEqualityRewritingExpressionVisitor ( VAR1 ) . Rewrite ( VAR0 ) ; VAR0 = new SubqueryMemberPushdownExpressionVisitor ( ) . Visit ( VAR0 ) ; VAR0 = new NavigationExpandingExpressionVisitor ( VAR1 , VAR2 . EvaluatableExpressionFilter ) . Expand ( VAR0 ) ; VAR0 = new FunctionPreprocessingExpressionVisitor ( ) . Visit ( VAR0 ) ;
VAR0 . AppendLine ( LITERAL ) ; VAR0 . Append ( LITERAL ) ; VAR0 . Visit ( VAR1 ) ; VAR0 . AppendLine ( LITERAL ) ; VAR0 . Append ( LITERAL ) ; VAR0 . Visit ( VAR2 ) ; VAR0 . AppendLine ( LITERAL ) ;
VAR0 . SetValueGenerationStrategy ( SqlServerValueGenerationStrategy . SequenceHiLo ) ; VAR0 . SetHiLoSequenceName ( VAR1 ) ; VAR0 . SetHiLoSequenceSchema ( VAR2 ) ; VAR0 . SetIdentitySeed ( null ) ; VAR0 . SetIdentityIncrement ( null ) ;
VAR0 . SetValueGenerationStrategy ( SqlServerValueGenerationStrategy . IdentityColumn ) ; VAR0 . SetIdentitySeed ( VAR1 ) ; VAR0 . SetIdentityIncrement ( VAR2 ) ; VAR0 . SetHiLoSequenceName ( null ) ; VAR0 . SetHiLoSequenceSchema ( null ) ;
Assert . True ( VAR0 . Metadata . IsClustered ( ) ) ; Assert . NotNull ( VAR0 . IsClustered ( false , fromDataAnnotation : true ) ) ; Assert . False ( VAR0 . Metadata . IsClustered ( ) ) ; Assert . Null ( VAR0 . IsClustered ( true ) ) ; Assert . False ( VAR0 . Metadata . IsClustered ( ) ) ;
Assert . Null ( VAR0 . GetSrid ( ) ) ; VAR0 . SetSrid ( 1 ) ; Assert . Equal ( 1 , VAR0 . GetSrid ( ) ) ; VAR0 . SetSrid ( null ) ; Assert . Null ( VAR0 . GetSrid ( ) ) ;
Assert . NotNull ( VAR0 . IsClustered ( true ) ) ; Assert . True ( VAR0 . Metadata . GetSqlServerIsClustered ( ) ) ; Assert . NotNull ( VAR0 . IsClustered ( false , fromDataAnnotation : true ) ) ; Assert . False ( VAR0 . Metadata . GetSqlServerIsClustered ( ) ) ; Assert . Null ( VAR0 . IsClustered ( true ) ) ; Assert . False ( VAR0 . Metadata . GetSqlServerIsClustered ( ) ) ;
var VAR3 = Guid . NewGuid ( ) ; var VAR0 = CreateCommand ( VAR2 , VAR3 , DbCommandMethod . ExecuteScalar ) ; VAR1 . Open ( ) ; var VAR4 = DateTimeOffset . UtcNow ;
VAR0 ??  = new HashSet < ISupplier > ( ) ; VAR1 ??  = new HashSet < IDiscontinuedProduct > ( ) ; VAR2 ??  = new HashSet < IProductReview > ( ) ; VAR3 ??  = new HashSet < IProductPhoto > ( ) ; VAR4 ??  = new HashSet < IBarcode > ( ) ;
Assert . Contains ( VAR1 . VAR2 , VAR10 => ReferenceEquals ( VAR10 , VAR0 ) ) ; Assert . Same ( VAR1 , VAR0 . VAR3 ) ; Assert . Null ( VAR1 . VAR4 ) ; Assert . Equal ( VAR5 , VAR6 . Entry ( VAR1 ) . State ) ; Assert . Equal ( VAR7 == null ? EntityState . Added : VAR5 , VAR6 . Entry ( VAR0 ) . State ) ; Assert . Contains ( VAR0 . VAR9 , VAR10 => ReferenceEquals ( VAR10 , VAR8 ) ) ;
Assert . Contains ( VAR1 . VAR2 , VAR10 => ReferenceEquals ( VAR10 , VAR0 ) ) ; Assert . Null ( VAR1 . VAR3 ) ; Assert . Same ( VAR1 , VAR0 . VAR4 ) ; Assert . Equal ( VAR5 , VAR6 . Entry ( VAR1 ) . State ) ; Assert . Equal ( VAR7 == null ? EntityState . Added : VAR5 , VAR6 . Entry ( VAR0 ) . State ) ; Assert . Contains ( VAR0 . VAR9 , VAR10 => ReferenceEquals ( VAR10 , VAR8 ) ) ;
Assert . Equal ( LITERAL , VAR0 . Carbonation ) ; var VAR1 = VAR2 . OfType < Lilt > ( ) . Single ( ) ; Assert . Equal ( LITERAL , VAR1 . SugarGrams ) ; Assert . Equal ( LITERAL , VAR1 . Carbonation ) ;
IMutableModel VAR0 = new Model ( TestRelationalConventionSetBuilder . Build ( ) ) ; var VAR1 = VAR0 . AddEntityType ( typeof ( T1 ) ) ; var VAR2 = VAR1 . FindProperty ( LITERAL ) ; VAR2 . ValueGenerated = VAR3 ? ValueGenerated . OnAdd : ValueGenerated . Never ; VAR2 . SetColumnName ( LITERAL ) ; VAR1 . SetPrimaryKey ( VAR2 ) ; var VAR4 = VAR1 . FindProperty ( LITERAL ) ; VAR4 . IsConcurrencyToken = VAR5 ; VAR4 . SetColumnName ( LITERAL ) ; VAR4 . ValueGenerated = VAR5 ? ValueGenerated . OnAddOrUpdate : ValueGenerated . Never ; var VAR6 = VAR1 . FindProperty ( LITERAL ) ;
var VAR0 = sqlite3_column_database_name ( VAR1 . VAR2 , VAR3 ) . utf8_to_string ( ) ; VAR4 [ VAR5 ] = VAR0 ; var VAR6 = sqlite3_column_origin_name ( VAR1 . VAR2 , VAR3 ) . utf8_to_string ( ) ; VAR4 [ VAR7 ] = VAR6 ; VAR4 [ VAR8 ] = DBNull . Value ; var VAR9 = sqlite3_column_table_name ( VAR1 . VAR2 , VAR3 ) . utf8_to_string ( ) ; VAR4 [ VAR10 ] = VAR9 ; VAR4 [ VAR11 ] = GetFieldType ( VAR3 ) ; VAR4 [ VAR12 ] = GetDataTypeName ( VAR3 ) ; VAR4 [ VAR13 ] = VAR6 != GetName ( VAR3 ) ; VAR4 [ VAR14 ] = VAR6 == null ; VAR4 [ VAR15 ] = DBNull . Value ;
ValueGenerationConvention VAR5 = new SqlServerValueGenerationConvention ( Dependencies , RelationalDependencies ) ; ReplaceConvention ( VAR1 . EntityTypeBaseTypeChangedConventions , VAR5 ) ; var VAR2 = new SqlServerMemoryOptimizedTablesConvention ( Dependencies , RelationalDependencies ) ; VAR1 . EntityTypeAnnotationChangedConventions . Add ( VAR2 ) ; ReplaceConvention ( VAR1 . EntityTypePrimaryKeyChangedConventions , VAR5 ) ; VAR1 . KeyAddedConventions . Add ( VAR2 ) ; ReplaceConvention ( VAR1 . ForeignKeyAddedConventions , VAR5 ) ; ReplaceConvention ( VAR1 . ForeignKeyRemovedConventions , VAR5 ) ; var VAR3 = new SqlServerIndexConvention ( Dependencies , RelationalDependencies , VAR4 ) ;
Assert . NotNull ( ( ( IConventionIndex ) VAR0 ) . Builder ) ; Assert . NotNull ( ( ( IConventionIndex ) VAR1 ) . Builder ) ; Assert . Equal ( LITERAL , VAR1 . Properties . Count ) ; Assert . Same ( VAR1 , VAR2 . FindIndex ( new [ ] { VAR3 , VAR4 } ) ) ; Assert . Same ( VAR3 , VAR1 . Properties [ 0 ] ) ; Assert . Same ( VAR4 , VAR1 . Properties [ 1 ] ) ; Assert . True ( VAR3 . IsIndex ( ) ) ; Assert . Equal ( new [ ] { VAR0 , VAR1 } , VAR3 . GetContainingIndexes ( ) . ToArray ( ) ) ;
VAR0 . EntityTypeAddedConventions . Add ( new DerivedTypeDiscoveryConvention ( VAR6 ) ) ; VAR0 . EntityTypeIgnoredConventions . Add ( VAR2 ) ; var VAR3 = new DiscriminatorConvention ( VAR6 ) ; VAR0 . EntityTypeRemovedConventions . Add ( new OwnedTypesConvention ( VAR6 ) ) ; VAR0 . EntityTypeRemovedConventions . Add ( VAR3 ) ; var VAR4 = new ForeignKeyIndexConvention ( VAR6 ) ; var VAR5 = new ValueGeneratorConvention ( VAR6 ) ;
VAR0 . ModelInitializedConventions . Add ( new RelationalMaxIdentifierLengthConvention ( LITERAL , VAR2 ) ) ; ValueGeneratorConvention VAR1 = new SqlServerValueGeneratorConvention ( VAR2 ) ; ReplaceConvention ( VAR0 . EntityTypeBaseTypeChangedConventions , VAR1 ) ; var VAR3 = new SqlServerMemoryOptimizedTablesConvention ( VAR2 ) ; VAR0 . EntityTypeAnnotationChangedConventions . Add ( VAR3 ) ; ReplaceConvention ( VAR0 . EntityTypePrimaryKeyChangedConventions , VAR1 ) ;
RunConvention ( VAR0 ) ; Assert . Same ( VAR0 . Metadata , VAR1 . Metadata . BaseType ) ; Assert . Same ( VAR0 . Metadata , VAR2 . Metadata . BaseType ) ; RunConvention ( VAR1 ) ;
var VAR0 = VAR1 . PrimaryKey ( VAR2 , ConfigurationSource . Convention ) ; RunConvention ( VAR1 ) ; var VAR3 = VAR0 . Metadata . Properties ;
RunConvention ( VAR0 ) ; Assert . Equal ( ValueGenerated . Never , ( ( IProperty ) VAR1 ) . ValueGenerated ) ; VAR2 . HasNoRelationship ( VAR0 . Metadata , ConfigurationSource . Convention ) ; RunConvention ( VAR2 ) ;
var VAR0 = VAR1 . Entry ( VAR2 ) . Collection ( VAR3 => VAR3 . VAR4 ) . FindEntry ( VAR5 ) ; Assert . Equal ( VAR2 . VAR6 , VAR0 . Property ( LITERAL ) . CurrentValue ) ; Assert . Equal ( EntityState . Added , VAR0 . State ) ; Assert . Equal ( nameof ( VAR7 . VAR4 ) , VAR0 . Metadata . DefiningNavigationName ) ; Assert . Contains ( VAR8 , VAR5 . VAR9 ) ; Assert . Same ( VAR5 , VAR8 . VAR7 ) ; var VAR10 = VAR0 . Collection ( VAR3 => VAR3 . VAR9 ) . FindEntry ( VAR8 ) ;
var VAR0 = VAR1 . Entry ( VAR2 ) . Collection ( VAR3 => VAR3 . VAR4 ) . FindEntry ( VAR5 ) ; Assert . Equal ( VAR2 . VAR6 , VAR0 . Property ( LITERAL ) . CurrentValue ) ; Assert . Equal ( EntityState . Added , VAR0 . State ) ; Assert . Equal ( nameof ( ParentPN . VAR4 ) , VAR0 . Metadata . DefiningNavigationName ) ; Assert . Contains ( VAR7 , VAR5 . VAR8 ) ; var VAR9 = VAR0 . Collection ( VAR3 => VAR3 . VAR8 ) . FindEntry ( VAR7 ) ;
ValidateSharedTableCompatibility ( VAR0 , VAR1 , VAR3 ) ; ValidateSharedColumnsCompatibility ( VAR0 , VAR1 , VAR3 ) ; ValidateSharedKeysCompatibility ( VAR0 , VAR1 , VAR3 ) ; ValidateSharedForeignKeysCompatibility ( VAR0 , VAR1 , VAR3 ) ; ValidateSharedIndexesCompatibility ( VAR0 , VAR1 , VAR3 ) ;
var VAR0 = VAR1 . Property ( typeof ( string ) , VAR2 , ConfigurationSource . Convention ) ; VAR0 . HasValueGenerator ( ( VAR3 , VAR4 ) => new IdValueGenerator ( ) , ConfigurationSource . Convention ) ; VAR1 . HasKey ( new [ ] { VAR0 . Metadata } , ConfigurationSource . Convention ) ; var VAR5 = VAR1 . Property ( typeof ( JObject ) , VAR6 , ConfigurationSource . Convention ) ;
Assert . Equal ( SqlServerValueGenerationStrategy . SequenceHiLo , VAR0 . GetSqlServerValueGenerationStrategy ( ) ) ; Assert . Equal ( ValueGenerated . OnAdd , VAR0 . ValueGenerated ) ; Assert . Equal ( LITERAL , VAR0 . GetSqlServerHiLoSequenceName ( ) ) ; Assert . Equal ( LITERAL , VAR0 . GetSqlServerHiLoSequenceSchema ( ) ) ; Assert . NotNull ( VAR1 . FindSequence ( LITERAL , LITERAL ) ) ; var VAR2 = VAR1 . FindSequence ( LITERAL , LITERAL ) ;
Assert . Null ( VAR0 . Property ( typeof ( string ) , nameof ( SpecialOrder . VAR1 ) , ConfigurationSource . DataAnnotation ) ) ; Assert . Null ( VAR2 . Metadata . FindPrimaryKey ( ) ) ; Assert . NotNull ( VAR2 . PrimaryKey ( new [ ] { VAR3 . Metadata . Name } , ConfigurationSource . Explicit ) ) ; VAR3 = VAR0 . Property ( typeof ( string ) , nameof ( SpecialOrder . VAR1 ) , ConfigurationSource . Explicit ) ;
var VAR0 = VAR1 ; Assert . Null ( VAR0 . GetDatabaseName ( ) ) ; VAR0 . SetDatabaseName ( LITERAL ) ; Assert . Equal ( LITERAL , VAR0 . GetDatabaseName ( ) ) ; VAR0 . SetDatabaseName ( null ) ; Assert . Null ( VAR0 . GetDatabaseName ( ) ) ;
var VAR0 = VAR1 . Metadata . GetDiscriminatorProperty ( ) ; Assert . NotNull ( VAR0 ) ; Assert . Same ( VAR0 , VAR2 . Metadata . GetDiscriminatorProperty ( ) ) ; Assert . Equal ( typeof ( EntityBase ) . VAR3 , VAR2 . Metadata . GetDiscriminatorValue ( ) ) ; Assert . Equal ( typeof ( Entity ) . VAR3 , VAR1 . Metadata . GetDiscriminatorValue ( ) ) ; Assert . NotNull ( VAR1 . HasBaseType ( ( Type ) null , ConfigurationSource . DataAnnotation ) ) ; Assert . True ( new DiscriminatorConvention ( VAR4 ) . Apply ( VAR1 , oldBaseType : VAR2 . Metadata ) ) ; Assert . Null ( VAR2 . Metadata . GetDiscriminatorProperty ( ) ) ; Assert . Null ( VAR1 . Metadata . GetDiscriminatorProperty ( ) ) ;
Assert . Equal ( LITERAL , VAR0 . GetName ( ) ) ; VAR0 . SetName ( LITERAL ) ; Assert . Equal ( LITERAL , VAR0 . GetName ( ) ) ; VAR0 . SetName ( null ) ; Assert . Equal ( LITERAL , VAR0 . GetName ( ) ) ;
Assert . Equal ( VAR0 . GetConstraintName ( ) , VAR1 . GetConstraintName ( ) ) ; var VAR2 = VAR0 . DeclaringEntityType . GetDeclaredIndexes ( ) . Single ( ) ; var VAR3 = VAR1 . DeclaringEntityType . GetDeclaredIndexes ( ) . Single ( ) ; Assert . NotSame ( VAR2 , VAR3 ) ; Assert . Equal ( VAR2 . GetName ( ) , VAR3 . GetName ( ) ) ;
Assert . NotNull ( VAR0 . ValueGenerated ( ValueGenerated . OnAddOrUpdate , ConfigurationSource . DataAnnotation ) ) ; Assert . NotNull ( VAR0 . ValueGenerated ( ValueGenerated . Never , ConfigurationSource . DataAnnotation ) ) ; Assert . Equal ( ValueGenerated . Never , VAR1 . ValueGenerated ) ; Assert . Null ( VAR0 . ValueGenerated ( ValueGenerated . OnAddOrUpdate , ConfigurationSource . Convention ) ) ;
Assert . NotNull ( VAR0 . ValueGenerated ( ValueGenerated . OnAddOrUpdate , ConfigurationSource . DataAnnotation ) ) ; Assert . Null ( VAR0 . ValueGenerated ( ValueGenerated . Never , ConfigurationSource . DataAnnotation ) ) ; Assert . Equal ( ValueGenerated . OnAddOrUpdate , VAR1 . ValueGenerated ) ; Assert . NotNull ( VAR0 . ValueGenerated ( ValueGenerated . Never , ConfigurationSource . Explicit ) ) ;
Assert . NotNull ( VAR0 . HasMaxLength ( 1 , ConfigurationSource . DataAnnotation ) ) ; Assert . NotNull ( VAR0 . HasMaxLength ( LITERAL , ConfigurationSource . DataAnnotation ) ) ; Assert . Equal ( LITERAL , VAR1 . GetMaxLength ( ) . Value ) ; Assert . Null ( VAR0 . HasMaxLength ( 1 , ConfigurationSource . Convention ) ) ;
Assert . NotNull ( VAR0 . HasMaxLength ( 1 , ConfigurationSource . DataAnnotation ) ) ; Assert . Null ( VAR0 . HasMaxLength ( LITERAL , ConfigurationSource . DataAnnotation ) ) ; Assert . Equal ( 1 , VAR1 . GetMaxLength ( ) . Value ) ; Assert . NotNull ( VAR0 . HasMaxLength ( LITERAL , ConfigurationSource . Explicit ) ) ;
Assert . NotNull ( VAR0 . IsRequired ( true , ConfigurationSource . DataAnnotation ) ) ; Assert . Null ( VAR0 . IsRequired ( false , ConfigurationSource . DataAnnotation ) ) ; Assert . False ( VAR1 . IsNullable ) ; Assert . NotNull ( VAR0 . IsRequired ( false , ConfigurationSource . Explicit ) ) ;
Assert . NotNull ( VAR0 . BeforeSave ( PropertySaveBehavior . Throw , ConfigurationSource . DataAnnotation ) ) ; Assert . Null ( VAR0 . BeforeSave ( PropertySaveBehavior . Ignore , ConfigurationSource . DataAnnotation ) ) ; Assert . Equal ( PropertySaveBehavior . Throw , VAR1 . GetBeforeSaveBehavior ( ) ) ; Assert . NotNull ( VAR0 . BeforeSave ( PropertySaveBehavior . Ignore , ConfigurationSource . Explicit ) ) ;
Assert . NotNull ( VAR0 . AfterSave ( PropertySaveBehavior . Throw , ConfigurationSource . DataAnnotation ) ) ; Assert . NotNull ( VAR0 . AfterSave ( PropertySaveBehavior . Ignore , ConfigurationSource . DataAnnotation ) ) ; Assert . Equal ( PropertySaveBehavior . Ignore , VAR1 . GetAfterSaveBehavior ( ) ) ; Assert . Null ( VAR0 . AfterSave ( PropertySaveBehavior . Save , ConfigurationSource . Convention ) ) ;
Assert . NotNull ( VAR0 . IsUnique ( true , ConfigurationSource . Convention ) ) ; Assert . NotNull ( VAR0 . IsUnique ( false , ConfigurationSource . DataAnnotation ) ) ; Assert . False ( VAR1 . IsUnique ) ; Assert . Null ( VAR0 . IsUnique ( true , ConfigurationSource . Convention ) ) ;
Assert . NotNull ( VAR0 . IsUnique ( true , ConfigurationSource . DataAnnotation ) ) ; Assert . Null ( VAR0 . IsUnique ( false , ConfigurationSource . DataAnnotation ) ) ; Assert . True ( VAR1 . IsUnique ) ; Assert . NotNull ( VAR0 . IsUnique ( false , ConfigurationSource . Explicit ) ) ;
Assert . NotNull ( VAR0 . HasAnnotation ( LITERAL , 1 , ConfigurationSource . Convention ) ) ; Assert . NotNull ( VAR0 . HasAnnotation ( LITERAL , LITERAL , ConfigurationSource . DataAnnotation ) ) ; Assert . Equal ( LITERAL , VAR1 . GetAnnotations ( ) . Single ( ) . Value ) ; Assert . Null ( VAR0 . HasAnnotation ( LITERAL , 1 , ConfigurationSource . Convention ) ) ;
var VAR0 = VAR1 . AddEntityType ( typeof ( VAR2 ) . FullName , ConfigurationSource . Explicit ) ; var VAR3 = CreateModelBuilder ( VAR1 ) ; Assert . Same ( VAR0 , VAR3 . Entity ( typeof ( VAR2 ) . FullName , ConfigurationSource . Convention ) . Metadata ) ; Assert . Null ( VAR3 . Ignore ( typeof ( VAR2 ) . FullName , ConfigurationSource . DataAnnotation ) ) ; Assert . NotNull ( VAR1 . FindEntityType ( typeof ( VAR2 ) . FullName ) ) ; Assert . NotNull ( VAR3 . Ignore ( typeof ( VAR2 ) . FullName , ConfigurationSource . Explicit ) ) ;
Assert . Same ( VAR0 , new ValueGeneratorConvention ( new TestLogger < DbLoggerCategory . Model , TestLoggingDefinitions > ( ) ) . Apply ( VAR0 ) ) ; Assert . False ( VAR1 [ 0 ] . RequiresValueGenerator ( ) ) ; Assert . Equal ( ValueGenerated . Never , VAR1 [ 0 ] . ValueGenerated ) ; VAR2 . RemoveForeignKey ( VAR0 . Metadata , ConfigurationSource . Convention ) ; new ValueGeneratorConvention ( new TestLogger < DbLoggerCategory . Model , TestLoggingDefinitions > ( ) ) . Apply ( VAR2 , VAR0 . Metadata ) ;
var VAR0 = CreateModel ( ) ; var VAR1 = VAR0 . AddEntityType ( LITERAL ) ; VAR1 . AddProperty ( LITERAL , typeof ( int ) ) ; VAR1 . AddProperty ( LITERAL , typeof ( string ) ) ; var VAR2 = InMemoryTestHelpers . Instance . CreateContextServices ( VAR0 ) ; var VAR3 = VAR2 . GetRequiredService < IStateManager > ( ) ; var VAR4 = VAR2 . GetRequiredService < IInternalEntityEntryFactory > ( ) ; var VAR5 = VAR4 . Create ( VAR3 , VAR1 , new Random ( ) ) ;
var VAR0 = ( ( IMutableModel ) new Model ( ) ) . AddEntityType ( typeof ( TEntity ) ) ; VAR0 . AddProperty ( nameof ( Blog . VAR1 ) , typeof ( int ) ) ; VAR0 . AddProperty ( nameof ( Blog . VAR2 ) , typeof ( string ) ) ; VAR0 . AddProperty ( nameof ( Blog . VAR3 ) , typeof ( string ) ) ; VAR0 . AddProperty ( nameof ( Blog . VAR4 ) , typeof ( int ) ) ; VAR0 . AddProperty ( LITERAL , typeof ( Guid ? ) ) ; VAR0 . AddProperty ( LITERAL , typeof ( string ) ) ; VAR0 . AddProperty ( LITERAL , typeof ( string ) ) ; VAR0 . AddProperty ( LITERAL , typeof ( string ) ) ; VAR0 . AddProperty ( LITERAL , typeof ( string ) ) ; VAR0 . AddProperty ( LITERAL , typeof ( string ) ) ; VAR0 . AddProperty ( LITERAL , typeof ( string ) ) ; VAR5 . Apply ( ( ( Model ) VAR0 . Model ) . Builder ) ;
VAR0 . SetPrimaryKey ( new [ ] { VAR1 , VAR2 } ) ; var VAR3 = VAR4 . AddEntityType ( typeof ( SomeEntity ) ) ; VAR3 . BaseType = VAR5 ; var VAR6 = VAR3 . AddProperty ( LITERAL , typeof ( string ) ) ; VAR6 . IsConcurrencyToken = true ; VAR6 . ValueGenerated = ValueGenerated . OnAdd ; var VAR7 = VAR4 . AddEntityType ( typeof ( SomeDependentEntity ) ) ; VAR7 . BaseType = VAR0 ; var VAR8 = VAR7 . AddProperty ( LITERAL , typeof ( int ) ) ; VAR7 . AddForeignKey ( new [ ] { VAR8 } , VAR3 . FindPrimaryKey ( ) , VAR3 ) ;
Assert . True ( VAR0 . Properties . Single ( ) . IsShadowProperty ( ) ) ; Assert . Null ( VAR0 . GetPropertiesConfigurationSource ( ) ) ; Assert . Same ( VAR0 . DeclaringEntityType , VAR1 . Metadata ) ; Assert . Same ( VAR0 . PrincipalEntityType , VAR2 . Metadata ) ; Assert . True ( VAR0 . IsUnique ) ;
Assert . False ( VAR0 . IsShadowProperty ( ) ) ; Assert . Equal ( LITERAL , VAR0 . VAR1 ) ; Assert . Same ( typeof ( string ) , VAR0 . VAR2 ) ; Assert . Same ( VAR3 , VAR0 . DeclaringEntityType ) ; Assert . Same ( HiddenFieldBase . VAR4 , VAR0 . PropertyInfo ) ; Assert . Null ( VAR0 . FieldInfo ) ;
Assert . Equal ( LITERAL , VAR0 . Relational ( ) . ConstraintName ) ; Assert . Equal ( LITERAL , ( ( IForeignKey ) VAR0 ) . Relational ( ) . ConstraintName ) ; VAR0 . Relational ( ) . ConstraintName = LITERAL ; Assert . Equal ( LITERAL , VAR0 . Relational ( ) . ConstraintName ) ; Assert . Equal ( LITERAL , ( ( IForeignKey ) VAR0 ) . Relational ( ) . ConstraintName ) ; VAR0 . Relational ( ) . ConstraintName = LITERAL ; Assert . Equal ( LITERAL , VAR0 . Relational ( ) . ConstraintName ) ; Assert . Equal ( LITERAL , ( ( IForeignKey ) VAR0 ) . Relational ( ) . ConstraintName ) ; VAR0 . Relational ( ) . ConstraintName = null ; Assert . Equal ( LITERAL , VAR0 . Relational ( ) . ConstraintName ) ; Assert . Equal ( LITERAL , ( ( IForeignKey ) VAR0 ) . Relational ( ) . ConstraintName ) ;
Assert . NotSame ( VAR0 . DeclaringEntityType , VAR1 . DeclaringEntityType ) ; Assert . Equal ( typeof ( int ) , VAR0 . DeclaringEntityType . GetForeignKeys ( ) . Single ( ) . Properties . Single ( ) . ClrType ) ; Assert . Equal ( typeof ( int ) , VAR0 . DeclaringEntityType . GetForeignKeys ( ) . Single ( ) . Properties . Single ( ) . ClrType ) ; Assert . Equal ( LITERAL , VAR0 [ LITERAL ] ) ; Assert . Equal ( LITERAL , VAR2 . GetEntityTypes ( ) . Count ( VAR3 => VAR3 . ClrType == typeof ( BookLabel ) ) ) ; Assert . Equal ( LITERAL , VAR2 . GetEntityTypes ( ) . Count ( ) ) ; VAR4 . Entity < Book > ( ) . OwnsOne ( VAR5 => VAR5 . Label ) . Ignore ( VAR6 => VAR6 . Book ) ; VAR4 . Entity < Book > ( ) . OwnsOne ( VAR5 => VAR5 . AlternateLabel ) . Ignore ( VAR6 => VAR6 . Book ) ; VAR4 . FinalizeModel ( ) ;
Assert . Same ( VAR0 , new ValueGeneratorConvention ( new TestLogger < DbLoggerCategory . Model > ( ) ) . Apply ( VAR0 ) ) ; Assert . False ( VAR1 [ 0 ] . RequiresValueGenerator ( ) ) ; Assert . Equal ( ValueGenerated . Never , VAR1 [ 0 ] . ValueGenerated ) ; VAR2 . RemoveForeignKey ( VAR0 . Metadata , ConfigurationSource . Convention ) ; new ValueGeneratorConvention ( new TestLogger < DbLoggerCategory . Model > ( ) ) . Apply ( VAR2 , VAR0 . Metadata ) ;
Assert . Null ( VAR1 . VAR2 ) ; Assert . Same ( VAR1 , VAR0 . VAR3 ) ; Assert . Same ( VAR4 , VAR5 . VAR2 ) ; Assert . Same ( VAR5 , VAR4 . VAR3 ) ; Assert . Null ( VAR1 . VAR6 ) ; Assert . Equal ( VAR5 . VAR6 , VAR4 . VAR7 ) ; VAR8 . SetEntityState ( EntityState . Detached ) ; Assert . Null ( VAR1 . VAR2 ) ; Assert . Same ( VAR1 , VAR0 . VAR3 ) ; Assert . Same ( VAR4 , VAR5 . VAR2 ) ; Assert . Same ( VAR5 , VAR4 . VAR3 ) ; Assert . Null ( VAR1 . VAR6 ) ;
var VAR0 = CreateConventionlessModelBuilder ( ) . Model ; var VAR1 = VAR0 . AddEntityType ( typeof ( Abstract ) ) ; SetPrimaryKey ( VAR1 ) ; var VAR2 = VAR0 . AddEntityType ( typeof ( Generic <  > ) ) ; SetBaseType ( VAR2 , VAR1 ) ;
var VAR0 = CreateConventionlessModelBuilder ( ) . Model ; var VAR1 = VAR0 . AddEntityType ( typeof ( ChangedOnlyEntity ) ) ; var VAR2 = VAR1 . AddProperty ( LITERAL , null ) ; VAR1 . SetPrimaryKey ( VAR2 ) ; VAR0 . SetChangeTrackingStrategy ( VAR3 ) ;
var VAR0 = CreateConventionlessModelBuilder ( ) . Model ; var VAR1 = VAR0 . AddEntityType ( typeof ( FullNotificationEntity ) ) ; var VAR2 = VAR1 . AddProperty ( LITERAL , null ) ; VAR1 . SetPrimaryKey ( VAR2 ) ; VAR0 . SetChangeTrackingStrategy ( VAR3 ) ;
VAR0 . UnionWith ( VAR1 . GetRuntimeProperties ( ) . Values . Where ( VAR2 => VAR2 . IsCandidateProperty ( ) ) . Select ( VAR2 => VAR2 . GetSimpleMemberName ( ) ) ) ; VAR0 . ExceptWith ( VAR1 . GetProperties ( ) . Select ( VAR3 => VAR3 . Name ) ) ; VAR0 . ExceptWith ( VAR1 . GetNavigations ( ) . Select ( VAR3 => VAR3 . Name ) ) ; VAR0 . ExceptWith ( VAR1 . GetServiceProperties ( ) . Select ( VAR3 => VAR3 . Name ) ) ; VAR0 . RemoveWhere ( VAR3 => VAR1 . Builder . IsIgnored ( VAR3 , ConfigurationSource . Convention ) ) ;
VAR0 . FinalizeModel ( ) ; var VAR1 = CreateModelBuilder ( ) ; VAR2 ( VAR1 ) ; VAR3 ( VAR1 ) ; VAR1 . FinalizeModel ( ) ;
VAR6 . Log . Clear ( ) ; VAR1 . VAR2 = LITERAL ; VAR3 . ChangeTracker . DetectChanges ( ) ; var ( level , _ , message , _ , _ ) = VAR6 . Log . Single ( VAR4 => VAR4 . VAR5 . VAR5 == CoreEventId . PropertyChangeDetected . VAR5 ) ;
var ( level , _ , message , _ , _ ) = VAR3 . Log . Single ( VAR1 => VAR1 . VAR2 . VAR2 == CoreEventId . SaveChangesStarting . VAR2 ) ; Assert . Equal ( LogLevel . Debug , level ) ; Assert . Equal ( CoreStrings . LogSaveChangesStarting . GenerateMessage ( nameof ( LikeAZooContext ) ) , message ) ; ( level , _ , message , _ , _ ) = VAR3 . Log . Single ( VAR1 => VAR1 . VAR2 . VAR2 == CoreEventId . SaveChangesCompleted . VAR2 ) ;
VAR0 [ 0 ] . OneToOne_Required_FK_Inverse2 = VAR1 [ 0 ] ; VAR0 [ 1 ] . OneToOne_Required_FK_Inverse2 = VAR1 [ 1 ] ; VAR0 [ LITERAL ] . OneToOne_Required_FK_Inverse2 = VAR1 [ LITERAL ] ; VAR0 [ LITERAL ] . OneToOne_Required_FK_Inverse2 = VAR1 [ LITERAL ] ; VAR0 [ LITERAL ] . OneToOne_Required_FK_Inverse2 = VAR1 [ LITERAL ] ; VAR0 [ LITERAL ] . OneToOne_Required_FK_Inverse2 = VAR1 [ LITERAL ] ; VAR0 [ LITERAL ] . OneToOne_Required_FK_Inverse2 = VAR1 [ LITERAL ] ; VAR0 [ LITERAL ] . OneToOne_Required_FK_Inverse2 = VAR1 [ LITERAL ] ; VAR0 [ LITERAL ] . OneToOne_Required_FK_Inverse2 = VAR1 [ LITERAL ] ; VAR0 [ LITERAL ] . OneToOne_Required_FK_Inverse2 = VAR1 [ LITERAL ] ;
VAR0 [ 0 ] . OneToOne_Optional_PK_Inverse2 = VAR1 [ 0 ] ; VAR0 [ LITERAL ] . OneToOne_Optional_PK_Inverse2 = VAR1 [ LITERAL ] ; VAR0 [ LITERAL ] . OneToOne_Optional_PK_Inverse2 = VAR1 [ LITERAL ] ; VAR0 [ LITERAL ] . OneToOne_Optional_PK_Inverse2 = VAR1 [ LITERAL ] ; VAR0 [ LITERAL ] . OneToOne_Optional_PK_Inverse2 = VAR1 [ LITERAL ] ; VAR0 [ LITERAL ] . OneToOne_Optional_FK_Inverse2 = VAR1 [ 1 ] ; VAR0 [ LITERAL ] . OneToOne_Optional_FK_Inverse2 = VAR1 [ LITERAL ] ; VAR0 [ LITERAL ] . OneToOne_Optional_FK_Inverse2 = VAR1 [ LITERAL ] ; VAR0 [ LITERAL ] . OneToOne_Optional_FK_Inverse2 = VAR1 [ LITERAL ] ; VAR0 [ 0 ] . OneToOne_Optional_FK_Inverse2 = VAR1 [ LITERAL ] ;
Assert . Equal ( StoreTypePostfix . PrecisionAndScale , VAR0 . StoreTypePostfix ) ; var VAR1 = new FakeValueConverter ( ) ; VAR0 = ( RelationalTypeMapping ) VAR2 . Clone ( VAR1 ) ; Assert . NotSame ( VAR2 , VAR0 ) ; Assert . Same ( VAR2 . GetType ( ) , VAR0 . GetType ( ) ) ; Assert . Equal ( LITERAL , VAR0 . StoreType ) ; Assert . Equal ( DbType . VarNumeric , VAR0 . DbType ) ; Assert . Null ( VAR0 . Size ) ; Assert . NotSame ( VAR2 . Converter , VAR0 . Converter ) ; Assert . Same ( VAR2 . Comparer , VAR0 . Comparer ) ; Assert . Same ( VAR2 . KeyComparer , VAR0 . KeyComparer ) ; Assert . Same ( typeof ( object ) , VAR0 . ClrType ) ; Assert . Equal ( StoreTypePostfix . PrecisionAndScale , VAR0 . StoreTypePostfix ) ;
var VAR1 = CreateDatabaseCreator ( VAR2 ) ; Assert . True ( await VAR1 . EnsureCreatedAsync ( ) ) ; Assert . False ( await VAR1 . EnsureCreatedAsync ( ) ) ; Assert . False ( await VAR1 . EnsureCreatedAsync ( ) ) ; VAR1 = CreateDatabaseCreator ( VAR2 ) ;
Assert . NotEqual ( default , VAR0 ) ; Assert . Equal ( default , VAR1 ) ; VAR2 . SaveChanges ( ) ; VAR3 = VAR4 . VAR5 ; var VAR6 = VAR4 . VAR7 ; Assert . NotEqual ( default , VAR3 ) ; Assert . NotEqual ( default , VAR6 ) ;
VAR0 . Process ( BenchmarkRunner . Run < InitializationSqliteTests > ( ) ) ; VAR0 . Process ( BenchmarkRunner . Run < DbSetOperationSqliteTests . AddDataVariations > ( ) ) ; VAR0 . Process ( BenchmarkRunner . Run < DbSetOperationSqliteTests . ExistingDataVariations > ( ) ) ; VAR0 . Process ( BenchmarkRunner . Run < FixupSqliteTests . ChildVariations > ( ) ) ; VAR0 . Process ( BenchmarkRunner . Run < FixupSqliteTests . ParentVariations > ( ) ) ; VAR0 . Process ( BenchmarkRunner . Run < FuncletizationSqliteTests > ( ) ) ; VAR0 . Process ( BenchmarkRunner . Run < NavigationsQuerySqliteTests > ( ) ) ; VAR0 . Process ( BenchmarkRunner . Run < QueryCompilationSqliteTests > ( ) ) ; VAR0 . Process ( BenchmarkRunner . Run < RawSqlQuerySqliteTests > ( ) ) ; VAR0 . Process ( BenchmarkRunner . Run < SimpleQuerySqliteTests > ( ) ) ; VAR0 . Process ( BenchmarkRunner . Run < SimpleUpdatePipelineSqliteTests . Insert > ( ) ) ; VAR0 . Process ( BenchmarkRunner . Run < SimpleUpdatePipelineSqliteTests . Update > ( ) ) ; VAR0 . Process ( BenchmarkRunner . Run < SimpleUpdatePipelineSqliteTests . Delete > ( ) ) ; VAR0 . Process ( BenchmarkRunner . Run < SimpleUpdatePipelineSqliteTests . Mixed > ( ) ) ;
Assert . Null ( VAR0 . GetProviderClrType ( ) ) ; VAR0 . SetProviderClrType ( typeof ( long ) ) ; Assert . Same ( typeof ( long ) , VAR0 . GetProviderClrType ( ) ) ; VAR0 . SetProviderClrType ( null ) ; Assert . Null ( VAR0 . GetProviderClrType ( ) ) ;
Assert . Equal ( LITERAL , VAR0 [ 0 ] . ConsumedProperties . First ( ) . Name ) ; Assert . Equal ( LITERAL , VAR0 [ 1 ] . ConsumedProperties . First ( ) . Name ) ; Assert . Equal ( LITERAL , VAR0 [ LITERAL ] . ConsumedProperties . First ( ) . Name ) ; Assert . Equal ( LITERAL , VAR0 [ LITERAL ] . ConsumedProperties . First ( ) . Name ) ; Assert . Equal ( LITERAL , VAR0 [ LITERAL ] . ConsumedProperties . First ( ) . Name ) ; Assert . Equal ( LITERAL , VAR0 [ LITERAL ] . ConsumedProperties . First ( ) . Name ) ; Assert . Equal ( LITERAL , VAR0 [ LITERAL ] . ConsumedProperties . First ( ) . Name ) ; Assert . Equal ( LITERAL , VAR0 [ LITERAL ] . ConsumedProperties . First ( ) . Name ) ; Assert . Equal ( LITERAL , VAR0 [ LITERAL ] . ConsumedProperties . First ( ) . Name ) ;
Assert . Equal ( nameof ( VAR1 ) , VAR2 . Metadata . FindOwnership ( ) . PrincipalToDependent . Name ) ; var VAR3 = VAR2 . Reference ( VAR4 => VAR4 . VAR5 ) . TargetEntry ; Assert . Equal ( VAR6 . VAR7 , VAR3 . Property ( LITERAL ) . CurrentValue ) ; Assert . Equal ( EntityState . Unchanged , VAR3 . State ) ; Assert . Equal ( nameof ( VAR1 . VAR5 ) , VAR3 . Metadata . DefiningNavigationName ) ; var VAR8 = VAR2 . Reference ( VAR4 => VAR4 . VAR9 ) . TargetEntry ; Assert . Equal ( VAR6 . VAR7 , VAR8 . Property ( LITERAL ) . CurrentValue ) ; Assert . Equal ( EntityState . Unchanged , VAR8 . State ) ; Assert . Equal ( nameof ( VAR1 . VAR9 ) , VAR8 . Metadata . DefiningNavigationName ) ; AssertFixup ( VAR10 , ( ) => { var VAR11 = VAR6 . VAR1 ; Assert . Same ( VAR6 , VAR11 . VAR0 ) ; var VAR12 = VAR11 . VAR5 ; var VAR13 = VAR11 . VAR9 ; Assert . Same ( VAR11 , VAR12 . VAR1 ) ; Assert . Same ( VAR11 , VAR13 . VAR1 ) ; Assert . Equal ( LITERAL , VAR12 . VAR14 ) ; Assert . Equal ( LITERAL , VAR13 . VAR14 ) ; Assert . Equal ( LITERAL , VAR10 . ChangeTracker . Entries ( ) . Count ( ) ) ; var VAR15 = VAR10 . Entry ( VAR6 ) ; Assert . Equal ( EntityState . Unchanged , VAR15 . State ) ; var VAR2 = VAR15 . Reference ( VAR4 => VAR4 . VAR1 ) . TargetEntry ; Assert . Equal ( VAR6 . VAR7 , VAR2 . Property ( LITERAL ) . CurrentValue ) ; Assert . Equal ( EntityState . Unchanged , VAR2 . State ) ; Assert . Equal ( nameof ( VAR1 ) , VAR2 . Metadata . FindOwnership ( ) . PrincipalToDependent . Name ) ; var VAR3 = VAR2 . Reference ( VAR4 => VAR4 . VAR5 ) . TargetEntry ; Assert . Equal ( VAR6 . VAR7 , VAR3 . Property ( LITERAL ) . CurrentValue ) ; Assert . Equal ( EntityState . Unchanged , VAR3 . State ) ; Assert . Equal ( nameof ( VAR1 . VAR5 ) , VAR3 . Metadata . DefiningNavigationName ) ; var VAR8 = VAR2 . Reference ( VAR4 => VAR4 . VAR9 ) . TargetEntry ; Assert . Equal ( VAR6 . VAR7 , VAR8 . Property ( LITERAL ) . CurrentValue ) ; Assert . Equal ( EntityState . Unchanged , VAR8 . State ) ; Assert . Equal ( nameof ( VAR1 . VAR9 ) , VAR8 . Metadata . DefiningNavigationName ) ; } ) ;
Assert . NotNull ( VAR0 . Set < MaxLengthDataTypes > ( ) . Where ( VAR1 => VAR1 . VAR2 == LITERAL && VAR1 . VAR3 == VAR4 ) . ToList ( ) . SingleOrDefault ( ) ) ; Assert . NotNull ( VAR0 . Set < MaxLengthDataTypes > ( ) . Where ( VAR1 => VAR1 . VAR2 == LITERAL && VAR1 . VAR5 == VAR6 ) . ToList ( ) . SingleOrDefault ( ) ) ; Assert . NotNull ( VAR0 . Set < MaxLengthDataTypes > ( ) . Where ( VAR1 => VAR1 . VAR2 == LITERAL && VAR1 . VAR7 == VAR8 ) . ToList ( ) . SingleOrDefault ( ) ) ; Assert . NotNull ( VAR0 . Set < MaxLengthDataTypes > ( ) . Where ( VAR1 => VAR1 . VAR2 == LITERAL && VAR1 . VAR9 == VAR10 ) . ToList ( ) . SingleOrDefault ( ) ) ;
var VAR0 = VAR1 . ComposeWith ( VAR2 ) . ConvertFromStore ; Assert . Equal ( Beatles . John , VAR0 ( LITERAL ) ) ; Assert . Equal ( Beatles . Paul , VAR0 ( LITERAL ) ) ; Assert . Equal ( Beatles . George , VAR0 ( 1 ) ) ; Assert . Equal ( Beatles . Ringo , VAR0 ( LITERAL ) ) ; Assert . Equal ( ( Beatles ) LITERAL , VAR0 ( LITERAL ) ) ; Assert . Equal ( default ( Beatles ) , VAR0 ( 0 ) ) ; Assert . Null ( VAR0 ( null ) ) ;
Assert . True ( VAR0 . Sqlite ( ConfigurationSource . Convention ) . HasName ( LITERAL ) ) ; Assert . Equal ( LITERAL , VAR0 . Metadata . Relational ( ) . Name ) ; Assert . True ( VAR0 . Sqlite ( ConfigurationSource . DataAnnotation ) . HasName ( LITERAL ) ) ; Assert . Equal ( LITERAL , VAR0 . Metadata . Relational ( ) . Name ) ; Assert . False ( VAR0 . Sqlite ( ConfigurationSource . Convention ) . HasName ( LITERAL ) ) ;
var VAR0 = new Order { VAR1 = LITERAL , VAR2 = LITERAL , VAR3 = DateTime . Parse ( LITERAL , CultureInfo . InvariantCulture ) } ; var VAR4 = new Order { VAR1 = LITERAL , VAR2 = LITERAL , VAR3 = DateTime . Parse ( LITERAL , CultureInfo . InvariantCulture ) } ; var VAR5 = new Order { VAR1 = LITERAL , VAR2 = LITERAL , VAR3 = DateTime . Parse ( LITERAL , CultureInfo . InvariantCulture ) } ; var VAR6 = new Order { VAR1 = LITERAL , VAR2 = LITERAL , VAR3 = DateTime . Parse ( LITERAL , CultureInfo . InvariantCulture ) } ; var VAR7 = new Order { VAR1 = LITERAL , VAR2 = LITERAL , VAR3 = DateTime . Parse ( LITERAL , CultureInfo . InvariantCulture ) } ; var VAR8 = new Order { VAR1 = LITERAL , VAR2 = LITERAL , VAR3 = DateTime . Parse ( LITERAL , CultureInfo . InvariantCulture ) } ;
await VAR0 . OpenAsync ( default ) ; Assert . Equal ( 0 , VAR0 . DbConnections . Count ) ; Assert . Equal ( 1 , VAR1 . OpenCount ) ; VAR0 . Close ( ) ; Assert . Equal ( 1 , VAR1 . OpenCount ) ; Assert . Equal ( 1 , VAR1 . CloseCount ) ; VAR1 . SetState ( ConnectionState . Open ) ; await VAR0 . OpenAsync ( default ) ;
VAR0 = VAR1 . Set < RequiredAk1 > ( ) . VAR3 ( VAR4 => VAR4 . VAR5 == VAR0 . VAR5 ) ; VAR6 = ( RequiredAk1Derived ) VAR1 . Set < RequiredAk1 > ( ) . VAR3 ( VAR4 => VAR4 . VAR5 == VAR6 . VAR5 ) ; VAR7 = ( RequiredAk1MoreDerived ) VAR1 . Set < RequiredAk1 > ( ) . VAR3 ( VAR4 => VAR4 . VAR5 == VAR7 . VAR5 ) ; VAR8 = VAR1 . Set < RequiredAk2 > ( ) . VAR3 ( VAR4 => VAR4 . VAR5 == VAR8 . VAR5 ) ; VAR10 = VAR1 . Set < RequiredAk2 > ( ) . VAR3 ( VAR4 => VAR4 . VAR5 == VAR10 . VAR5 ) ; VAR11 = VAR1 . Set < RequiredComposite2 > ( ) . VAR3 ( VAR4 => VAR4 . VAR5 == VAR11 . VAR5 ) ; VAR13 = VAR1 . Set < RequiredComposite2 > ( ) . VAR3 ( VAR4 => VAR4 . VAR5 == VAR13 . VAR5 ) ; VAR14 = ( RequiredAk2Derived ) VAR1 . Set < RequiredAk2 > ( ) . VAR3 ( VAR4 => VAR4 . VAR5 == VAR14 . VAR5 ) ; VAR15 = ( RequiredAk2MoreDerived ) VAR1 . Set < RequiredAk2 > ( ) . VAR3 ( VAR4 => VAR4 . VAR5 == VAR15 . VAR5 ) ;
VAR0 . VAR5 = false ; Assert . Same ( VAR1 , VAR0 . VAR6 ) ; Assert . Same ( VAR2 , VAR0 . VAR7 . VAR8 . Single ( ) ) ; Assert . Same ( VAR3 , VAR0 . VAR8 . Single ( ) ) ; Assert . False ( VAR0 . VAR5 ) ; Assert . Same ( VAR4 , VAR0 . VAR7 ) ;
Assert . Null ( VAR0 . VAR1 ) ; Assert . Equal ( LITERAL , VAR0 . VAR2 ) ; Assert . False ( VAR3 . Property ( VAR4 => VAR4 . VAR5 ) . IsModified ) ; Assert . True ( VAR3 . Property ( VAR4 => VAR4 . VAR1 ) . IsModified ) ; Assert . True ( VAR3 . Property ( VAR4 => VAR4 . VAR2 ) . IsModified ) ; var VAR6 = VAR3 . GetInfrastructure ( ) ; Assert . False ( VAR6 . IsConceptualNull ( VAR3 . Property ( VAR4 => VAR4 . VAR5 ) . Metadata ) ) ; Assert . False ( VAR6 . IsConceptualNull ( VAR3 . Property ( VAR4 => VAR4 . VAR1 ) . Metadata ) ) ; Assert . False ( VAR6 . IsConceptualNull ( VAR3 . Property ( VAR4 => VAR4 . VAR2 ) . Metadata ) ) ;
Assert . Equal ( LITERAL , VAR0 . Schema ) ; Assert . Equal ( LITERAL , VAR0 . StoreType ) ; Assert . Equal ( 1 , VAR0 . IncrementBy ) ; Assert . False ( VAR0 . IsCyclic ) ; Assert . Null ( VAR0 . MaxValue ) ; Assert . Null ( VAR0 . MinValue ) ; Assert . Null ( VAR0 . StartValue ) ;
Assert . True ( await VAR0 . OpenAsync ( VAR1 : VAR1 ) ) ; Assert . Equal ( 1 , VAR0 . DbConnections . Count ) ; var VAR2 = VAR0 . DbConnections [ 0 ] ; Assert . Equal ( 1 , VAR2 . OpenAsyncCount ) ; Assert . False ( await VAR0 . OpenAsync ( VAR1 : VAR1 ) ) ; Assert . False ( await VAR0 . OpenAsync ( VAR1 : VAR1 ) ) ; Assert . Equal ( 1 , VAR2 . OpenAsyncCount ) ;
Assert . False ( await VAR0 . OpenAsync ( VAR1 : VAR1 ) ) ; Assert . False ( await VAR0 . OpenAsync ( VAR1 : VAR1 ) ) ; Assert . Equal ( 1 , VAR2 . OpenAsyncCount ) ;
Assert . Equal ( 0 , VAR0 . Index ) ; Assert . Equal ( LITERAL , VAR0 . Name ) ; Assert . Equal ( typeof ( string ) , VAR0 . ParameterType ) ; VAR0 . Index = LITERAL ; VAR0 . Name = LITERAL ; VAR0 . ParameterType = typeof ( int ) ; Assert . Equal ( LITERAL , VAR0 . Index ) ; Assert . Equal ( LITERAL , VAR0 . Name ) ; Assert . Equal ( typeof ( int ) , VAR0 . ParameterType ) ;
Assert . False ( VAR0 . IsNullable ) ; Assert . Equal ( DbType . Int32 , VAR0 . DbType ) ; VAR0 = VAR1 . DbConnections [ 0 ] . DbCommands [ 0 ] . Parameters [ 1 ] ; Assert . Equal ( LITERAL , VAR0 . ParameterName ) ; Assert . Equal ( LITERAL , VAR0 . Value ) ; Assert . Equal ( ParameterDirection . Input , VAR0 . Direction ) ; Assert . True ( VAR0 . IsNullable ) ;
Assert . Equal ( LITERAL , VAR0 . Relational ( ) . TableName ) ; Assert . Null ( VAR0 . FindProperty ( LITERAL ) . Relational ( ) . ColumnType ) ; Assert . Equal ( typeof ( string ) , VAR0 . FindProperty ( LITERAL ) . ClrType ) ; Assert . Equal ( LITERAL , VAR0 . FindProperty ( LITERAL ) . Relational ( ) . ColumnType ) ;
Assert . Equal ( LITERAL , VAR0 . Metadata . Relational ( ) . TableName ) ; Assert . True ( VAR0 . Sqlite ( ConfigurationSource . DataAnnotation ) . ToTable ( LITERAL ) ) ; Assert . Equal ( LITERAL , VAR0 . Metadata . Relational ( ) . TableName ) ; Assert . False ( VAR0 . Sqlite ( ConfigurationSource . Convention ) . ToTable ( LITERAL ) ) ; Assert . Equal ( LITERAL , VAR0 . Metadata . Relational ( ) . TableName ) ;
Assert . Null ( VAR0 . Relational ( ) . ColumnType ) ; Assert . Null ( ( ( IProperty ) VAR0 ) . Relational ( ) . ColumnType ) ; VAR0 . Relational ( ) . ColumnType = LITERAL ; Assert . Equal ( LITERAL , VAR0 . Relational ( ) . ColumnType ) ; Assert . Equal ( LITERAL , ( ( IProperty ) VAR0 ) . Relational ( ) . ColumnType ) ; VAR0 . Relational ( ) . ColumnType = LITERAL ; Assert . Equal ( LITERAL , VAR0 . Relational ( ) . ColumnType ) ; Assert . Equal ( LITERAL , ( ( IProperty ) VAR0 ) . Relational ( ) . ColumnType ) ; VAR0 . Relational ( ) . ColumnType = null ; Assert . Null ( VAR0 . Relational ( ) . ColumnType ) ; Assert . Null ( ( ( IProperty ) VAR0 ) . Relational ( ) . ColumnType ) ;
Assert . Equal ( LITERAL , VAR0 . Relational ( ) . VAR1 ) ; Assert . Equal ( LITERAL , ( ( IForeignKey ) VAR0 ) . Relational ( ) . VAR1 ) ; VAR0 . Relational ( ) . VAR1 = LITERAL ; Assert . Equal ( LITERAL , VAR0 . Relational ( ) . VAR1 ) ; Assert . Equal ( LITERAL , ( ( IForeignKey ) VAR0 ) . Relational ( ) . VAR1 ) ; VAR0 . Relational ( ) . VAR1 = LITERAL ; Assert . Equal ( LITERAL , VAR0 . Relational ( ) . VAR1 ) ; Assert . Equal ( LITERAL , ( ( IForeignKey ) VAR0 ) . Relational ( ) . VAR1 ) ; VAR0 . Relational ( ) . VAR1 = null ; Assert . Equal ( LITERAL , VAR0 . Relational ( ) . VAR1 ) ; Assert . Equal ( LITERAL , ( ( IForeignKey ) VAR0 ) . Relational ( ) . VAR1 ) ;
Assert . Equal ( PropertySaveBehavior . Save , VAR0 . BeforeSaveBehavior ) ; Assert . Equal ( PropertySaveBehavior . Save , VAR0 . AfterSaveBehavior ) ; VAR0 . ValueGenerated = ValueGenerated . OnAddOrUpdate ; Assert . Equal ( PropertySaveBehavior . Ignore , VAR0 . BeforeSaveBehavior ) ; Assert . Equal ( PropertySaveBehavior . Ignore , VAR0 . AfterSaveBehavior ) ; VAR0 . BeforeSaveBehavior = PropertySaveBehavior . Save ; Assert . Equal ( PropertySaveBehavior . Save , VAR0 . BeforeSaveBehavior ) ; Assert . Equal ( PropertySaveBehavior . Ignore , VAR0 . AfterSaveBehavior ) ; VAR0 . AfterSaveBehavior = PropertySaveBehavior . Save ; Assert . Equal ( PropertySaveBehavior . Save , VAR0 . BeforeSaveBehavior ) ; Assert . Equal ( PropertySaveBehavior . Save , VAR0 . AfterSaveBehavior ) ;
var VAR0 = new BaseTypeChangedConvention ( VAR1 : false ) ; var VAR2 = new BaseTypeChangedConvention ( VAR1 : true ) ; var VAR3 = new BaseTypeChangedConvention ( VAR1 : false ) ; VAR4 . BaseEntityTypeChangedConventions . Add ( VAR0 ) ; VAR4 . BaseEntityTypeChangedConventions . Add ( VAR2 ) ; VAR4 . BaseEntityTypeChangedConventions . Add ( VAR3 ) ;
Assert . Equal ( PropertyValueBehavior . UseValue , VAR0 . BeforeSaveBehavior ) ; Assert . Equal ( PropertyValueBehavior . UseValue , VAR0 . AfterSaveBehavior ) ; VAR0 . ValueGenerated = ValueGenerated . OnAddOrUpdate ; Assert . Equal ( PropertyValueBehavior . Ignore , VAR0 . BeforeSaveBehavior ) ; Assert . Equal ( PropertyValueBehavior . Ignore , VAR0 . AfterSaveBehavior ) ; VAR0 . BeforeSaveBehavior = PropertyValueBehavior . UseValue ; Assert . Equal ( PropertyValueBehavior . UseValue , VAR0 . BeforeSaveBehavior ) ; Assert . Equal ( PropertyValueBehavior . Ignore , VAR0 . AfterSaveBehavior ) ; VAR0 . AfterSaveBehavior = PropertyValueBehavior . UseValue ; Assert . Equal ( PropertyValueBehavior . UseValue , VAR0 . BeforeSaveBehavior ) ; Assert . Equal ( PropertyValueBehavior . UseValue , VAR0 . AfterSaveBehavior ) ;
Assert . Same ( VAR0 , new ValueGeneratorConvention ( ) . Apply ( VAR0 ) ) ; Assert . Equal ( ValueGenerated . Never , ( ( IProperty ) VAR1 ) . ValueGenerated ) ; VAR2 . RemoveForeignKey ( VAR0 . Metadata , ConfigurationSource . Convention ) ; Assert . True ( new ValueGeneratorConvention ( ) . Apply ( VAR2 , ( Key ) null ) ) ;
Assert . True ( new KeyConvention ( ) . Apply ( VAR2 , ( Key ) null ) ) ; var VAR1 = VAR0 . Metadata . Properties ; Assert . True ( VAR1 [ 0 ] . RequiresValueGenerator ( ) ) ; Assert . False ( VAR1 [ 1 ] . RequiresValueGenerator ( ) ) ; Assert . Equal ( ValueGenerated . OnAdd , VAR1 [ 0 ] . ValueGenerated ) ; Assert . Equal ( ValueGenerated . Never , VAR1 [ 1 ] . ValueGenerated ) ;
Assert . NotNull ( VAR0 [ 0 ] = VAR1 . GetService < IInMemoryStoreCache > ( ) ) ; Assert . NotNull ( VAR0 [ 1 ] = VAR1 . GetService < ILoggerFactory > ( ) ) ; Assert . NotNull ( VAR0 [ LITERAL ] = VAR1 . GetService < IMemoryCache > ( ) ) ; Assert . Same ( VAR2 , VAR1 . GetService < IDbContextOptions > ( ) ) ; Assert . NotNull ( VAR1 . GetService < ILogger < Random > > ( ) ) ; Assert . Same ( VAR0 [ 0 ] , VAR3 . GetService < IInMemoryStoreCache > ( ) ) ;
Assert . NotNull ( VAR0 [ 0 ] = VAR1 . GetService < IInMemoryStoreCache > ( ) ) ; Assert . NotNull ( VAR0 [ 1 ] = VAR1 . GetService < ILoggerFactory > ( ) ) ; Assert . NotNull ( VAR0 [ LITERAL ] = VAR1 . GetService < IMemoryCache > ( ) ) ; Assert . Same ( VAR2 , VAR1 . GetService < IDbContextOptions > ( ) ) ; Assert . NotNull ( VAR1 . GetService < ILogger < Random > > ( ) ) ; Assert . Same ( VAR0 [ 0 ] , VAR3 . GetService < IInMemoryStoreCache > ( ) ) ;
VAR0 . VAR7 = VAR7 ; VAR0 . VAR2 = VAR2 || ! VAR0 . VAR3 . Any ( ) ; VAR4 = null ; VAR5 = null ; VAR6 = false ; VAR7 = null ;
VAR0 . VAR9 = VAR9 ; VAR0 . VAR2 = VAR2 || ! VAR0 . VAR3 . Any ( ) ; VAR4 = null ; VAR5 = null ; VAR6 = false ; VAR9 = null ; VAR7 = null ; ClearTables ( ) ; ClearProjection ( ) ; ClearOrderBy ( ) ; VAR8 . Add ( VAR0 ) ; VAR9 = VAR0 ;
Check . NotNull ( VAR18 , nameof ( VAR18 ) ) ; VAR1 = VAR2 . Context . GetType ( ) ; VAR3 = VAR4 ; VAR5 = VAR6 ; VAR7 = VAR8 ; VAR9 = VAR10 ; VAR11 = VAR12 ; VAR13 = VAR14 ; VAR15 = VAR16 ; VAR17 = VAR18 . InvariantName ;
Assert . True ( VAR0 . RequiresValueGenerator ( ) ) ; Assert . False ( VAR1 . HasValueGenerator ( ( VAR2 , VAR3 ) => new CustomValueGenerator1 ( ) , ConfigurationSource . Convention ) ) ; Assert . IsType < CustomValueGenerator2 > ( VAR0 . GetValueGeneratorFactory ( ) ( null , null ) ) ; Assert . True ( VAR0 . RequiresValueGenerator ( ) ) ;
Assert . True ( VAR0 . RequiresValueGenerator ( ) ) ; Assert . True ( VAR1 . HasValueGenerator ( ( VAR2 , VAR3 ) => new CustomValueGenerator2 ( ) , ConfigurationSource . Explicit ) ) ; Assert . IsType < CustomValueGenerator2 > ( VAR0 . GetValueGeneratorFactory ( ) ( null , null ) ) ; Assert . True ( VAR0 . RequiresValueGenerator ( ) ) ;
Assert . Equal ( VAR0 , VAR1 . GetFieldName ( ) ) ; var VAR2 = VAR1 . FieldInfo ; Assert . Equal ( VAR0 , VAR2 . Name ) ; Assert . Same ( VAR3 ?? ( MemberInfo ) VAR2 , VAR1 . MemberInfo ) ; VAR1 . SetField ( null , ConfigurationSource . Explicit ) ; Assert . Null ( VAR1 . GetFieldName ( ) ) ;
var VAR0 = VAR1 . AddProperty ( LITERAL , typeof ( int ) ) ; VAR0 . ValueGenerated = VAR2 ? ValueGenerated . OnAdd : ValueGenerated . Never ; VAR0 . Relational ( ) . ColumnName = LITERAL ; VAR1 . GetOrSetPrimaryKey ( VAR0 ) ; var VAR3 = VAR1 . AddProperty ( LITERAL , typeof ( string ) ) ;
var VAR0 = VAR1 . FieldInfo ; Assert . Equal ( VAR2 , VAR0 . Name ) ; Assert . Same ( VAR3 ?? ( MemberInfo ) VAR0 , VAR1 . MemberInfo ) ; VAR1 . SetField ( null , ConfigurationSource . Explicit ) ; Assert . Null ( VAR1 . GetField ( ) ) ; Assert . Null ( VAR1 . FieldInfo ) ;
var VAR7 = VAR1 . GetForeignKeys ( ) . Single ( VAR2 => VAR2 . DependentToPrincipal == null ) ; var VAR0 = VAR1 . GetForeignKeys ( ) . Single ( VAR2 => VAR2 != VAR7 ) ; Assert . Same ( VAR0 . DependentToPrincipal , VAR1 . GetNavigations ( ) . Single ( ) ) ; Assert . Same ( VAR0 . PrincipalToDependent , VAR4 . GetNavigations ( ) . Single ( ) ) ; AssertEqual ( VAR5 , VAR4 . GetProperties ( ) ) ; VAR6 . Add ( VAR0 . Properties . Single ( ) ) ;
var VAR4 = VAR1 . GetForeignKeys ( ) . Single ( ) ; Assert . Equal ( VAR2 . Properties , VAR4 . Properties ) ; Assert . Equal ( VAR2 . PrincipalKey . Properties , VAR4 . PrincipalKey . Properties ) ; Assert . Equal ( LITERAL , VAR1 . GetNavigations ( ) . Single ( ) . Name ) ; Assert . Equal ( LITERAL , VAR3 . GetNavigations ( ) . Single ( ) . Name ) ; Assert . Same ( VAR4 , VAR1 . GetNavigations ( ) . Single ( ) . ForeignKey ) ; Assert . Same ( VAR4 , VAR3 . GetNavigations ( ) . Single ( ) . ForeignKey ) ;
var VAR2 = VAR1 . GetForeignKeys ( ) . Single ( VAR6 => VAR6 != VAR3 ) ; Assert . Same ( VAR1 . FindProperty ( nameof ( Customer . Id ) ) , VAR2 . Properties . Single ( ) ) ; Assert . Empty ( VAR1 . GetNavigations ( ) . Where ( VAR4 => VAR4 . ForeignKey == VAR2 ) ) ; Assert . Empty ( VAR5 . GetNavigations ( ) . Where ( VAR4 => VAR4 . ForeignKey == VAR2 ) ) ;
var VAR2 = CreateModelBuilder ( ) ; VAR2 . Entity < SRelated > ( ) ; Validate ( VAR2 ) ; Assert . True ( GetProperty < OKeyBase > ( VAR2 , nameof ( OKeyBase . VAR1 ) ) . IsPrimaryKey ( ) ) ; Assert . True ( GetProperty < DODerived > ( VAR2 , nameof ( DODerived . VAR1 ) ) . IsPrimaryKey ( ) ) ;
Assert . False ( VAR0 . Ignore ( Order . VAR1 . Name , ConfigurationSource . DataAnnotation ) ) ; Assert . NotNull ( VAR2 . FindProperty ( Order . VAR1 . Name ) ) ; Assert . NotNull ( VAR0 . Property ( Order . VAR1 . Name , typeof ( int ) , ConfigurationSource . Explicit ) ) ; Assert . False ( VAR0 . Ignore ( Order . VAR1 . Name , ConfigurationSource . Convention ) ) ; Assert . False ( VAR0 . Ignore ( Order . VAR1 . Name , ConfigurationSource . DataAnnotation ) ) ; Assert . NotNull ( VAR2 . FindProperty ( Order . VAR1 . Name ) ) ;
AssertReceivedMessagesConsistent ( VAR0 ) ; AssertReceivedMessagesConsistent ( VAR2 , VAR3 , VAR4 ) ; AssertReceivedMessagesConsistent ( VAR5 , VAR1 ) ; AssertSentMessagesConsistent ( VAR0 , VAR3 , VAR4 ) ; AssertSentMessagesConsistent ( VAR2 , VAR1 ) ; AssertSentMessagesConsistent ( VAR5 ) ; VAR1 . ToUsername = VAR0 . Username ;
var VAR0 = new VAR1 ( LITERAL ) ; var VAR3 = new VAR4 ( LITERAL , 0 ) ; VAR5 . Entry ( VAR0 ) . State = VAR6 ; VAR3 . SetCategoryId ( VAR0 . VAR2 ) ; VAR3 . SetCategory ( VAR0 ) ; VAR0 . AddProduct ( VAR3 ) ;
var VAR0 = new VAR1 ( LITERAL ) ; var VAR3 = new VAR4 ( LITERAL , 0 ) ; VAR5 . Entry ( VAR0 ) . State = VAR6 ; VAR3 . SetCategory ( VAR0 ) ; VAR0 . AddProduct ( VAR3 ) ;
var VAR0 = new VAR1 ( LITERAL ) ; var VAR3 = new VAR4 ( LITERAL , 0 ) ; VAR5 . Entry ( VAR0 ) . State = VAR6 ; VAR3 . SetCategoryId ( VAR0 . VAR2 ) ; VAR3 . SetCategory ( VAR0 ) ;
var VAR0 = new VAR1 ( LITERAL ) ; var VAR3 = new VAR4 ( LITERAL , 0 ) ; VAR5 . Entry ( VAR3 ) . State = VAR6 ; VAR3 . SetParentId ( VAR0 . VAR2 ) ; VAR0 . SetChild ( VAR3 ) ;
var VAR0 = new VAR1 ( LITERAL ) ; var VAR3 = new VAR4 ( LITERAL , 0 ) ; VAR5 . Entry ( VAR3 ) . State = VAR6 ; VAR3 . SetParentId ( VAR0 . VAR2 ) ; VAR3 . SetParent ( VAR0 ) ;
var VAR0 = new VAR1 ( LITERAL ) ; var VAR3 = new VAR4 ( LITERAL , 0 ) ; VAR5 . Entry ( VAR0 ) . State = VAR6 ; VAR3 . SetParentId ( VAR0 . VAR2 ) ; VAR0 . SetChild ( VAR3 ) ;
var VAR0 = VAR1 . StartTrackingFromQuery ( VAR2 , new Category { VAR3 = LITERAL , VAR4 = LITERAL } , new ValueBuffer ( new object [  ] { LITERAL , LITERAL , LITERAL } ) , null ) ; Assert . Equal ( TrackingQueryMode . Simple , VAR1 . GetTrackingQueryMode ( VAR2 ) ) ; VAR0 . SetEntityState ( EntityState . Modified ) ; Assert . Equal ( TrackingQueryMode . Multiple , VAR1 . GetTrackingQueryMode ( VAR2 ) ) ;
Check . NotEmpty ( VAR12 , nameof ( VAR12 ) ) ; VAR1 = VAR2 ; VAR3 = VAR4 ; VAR5 = VAR6 ; VAR7 = VAR8 ; VAR13 = VAR12 ; VAR10 = new LazyRef < ILogger > ( ( ) => VAR1 . CreateCommandsLogger ( ) ) ; var VAR11 = new StartupInvoker ( VAR6 , VAR8 , VAR12 ) ;
var VAR4 = VAR5 ; VAR5 = InferTypeMappingFromColumn ( VAR2 . Operand ) ?? VAR4 ; Visit ( VAR2 . Operand ) ; VAR3 . Append ( LITERAL ) ; Visit ( VAR2 . SubQuery ) ; VAR5 = VAR4 ;
Assert . True ( VAR0 . Features == null || ! VAR0 . Features . Any ( ) ) ; Assert . Same ( VAR1 , VAR2 . Review ) ; Assert . Same ( VAR2 , VAR1 . Features . Single ( ) ) ; Assert . True ( VAR3 . Features == null || ! VAR3 . Features . Any ( ) ) ; Assert . True ( VAR4 . Features == null || ! VAR4 . Features . Any ( ) ) ;
Assert . NotNull ( VAR0 [ 0 ] = VAR1 . GetService < IInMemoryStoreSource > ( ) ) ; Assert . NotNull ( VAR0 [ 1 ] = VAR1 . GetService < ILoggerFactory > ( ) ) ; Assert . NotNull ( VAR0 [ LITERAL ] = VAR1 . GetService < IMemoryCache > ( ) ) ; Assert . Same ( VAR2 , VAR1 . GetService < IDbContextOptions > ( ) ) ; Assert . NotNull ( VAR1 . GetService < ILogger < Random > > ( ) ) ; Assert . Same ( VAR0 [ 0 ] , VAR3 . GetService < IInMemoryStoreSource > ( ) ) ;
Assert . Empty ( VAR0 . VAR1 ) ; Assert . Empty ( VAR0 . VAR2 ) ; VAR3 . VAR4 = new List < ChangedOnlyNotificationEntity > ( ) ; var VAR5 = VAR6 . EntityType . FindNavigation ( LITERAL ) ; Assert . Same ( VAR5 , VAR0 . VAR1 . Single ( ) ) ; Assert . Same ( VAR5 , VAR0 . VAR2 . Single ( ) ) ;
var VAR0 = new ModificationCommand ( LITERAL , null , new ParameterNameGenerator ( ) . GenerateNext , VAR1 => VAR1 . TestProvider ( ) ) ; VAR0 . AddEntry ( VAR2 ) ; var VAR3 = VAR4 . GetOrCreateEntry ( new object ( ) ) ; VAR3 [ VAR5 ] = LITERAL ; VAR3 . SetEntityState ( EntityState . Deleted ) ; var VAR6 = new ModificationCommand ( LITERAL , null , new ParameterNameGenerator ( ) . GenerateNext , VAR1 => VAR1 . TestProvider ( ) ) ;
var VAR0 = new ModificationCommand ( LITERAL , null , new ParameterNameGenerator ( ) . GenerateNext , VAR1 => VAR1 . TestProvider ( ) ) ; VAR0 . AddEntry ( VAR2 ) ; var VAR3 = VAR4 . GetOrCreateEntry ( new object ( ) ) ; VAR3 [ VAR5 ] = LITERAL ; VAR3 . SetEntityState ( EntityState . Modified ) ; var VAR6 = new ModificationCommand ( LITERAL , null , new ParameterNameGenerator ( ) . GenerateNext , VAR1 => VAR1 . TestProvider ( ) ) ; VAR6 . AddEntry ( VAR3 ) ; var VAR7 = VAR4 . GetOrCreateEntry ( new object ( ) ) ; VAR7 [ VAR5 ] = LITERAL ; VAR7 . SetEntityState ( EntityState . Deleted ) ; var VAR8 = new ModificationCommand ( LITERAL , null , new ParameterNameGenerator ( ) . GenerateNext , VAR1 => VAR1 . TestProvider ( ) ) ;
Dictionary < string , string > VAR0 ; Dictionary < string , string > VAR1 ; Dictionary < string , string > VAR2 ; Dictionary < string , List < string > > VAR3 ; Dictionary < string , List < string > > VAR4 ;
Assert . True ( VAR0 . Relational ( ConfigurationSource . Convention ) . HasName ( LITERAL ) ) ; Assert . Equal ( LITERAL , VAR0 . Metadata . Relational ( ) . Name ) ; Assert . True ( VAR0 . Relational ( ConfigurationSource . DataAnnotation ) . HasName ( LITERAL ) ) ; Assert . Equal ( LITERAL , VAR0 . Metadata . Relational ( ) . Name ) ; Assert . False ( VAR0 . Relational ( ConfigurationSource . Convention ) . HasName ( LITERAL ) ) ;
Assert . True ( VAR0 . SqlServer ( ConfigurationSource . Convention ) . IsClustered ( true ) ) ; Assert . True ( VAR0 . Metadata . SqlServer ( ) . IsClustered ) ; Assert . True ( VAR0 . SqlServer ( ConfigurationSource . DataAnnotation ) . IsClustered ( false ) ) ; Assert . False ( VAR0 . Metadata . SqlServer ( ) . IsClustered ) ; Assert . False ( VAR0 . SqlServer ( ConfigurationSource . Convention ) . IsClustered ( true ) ) ;
Check . NotNull ( VAR10 , nameof ( VAR10 ) ) ; VAR1 = VAR2 ; VAR3 = VAR4 ; VAR5 = VAR6 ; VAR7 = VAR8 ; VAR9 = VAR10 . Context ;
Check . NotNull ( VAR14 , nameof ( VAR14 ) ) ; VAR1 = VAR2 ; VAR3 = VAR4 ; VAR5 = VAR6 ; VAR7 = VAR8 ; VAR9 = VAR10 ; VAR11 = VAR12 ; VAR13 = VAR14 . Context . GetType ( ) ;
VAR0 . Attach ( VAR1 ) ; Assert . Equal ( LITERAL , VAR1 . VAR2 ) ; Assert . Same ( VAR1 , VAR3 . VAR4 . Single ( ) ) ; Assert . Same ( VAR5 , VAR1 . VAR6 ) ; Assert . Same ( VAR1 , VAR5 . VAR4 . Single ( ) ) ; Assert . Equal ( EntityState . Detached , VAR0 . Entry ( VAR3 ) . State ) ; Assert . Equal ( EntityState . Unchanged , VAR0 . Entry ( VAR1 ) . State ) ; VAR0 . Attach ( VAR3 ) ;
Assert . True ( VAR0 . Allows ( LITERAL ) ) ; var VAR1 = VAR0 . Tables . First ( ) ; var VAR2 = VAR0 . Tables . Skip ( 1 ) . First ( ) ; var VAR3 = VAR0 . Tables . Last ( ) ; Assert . True ( VAR1 . IsMatched ) ; Assert . False ( VAR2 . IsMatched ) ; Assert . False ( VAR3 . IsMatched ) ; Assert . True ( VAR0 . Allows ( LITERAL ) ) ;
Assert . Equal ( 1 , VAR0 . GetOriginalValue ( VAR1 ) ) ; Assert . Equal ( LITERAL , VAR0 . GetOriginalValue ( VAR2 ) ) ; Assert . Equal ( 1 , VAR0 [ VAR1 ] ) ; Assert . Equal ( LITERAL , VAR0 [ VAR2 ] ) ; VAR0 [ VAR2 ] = LITERAL ; Assert . Equal ( 1 , VAR0 . GetOriginalValue ( VAR1 ) ) ; Assert . Equal ( LITERAL , VAR0 . GetOriginalValue ( VAR2 ) ) ; Assert . Equal ( 1 , VAR0 [ VAR1 ] ) ; Assert . Equal ( LITERAL , VAR0 [ VAR2 ] ) ; VAR0 . SetOriginalValue ( VAR1 , LITERAL ) ; VAR0 . SetOriginalValue ( VAR2 , LITERAL ) ; Assert . Equal ( LITERAL , VAR0 . GetOriginalValue ( VAR1 ) ) ; Assert . Equal ( LITERAL , VAR0 . GetOriginalValue ( VAR2 ) ) ;
VAR0 . SetOriginalValue ( VAR1 , LITERAL ) ; VAR0 . AcceptChanges ( ) ; Assert . Equal ( EntityState . Unchanged , VAR0 . EntityState ) ; Assert . Equal ( LITERAL , VAR0 [ VAR1 ] ) ; Assert . Equal ( LITERAL , VAR0 . GetOriginalValue ( VAR1 ) ) ;
Assert . Equal ( LITERAL , VAR0 . GetCurrentValue ( VAR1 ) ) ; VAR2 . VAR3 = LITERAL ; Assert . Equal ( LITERAL , VAR0 . GetValue ( VAR1 , ValueSource . RelationshipSnapshot ) ) ; Assert . Equal ( LITERAL , VAR0 . GetValue ( VAR1 , ValueSource . Original ) ) ; Assert . Equal ( LITERAL , VAR0 . GetCurrentValue ( VAR1 ) ) ;
VAR0 . Value . LogDebug ( CommandsStrings . WritingMigration ( VAR1 ) ) ; Directory . CreateDirectory ( VAR2 ) ; File . WriteAllText ( VAR1 , VAR3 . MigrationCode ) ; File . WriteAllText ( VAR4 , VAR3 . MetadataCode ) ; VAR0 . Value . LogDebug ( CommandsStrings . WritingSnapshot ( VAR5 ) ) ;
var VAR0 = VAR1 . AddProperty ( typeof ( Duck ) . GetTypeInfo ( ) . GetDeclaredProperty ( nameof ( Duck . VAR2 ) ) ) ; VAR1 . AddProperty ( typeof ( Duck ) . GetTypeInfo ( ) . GetDeclaredProperty ( nameof ( Duck . VAR3 ) ) ) ; VAR1 . AddProperty ( typeof ( Duck ) . GetTypeInfo ( ) . GetDeclaredProperty ( nameof ( Duck . VAR4 ) ) ) ; VAR1 . AddProperty ( typeof ( Duck ) . GetTypeInfo ( ) . GetDeclaredProperty ( nameof ( Duck . VAR5 ) ) ) ; VAR1 . AddProperty ( typeof ( Duck ) . GetTypeInfo ( ) . GetDeclaredProperty ( nameof ( Duck . VAR6 ) ) ) ;
Assert . True ( VAR0 . HasClrType ( typeof ( int ) , ConfigurationSource . DataAnnotation ) ) ; Assert . Equal ( typeof ( int ) , VAR1 . ClrType ) ; Assert . True ( VAR0 . HasClrType ( typeof ( string ) , ConfigurationSource . DataAnnotation ) ) ; Assert . Equal ( typeof ( string ) , VAR1 . ClrType ) ; Assert . False ( VAR0 . HasClrType ( typeof ( int ) , ConfigurationSource . Convention ) ) ; Assert . Equal ( typeof ( string ) , VAR1 . ClrType ) ; Assert . True ( VAR0 . HasClrType ( typeof ( string ) , ConfigurationSource . Convention ) ) ;
VAR2 . Append ( LITERAL ) ; Visit ( VAR1 . Left ) ; VAR2 . Append ( LITERAL ) ; Visit ( VAR1 . Right ) ; VAR2 . Append ( LITERAL ) ;
Check . NotEmpty ( VAR8 , nameof ( VAR8 ) ) ; VAR1 = VAR2 ; VAR3 = VAR4 ; VAR5 = VAR6 ; VAR9 = VAR8 ;
var VAR0 = VAR1 . ChangeTracker . GetInfrastructure ( ) . GetOrCreateEntry ( new T ( ) ) ; VAR3 = ( T ) VAR0 . Entity ; VAR0 [ VAR4 ] = LITERAL ; VAR0 [ VAR5 ] = LITERAL ; VAR0 . SetEntityState ( EntityState . Added ) ;
var VAR0 = CreateModel ( ) ; var VAR1 = VAR0 . AddEntityType ( LITERAL ) ; var VAR2 = VAR1 . AddProperty ( LITERAL , typeof ( int ) ) ; var VAR3 = VAR1 . AddKey ( VAR2 ) ; var VAR4 = VAR0 . AddEntityType ( LITERAL ) ;
var VAR0 = CreateModel ( ) ; var VAR1 = VAR0 . AddEntityType ( LITERAL ) ; var VAR2 = VAR1 . AddProperty ( LITERAL , typeof ( int ) ) ; var VAR3 = VAR1 . AddProperty ( LITERAL , typeof ( int ) ) ; var VAR4 = VAR1 . AddKey ( new [ ] { VAR2 , VAR3 } ) ; var VAR5 = VAR0 . AddEntityType ( LITERAL ) ; var VAR6 = VAR5 . AddProperty ( LITERAL , typeof ( int ) ) ; var VAR7 = VAR5 . AddKey ( VAR6 ) ; var VAR8 = VAR0 . AddEntityType ( LITERAL ) ; var VAR9 = VAR8 . AddProperty ( LITERAL , typeof ( int ) ) ; var VAR10 = VAR8 . AddProperty ( LITERAL , typeof ( int ) ) ; var VAR11 = VAR8 . AddKey ( VAR9 ) ;
Assert . Same ( VAR0 , VAR1 . TryGetEntry ( new KeyValue < int > ( VAR0 . EntityType . FindPrimaryKey ( ) , LITERAL ) ) ) ; VAR2 . VAR3 = LITERAL ; VAR4 . DetectChanges ( VAR0 ) ; Assert . Equal ( LITERAL , VAR0 . RelationshipsSnapshot [ VAR0 . EntityType . FindProperty ( LITERAL ) ] ) ; Assert . Same ( VAR0 , VAR1 . TryGetEntry ( new KeyValue < int > ( VAR0 . EntityType . FindPrimaryKey ( ) , LITERAL ) ) ) ;
var VAR1 = CreateModelBuilder ( ) ; var VAR0 = VAR1 . Model ; VAR1 . Entity < Customer > ( ) ; VAR1 . Entity < Order > ( ) ; VAR1 . Ignore < OrderDetails > ( ) ; VAR1 . Ignore < CustomerDetails > ( ) ; var VAR2 = VAR0 . FindEntityType ( typeof ( Order ) ) ; var VAR3 = VAR0 . FindEntityType ( typeof ( Customer ) ) ; var VAR4 = VAR2 . FindProperty ( nameof ( Order . CustomerId ) ) ; var VAR5 = VAR3 . GetKeys ( ) . Single ( ) ; var VAR6 = VAR2 . GetKeys ( ) . Single ( ) ;
var VAR1 = CreateModelBuilder ( ) ; var VAR0 = VAR1 . Model ; VAR1 . Entity < PrincipalEntity > ( ) ; var VAR2 = VAR0 . FindEntityType ( typeof ( DependentEntity ) ) . GetForeignKeys ( ) . Single ( ) ; Assert . Equal ( LITERAL , VAR2 . Properties . Single ( ) . Name ) ; VAR1 . Entity < DependentEntity > ( ) . Property ( VAR3 => VAR3 . PrincipalEntityId ) ; var VAR4 = VAR0 . FindEntityType ( typeof ( DependentEntity ) ) . GetForeignKeys ( ) . Single ( ) ; Assert . Equal ( LITERAL , VAR4 . Properties . Single ( ) . Name ) ;
VAR1 . HasPrincipalToDependent ( LITERAL ) ; Assert . Equal ( new [ ] { LITERAL } , VAR0 . GetNavigations ( ) . Select ( VAR2 => VAR2 . VAR3 ) . ToArray ( ) ) ; Assert . Equal ( new [ ] { LITERAL } , VAR4 . GetNavigations ( ) . Select ( VAR2 => VAR2 . VAR3 ) . ToArray ( ) ) ; var VAR5 = VAR6 . GetOrAddProperty ( Order . VAR7 ) ; var VAR8 = VAR6 . GetOrAddForeignKey ( VAR5 , VAR9 , VAR4 ) ; VAR8 . HasPrincipalToDependent ( LITERAL ) ;
AssertEqual ( VAR0 , VAR1 . GetReferencingForeignKeys ( ) ) ; AssertEqual ( VAR2 , VAR3 . GetProperties ( ) , new PropertyComparer ( compareAnnotations : false ) ) ; AssertEqual ( VAR4 , VAR3 . GetKeys ( ) ) ; AssertEqual ( VAR5 , VAR3 . GetIndexes ( ) ) ; Assert . Equal ( VAR6 . Count ( ) , VAR3 . GetForeignKeys ( ) . Count ( ) ) ; Assert . Equal ( VAR0 . Count ( ) , VAR3 . GetReferencingForeignKeys ( ) . Count ( ) ) ;
Assert . Same ( VAR0 , VAR1 . RemoveAnnotation ( VAR0 . Name ) ) ; Assert . Empty ( VAR1 . Annotations ) ; Assert . Null ( VAR1 . RemoveAnnotation ( VAR0 . Name ) ) ; Assert . Null ( VAR1 [ LITERAL ] ) ; Assert . Null ( VAR1 . FindAnnotation ( LITERAL ) ) ;
Assert . Null ( VAR0 . IsStoreGeneratedAlways ) ; Assert . False ( ( ( IProperty ) VAR0 ) . IsStoreGeneratedAlways ) ; VAR0 . IsStoreGeneratedAlways = true ; Assert . True ( VAR0 . IsStoreGeneratedAlways . Value ) ; Assert . True ( ( ( IProperty ) VAR0 ) . IsStoreGeneratedAlways ) ; VAR0 . IsStoreGeneratedAlways = false ; Assert . False ( VAR0 . IsStoreGeneratedAlways . Value ) ; Assert . False ( ( ( IProperty ) VAR0 ) . IsStoreGeneratedAlways ) ; VAR0 . IsStoreGeneratedAlways = null ; Assert . Null ( VAR0 . IsStoreGeneratedAlways ) ; Assert . False ( ( ( IProperty ) VAR0 ) . IsStoreGeneratedAlways ) ;
Assert . Null ( VAR0 . FindEntityType ( typeof ( Post ) ) . FindNavigation ( LITERAL ) . ForeignKey . PrincipalToDependent ) ; Assert . Equal ( LITERAL , VAR0 . FindEntityType ( typeof ( Post ) ) . FindNavigation ( LITERAL ) . ForeignKey . Properties . First ( ) . Name ) ; Assert . Null ( VAR0 . FindEntityType ( typeof ( PostDetails ) ) . FindNavigation ( LITERAL ) . ForeignKey . PrincipalToDependent ) ; Assert . Equal ( LITERAL , VAR0 . FindEntityType ( typeof ( PostDetails ) ) . FindNavigation ( LITERAL ) . ForeignKey . Properties . First ( ) . Name ) ;
Assert . Null ( VAR0 . FindEntityType ( typeof ( Post ) ) . FindNavigation ( LITERAL ) . ForeignKey . PrincipalToDependent ) ; Assert . Equal ( LITERAL , VAR0 . FindEntityType ( typeof ( Post ) ) . FindNavigation ( LITERAL ) . ForeignKey . Properties . First ( ) . Name ) ; Assert . Null ( VAR0 . FindEntityType ( typeof ( Author ) ) . FindNavigation ( LITERAL ) . ForeignKey . PrincipalToDependent ) ; Assert . Equal ( LITERAL , VAR0 . FindEntityType ( typeof ( Author ) ) . FindNavigation ( LITERAL ) . ForeignKey . Properties . First ( ) . Name ) ;
var VAR0 = VAR1 . FindEntityType ( typeof ( Tomato ) ) ; var VAR2 = VAR1 . FindEntityType ( typeof ( Whoopper ) ) ; var VAR3 = VAR0 . GetForeignKeys ( ) . Single ( VAR4 => VAR4 . Properties . First ( ) . Name == LITERAL ) ; VAR0 . RemoveNavigation ( VAR3 . DependentToPrincipal . Name ) ; var VAR5 = VAR2 . FindPrimaryKey ( ) ;
var VAR0 = VAR1 . FindEntityType ( typeof ( Tomato ) ) ; var VAR2 = VAR1 . FindEntityType ( typeof ( Whoopper ) ) ; var VAR3 = VAR0 . FindProperty ( LITERAL ) ; var VAR4 = VAR0 . FindProperty ( LITERAL ) ; var VAR5 = VAR2 . FindProperty ( LITERAL ) ; var VAR6 = VAR2 . FindProperty ( LITERAL ) ; var VAR7 = VAR2 . FindPrimaryKey ( ) ;
var VAR0 = VAR1 . FindEntityType ( typeof ( Tomato ) ) ; var VAR2 = VAR1 . FindEntityType ( typeof ( Whoopper ) ) ; var VAR3 = VAR0 . FindProperty ( LITERAL ) ; var VAR4 = VAR0 . FindProperty ( LITERAL ) ; var VAR5 = VAR2 . FindProperty ( LITERAL ) ; var VAR6 = VAR2 . FindProperty ( LITERAL ) ; var VAR7 = VAR2 . FindPrimaryKey ( ) ; var VAR8 = VAR0 . FindPrimaryKey ( ) ;
var VAR0 = VAR1 . FindEntityType ( typeof ( Tomato ) ) ; var VAR2 = VAR1 . FindEntityType ( typeof ( Whoopper ) ) ; var VAR3 = VAR0 . FindProperty ( nameof ( Tomato . BurgerId1 ) ) ; var VAR4 = VAR0 . FindProperty ( nameof ( Tomato . BurgerId2 ) ) ; var VAR5 = VAR2 . FindPrimaryKey ( ) ;
var VAR0 = VAR1 . FindEntityType ( typeof ( DependentEntity ) ) . GetForeignKeys ( ) . Single ( ) ; Assert . Equal ( LITERAL , VAR0 . Properties . Single ( ) . Name ) ; VAR2 . Entity < DependentEntity > ( ) . Property ( VAR3 => VAR3 . PrincipalEntityId ) ; var VAR4 = VAR1 . FindEntityType ( typeof ( DependentEntity ) ) . GetForeignKeys ( ) . Single ( ) ;
var VAR0 = VAR1 . Model . FindEntityType ( typeof ( Customer ) ) ; var VAR2 = VAR0 . AddKey ( VAR0 . GetOrAddProperty ( Customer . NameProperty ) ) ; VAR1 . Entity < Customer > ( ) . HasKey ( VAR3 => VAR3 . Name ) ; Assert . Same ( VAR2 , VAR0 . GetKeys ( ) . Single ( ) ) ; Assert . Equal ( Customer . NameProperty . Name , VAR0 . FindPrimaryKey ( ) . Properties . Single ( ) . Name ) ; var VAR4 = ( IProperty ) EntityTypeExtensions . FindProperty ( ( IEntityType ) VAR0 , Customer . IdProperty ) ;
var VAR0 = ( IEntityType ) VAR1 . FindEntityType ( typeof ( Quarks ) ) ; Assert . True ( VAR0 . FindProperty ( LITERAL ) . IsNullable ) ; Assert . True ( VAR0 . FindProperty ( LITERAL ) . IsNullable ) ; Assert . True ( VAR0 . FindProperty ( LITERAL ) . IsNullable ) ;
var VAR0 = ( IEntityType ) VAR1 . FindEntityType ( typeof ( Quarks ) ) ; Assert . False ( VAR0 . FindProperty ( LITERAL ) . IsShadowProperty ) ; Assert . False ( VAR0 . FindProperty ( LITERAL ) . IsShadowProperty ) ; Assert . False ( VAR0 . FindProperty ( LITERAL ) . IsShadowProperty ) ; Assert . True ( VAR0 . FindProperty ( LITERAL ) . IsShadowProperty ) ; Assert . True ( VAR0 . FindProperty ( LITERAL ) . IsShadowProperty ) ; Assert . Equal ( - 1 , VAR0 . FindProperty ( LITERAL ) . GetShadowIndex ( ) ) ; Assert . Equal ( - 1 , VAR0 . FindProperty ( LITERAL ) . GetShadowIndex ( ) ) ; Assert . Equal ( - 1 , VAR0 . FindProperty ( LITERAL ) . GetShadowIndex ( ) ) ; Assert . Equal ( 0 , VAR0 . FindProperty ( LITERAL ) . GetShadowIndex ( ) ) ; Assert . Equal ( 1 , VAR0 . FindProperty ( LITERAL ) . GetShadowIndex ( ) ) ;
var VAR0 = VAR1 . FindEntityType ( typeof ( Order ) ) ; var VAR2 = VAR1 . FindEntityType ( typeof ( Customer ) ) ; var VAR3 = VAR2 . GetKeys ( ) . Single ( ) ; var VAR4 = VAR0 . GetKeys ( ) . Single ( ) ; VAR5 . Entity < Customer > ( ) . HasMany < Order > ( ) . WithOne ( VAR6 => VAR6 . Customer ) ; var VAR7 = VAR0 . GetNavigations ( ) . Single ( ) . ForeignKey ; Assert . Same ( VAR0 . FindProperty ( nameof ( Order . CustomerId ) ) , VAR7 . Properties . Single ( ) ) ;
Assert . Same ( VAR0 . FindProperty ( nameof ( Pickle . BurgerId ) ) , VAR1 . Properties . Single ( ) ) ; Assert . Equal ( nameof ( Pickle . BigMak ) , VAR1 . DependentToPrincipal . Name ) ; Assert . Null ( VAR1 . PrincipalToDependent ) ; Assert . NotSame ( VAR1 , VAR2 . GetNavigations ( ) . Single ( ) . ForeignKey ) ; Assert . Same ( VAR3 , VAR2 . GetKeys ( ) . Single ( ) ) ; Assert . Same ( VAR4 , VAR0 . GetKeys ( ) . Single ( ) ) ; Assert . Same ( VAR3 , VAR2 . FindPrimaryKey ( ) ) ; Assert . Same ( VAR4 , VAR0 . FindPrimaryKey ( ) ) ;
var VAR0 = VAR1 . FindEntityType ( typeof ( Order ) ) ; var VAR2 = VAR1 . FindEntityType ( typeof ( Customer ) ) ; var VAR3 = VAR0 . FindProperty ( LITERAL ) ; var VAR4 = VAR2 . FindProperty ( Customer . IdProperty . Name ) ;
var VAR0 = VAR1 . FindEntityType ( typeof ( Order ) ) ; var VAR2 = VAR1 . FindEntityType ( typeof ( Customer ) ) ; var VAR3 = VAR0 . FindProperty ( LITERAL ) ; var VAR4 = VAR2 . FindProperty ( Customer . IdProperty . Name ) ;
var VAR0 = VAR1 . FindEntityType ( typeof ( Pickle ) ) ; var VAR2 = VAR1 . FindEntityType ( typeof ( BigMak ) ) ; var VAR3 = VAR0 . FindProperty ( LITERAL ) ; var VAR4 = VAR2 . FindProperty ( LITERAL ) ;
var VAR0 = VAR1 . FindEntityType ( typeof ( Tomato ) ) ; var VAR2 = VAR1 . FindEntityType ( typeof ( Whoopper ) ) ; var VAR3 = VAR0 . FindProperty ( LITERAL ) ; var VAR4 = VAR0 . FindProperty ( LITERAL ) ; var VAR5 = VAR2 . FindProperty ( LITERAL ) ; var VAR6 = VAR2 . FindProperty ( LITERAL ) ; var VAR7 = VAR2 . FindPrimaryKey ( ) ;
var VAR0 = VAR1 . FindEntityType ( typeof ( DependentEntity ) ) . GetForeignKeys ( ) . Single ( ) ; Assert . Equal ( LITERAL , VAR0 . Properties . Single ( ) . Name ) ; VAR2 . Entity < DependentEntity > ( ) . Property ( VAR3 => VAR3 . PrincipalEntityId ) ; var VAR4 = VAR1 . FindEntityType ( typeof ( DependentEntity ) ) . GetForeignKeys ( ) . Single ( ) ;
var VAR0 = VAR1 . FindEntityType ( typeof ( CustomerDetails ) ) ; var VAR2 = VAR1 . FindEntityType ( typeof ( Customer ) ) ; var VAR3 = VAR2 . GetKeys ( ) . Single ( ) ; var VAR4 = VAR0 . GetKeys ( ) . Single ( ) ; VAR5 . Entity < Customer > ( ) . HasOne ( VAR6 => VAR6 . Details ) . WithOne ( VAR6 => VAR6 . Customer ) ; var VAR7 = VAR0 . GetNavigations ( ) . Single ( ) . ForeignKey ; Assert . Same ( VAR7 , VAR2 . GetNavigations ( ) . Single ( ) . ForeignKey ) ; Assert . Same ( VAR3 , VAR2 . GetKeys ( ) . Single ( ) ) ; Assert . Same ( VAR4 , VAR0 . GetKeys ( ) . Single ( ) ) ; Assert . Same ( VAR3 , VAR2 . FindPrimaryKey ( ) ) ; Assert . Same ( VAR4 , VAR0 . FindPrimaryKey ( ) ) ;
var VAR0 = VAR1 . FindEntityType ( typeof ( CustomerDetails ) ) ; var VAR2 = VAR1 . FindEntityType ( typeof ( Customer ) ) ; var VAR3 = VAR0 . FindProperty ( Customer . IdProperty . Name ) ; var VAR4 = VAR2 . GetKeys ( ) . Single ( ) ; var VAR5 = VAR0 . GetKeys ( ) . Single ( ) ;
var VAR0 = VAR1 . FindEntityType ( typeof ( AnEntity ) ) ; VAR0 . FindProperty ( LITERAL ) . SqlServer ( ) . GeneratedValueSql = LITERAL ; var VAR2 = SqlServerTestHelpers . Instance . CreateContextServices ( VAR1 ) . GetRequiredService < IValueGeneratorSelector > ( ) ; Assert . IsType < TemporaryGuidValueGenerator > ( VAR2 . Select ( VAR0 . FindProperty ( LITERAL ) , VAR0 ) ) ;
var VAR0 = VAR1 . Model . FindEntityType ( typeof ( VAR2 ) ) ; Assert . Equal ( LITERAL , VAR0 . Relational ( ) . DiscriminatorProperty . VAR3 ) ; Assert . Equal ( typeof ( string ) , VAR0 . Relational ( ) . DiscriminatorProperty . ClrType ) ; Assert . Equal ( 1 , VAR0 . Relational ( ) . DiscriminatorValue ) ; Assert . Equal ( LITERAL , VAR1 . Model . FindEntityType ( typeof ( SpecialCustomer ) ) . Relational ( ) . DiscriminatorValue ) ;
var VAR0 = VAR1 . Model . FindEntityType ( typeof ( VAR2 ) ) ; Assert . Equal ( LITERAL , VAR0 . Relational ( ) . DiscriminatorProperty . VAR3 ) ; Assert . Equal ( typeof ( string ) , VAR0 . Relational ( ) . DiscriminatorProperty . ClrType ) ; Assert . Equal ( 1 , VAR0 . Relational ( ) . DiscriminatorValue ) ; Assert . Equal ( LITERAL , VAR1 . Model . FindEntityType ( typeof ( SpecialCustomer ) ) . Relational ( ) . DiscriminatorValue ) ;
var VAR0 = VAR1 . FindEntityType ( LITERAL ) ; var VAR2 = VAR1 . FindEntityType ( LITERAL ) ; Assert . NotEmpty ( VAR0 . FindReferencingForeignKeys ( ) ) ; Assert . NotEmpty ( VAR2 . GetForeignKeys ( ) ) ; var VAR3 = VAR2 . FindForeignKey ( VAR2 . FindProperty ( LITERAL ) ) . PrincipalKey ;
var VAR0 = VAR1 . FindEntityType ( LITERAL ) ; Assert . NotEmpty ( VAR0 . FindReferencingForeignKeys ( ) ) ; Assert . NotEmpty ( VAR0 . GetForeignKeys ( ) ) ; var VAR2 = VAR0 . FindForeignKey ( VAR0 . FindProperty ( LITERAL ) ) . PrincipalKey ;
Assert . Same ( VAR0 , VAR1 . TryGetEntry ( new SimpleKeyValue < int > ( VAR0 . EntityType . FindPrimaryKey ( ) , LITERAL ) ) ) ; VAR2 . VAR3 = LITERAL ; VAR4 . DetectChanges ( VAR0 ) ; Assert . Equal ( LITERAL , VAR0 . RelationshipsSnapshot [ VAR0 . EntityType . FindProperty ( LITERAL ) ] ) ; Assert . Same ( VAR0 , VAR1 . TryGetEntry ( new SimpleKeyValue < int > ( VAR0 . EntityType . FindPrimaryKey ( ) , LITERAL ) ) ) ;
Assert . Same ( VAR0 , VAR1 . TryGetEntry ( new SimpleKeyValue < int > ( VAR0 . EntityType . FindPrimaryKey ( ) , - 1 ) ) ) ; VAR2 . VAR3 = LITERAL ; Assert . Equal ( LITERAL , VAR0 . RelationshipsSnapshot [ VAR0 . EntityType . FindProperty ( LITERAL ) ] ) ; Assert . Same ( VAR0 , VAR1 . TryGetEntry ( new SimpleKeyValue < int > ( VAR0 . EntityType . FindPrimaryKey ( ) , - 1 ) ) ) ;
Assert . Same ( VAR0 , VAR1 . TryGetEntry ( new SimpleKeyValue < int > ( VAR0 . EntityType . FindPrimaryKey ( ) , - 1 ) ) ) ; VAR2 . VAR3 = LITERAL ; Assert . Equal ( LITERAL , VAR0 . RelationshipsSnapshot [ VAR0 . EntityType . FindProperty ( LITERAL ) ] ) ; Assert . Same ( VAR0 , VAR1 . TryGetEntry ( new SimpleKeyValue < int > ( VAR0 . EntityType . FindPrimaryKey ( ) , - 1 ) ) ) ; var VAR4 = VAR5 . GetRequiredService < TestRelationshipListener > ( ) ; Assert . Same ( VAR0 , VAR4 . VAR6 . Item1 ) ; Assert . Same ( VAR0 . EntityType . FindProperty ( LITERAL ) , VAR4 . VAR6 . Item2 ) ;
Assert . Same ( VAR0 , VAR1 . TryGetEntry ( new SimpleKeyValue < int > ( VAR0 . EntityType . FindPrimaryKey ( ) , - 1 ) ) ) ; VAR2 . VAR3 = LITERAL ; Assert . Equal ( LITERAL , VAR0 . RelationshipsSnapshot [ VAR0 . EntityType . FindProperty ( LITERAL ) ] ) ; Assert . Same ( VAR0 , VAR1 . TryGetEntry ( new SimpleKeyValue < int > ( VAR0 . EntityType . FindPrimaryKey ( ) , - 1 ) ) ) ;
Assert . Equal ( LITERAL , VAR0 . RelationshipsSnapshot [ VAR0 . EntityType . FindProperty ( LITERAL ) ] ) ; var VAR1 = VAR2 . GetRequiredService < TestRelationshipListener > ( ) ; Assert . Same ( VAR0 , VAR1 . VAR3 . Item1 ) ; Assert . Same ( VAR0 . EntityType . FindProperty ( LITERAL ) , VAR1 . VAR3 . Item2 ) ;
Assert . Equal ( VAR0 , VAR1 . RelationshipsSnapshot [ VAR1 . EntityType . FindNavigation ( LITERAL ) ] ) ; var VAR2 = VAR3 . GetRequiredService < TestRelationshipListener > ( ) ; Assert . Same ( VAR1 , VAR2 . VAR4 . Item1 ) ; Assert . Same ( VAR1 . EntityType . FindNavigation ( LITERAL ) , VAR2 . VAR4 . Item2 ) ;
var VAR0 = VAR1 . FindEntityType ( typeof ( SomeDependentEntity ) . FullName ) ; var VAR2 = VAR0 . GetForeignKeys ( ) . Single ( ) ; var VAR3 = VAR2 . Properties . Single ( ) ; var VAR4 = TestHelpers . Instance . CreateContextServices ( VAR1 ) ; var VAR5 = CreateInternalEntry ( VAR4 , VAR0 , new SomeDependentEntity ( ) ) ; VAR5 [ VAR3 ] = LITERAL ; VAR5 . RelationshipsSnapshot [ VAR3 ] = LITERAL ; var VAR6 = VAR5 . GetDependentKeyValue ( VAR2 ) ; Assert . IsType < SimpleKeyValue < int > > ( VAR6 ) ; Assert . Equal ( LITERAL , VAR6 . Value ) ; Assert . Same ( VAR2 . PrincipalEntityType . FindPrimaryKey ( ) , VAR6 . Key ) ;
var VAR0 = VAR1 . FindEntityType ( typeof ( SomeDependentEntity ) . FullName ) ; var VAR2 = VAR0 . GetForeignKeys ( ) . Single ( ) ; var VAR3 = VAR2 . Properties . Single ( ) ; var VAR4 = TestHelpers . Instance . CreateContextServices ( VAR1 ) ; var VAR5 = CreateInternalEntry ( VAR4 , VAR0 , new SomeDependentEntity ( ) ) ; VAR5 [ VAR3 ] = LITERAL ; var VAR6 = VAR5 . RelationshipsSnapshot . GetDependentKeyValue ( VAR2 ) ; Assert . IsType < SimpleKeyValue < int > > ( VAR6 ) ; Assert . Equal ( LITERAL , VAR6 . Value ) ; Assert . Same ( VAR2 . PrincipalEntityType . FindPrimaryKey ( ) , VAR6 . Key ) ;
var VAR0 = VAR1 . FindEntityType ( typeof ( SomeEntity ) . FullName ) ; var VAR2 = VAR1 . FindEntityType ( typeof ( SomeDependentEntity ) . FullName ) ; var VAR3 = VAR0 . FindProperty ( LITERAL ) ; var VAR4 = TestHelpers . Instance . CreateContextServices ( VAR1 ) ; var VAR5 = CreateInternalEntry ( VAR4 , VAR0 , new SomeEntity ( ) ) ; VAR5 [ VAR3 ] = LITERAL ; var VAR6 = VAR2 . GetForeignKeys ( ) . Single ( ) ; var VAR7 = VAR5 . GetPrincipalKeyValue ( VAR6 ) ; Assert . IsType < SimpleKeyValue < int > > ( VAR7 ) ; Assert . Equal ( LITERAL , VAR7 . Value ) ; Assert . Same ( VAR6 . PrincipalEntityType . FindPrimaryKey ( ) , VAR7 . Key ) ;
var VAR0 = VAR1 . FindEntityType ( typeof ( SomeMoreDependentEntity ) . FullName ) ; var VAR2 = VAR0 . GetForeignKeys ( ) . Single ( ) ; var VAR3 = TestHelpers . Instance . CreateContextServices ( VAR1 ) ; var VAR4 = CreateInternalEntry ( VAR3 , VAR0 , new SomeMoreDependentEntity ( ) ) ; VAR4 [ VAR2 . Properties [ 0 ] ] = LITERAL ; VAR4 [ VAR2 . Properties [ 1 ] ] = LITERAL ; var VAR5 = ( CompositeKeyValue ) VAR4 . GetDependentKeyValue ( VAR2 ) ; Assert . Equal ( LITERAL , VAR5 . Value [ 0 ] ) ; Assert . Equal ( LITERAL , VAR5 . Value [ 1 ] ) ; Assert . Same ( VAR2 . PrincipalEntityType . FindPrimaryKey ( ) , VAR5 . Key ) ;
var VAR0 = CreateModel ( VAR1 ) ; var VAR2 = Assert . Single ( VAR0 . Tables . Single ( VAR3 => VAR3 . ForeignKeys . Count > 0 ) . ForeignKeys ) ; Assert . Equal ( LITERAL , VAR2 . Table . SchemaName ) ; Assert . Equal ( LITERAL , VAR2 . Table . Name ) ; Assert . Equal ( LITERAL , VAR2 . PrincipalTable . SchemaName ) ; Assert . Equal ( LITERAL , VAR2 . PrincipalTable . Name ) ; Assert . Equal ( LITERAL , VAR2 . Columns . Single ( ) . Name ) ; Assert . Equal ( LITERAL , VAR2 . PrincipalColumns . Single ( ) . Name ) ;
Assert . Equal ( new [ ] { LITERAL , LITERAL } , VAR0 . GetProperties ( ) . Select ( VAR1 => VAR1 . VAR2 ) . ToArray ( ) ) ; Assert . Equal ( new [ ] { LITERAL , LITERAL } , VAR3 . GetProperties ( ) . Select ( VAR1 => VAR1 . VAR2 ) . ToArray ( ) ) ; Assert . Equal ( new [ ] { LITERAL , LITERAL } , VAR4 . GetProperties ( ) . Select ( VAR1 => VAR1 . VAR2 ) . ToArray ( ) ) ; VAR3 . BaseType = VAR0 ; VAR4 . BaseType = VAR0 ; Assert . Equal ( new [ ] { LITERAL , LITERAL } , VAR0 . GetProperties ( ) . Select ( VAR1 => VAR1 . VAR2 ) . ToArray ( ) ) ; Assert . Equal ( new [ ] { LITERAL , LITERAL , LITERAL , LITERAL } , VAR3 . GetProperties ( ) . Select ( VAR1 => VAR1 . VAR2 ) . ToArray ( ) ) ; Assert . Equal ( new [ ] { LITERAL , LITERAL , LITERAL , LITERAL } , VAR4 . GetProperties ( ) . Select ( VAR1 => VAR1 . VAR2 ) . ToArray ( ) ) ; Assert . Equal ( new [ ] { 0 , 1 , LITERAL , LITERAL } , VAR3 . GetProperties ( ) . Select ( VAR1 => VAR1 . Index ) ) ; Assert . Equal ( new [ ] { 0 , 1 , LITERAL , LITERAL } , VAR4 . GetProperties ( ) . Select ( VAR1 => VAR1 . Index ) ) ;
Assert . Equal ( new [ ] { LITERAL } , VAR0 . GetNavigations ( ) . Select ( VAR1 => VAR1 . VAR2 ) . ToArray ( ) ) ; Assert . Equal ( new string [ 0 ] , VAR3 . GetNavigations ( ) . Select ( VAR1 => VAR1 . VAR2 ) . ToArray ( ) ) ; VAR3 . BaseType = VAR0 ; Assert . Equal ( new [ ] { LITERAL } , VAR0 . GetNavigations ( ) . Select ( VAR1 => VAR1 . VAR2 ) . ToArray ( ) ) ; Assert . Equal ( new [ ] { LITERAL } , VAR3 . GetNavigations ( ) . Select ( VAR1 => VAR1 . VAR2 ) . ToArray ( ) ) ; var VAR4 = VAR5 . GetOrAddProperty ( Order . VAR6 ) ; var VAR7 = VAR5 . GetOrAddForeignKey ( VAR4 , VAR8 , VAR3 ) ; VAR3 . AddNavigation ( LITERAL , VAR7 , pointsToPrincipal : false ) ; Assert . Equal ( new [ ] { LITERAL } , VAR0 . GetNavigations ( ) . Select ( VAR1 => VAR1 . VAR2 ) . ToArray ( ) ) ; Assert . Equal ( new [ ] { LITERAL , LITERAL } , VAR3 . GetNavigations ( ) . Select ( VAR1 => VAR1 . VAR2 ) . ToArray ( ) ) ;
Assert . Contains ( VAR0 . Metadata . GetNavigations ( ) , VAR1 => VAR1 . Name == nameof ( VAR2 . VAR3 ) ) ; Assert . DoesNotContain ( VAR0 . Metadata . GetNavigations ( ) , VAR1 => VAR1 . Name == nameof ( VAR2 . VAR4 ) ) ; Assert . Contains ( VAR5 . Metadata . GetNavigations ( ) , VAR1 => VAR1 . Name == nameof ( VAR4 . VAR2 ) ) ; new InversePropertyAttributeConvention ( ) . Apply ( VAR5 ) ; Assert . Contains ( VAR0 . Metadata . GetNavigations ( ) , VAR1 => VAR1 . Name == nameof ( VAR2 . VAR3 ) ) ; Assert . DoesNotContain ( VAR0 . Metadata . GetNavigations ( ) , VAR1 => VAR1 . Name == nameof ( VAR2 . VAR4 ) ) ; Assert . Contains ( VAR5 . Metadata . GetNavigations ( ) , VAR1 => VAR1 . Name == nameof ( VAR4 . VAR2 ) ) ;
Assert . Contains ( LITERAL , VAR0 . GetEntityType ( typeof ( BookLabel ) ) . GetNavigations ( ) . Select ( VAR1 => VAR1 . Name ) ) ; Assert . Equal ( LITERAL , VAR0 . GetEntityType ( typeof ( BookLabel ) ) . FindNavigation ( LITERAL ) . ForeignKey . PrincipalToDependent . Name ) ; Assert . Contains ( LITERAL , VAR0 . GetEntityType ( typeof ( Book ) ) . GetNavigations ( ) . Select ( VAR1 => VAR1 . Name ) ) ; Assert . Null ( VAR0 . GetEntityType ( typeof ( Book ) ) . FindNavigation ( LITERAL ) . ForeignKey . PrincipalToDependent ) ; VAR2 . Entity < SpecialBookLabel > ( ) . HasBaseType ( null ) ; Assert . Null ( VAR0 . GetEntityType ( typeof ( SpecialBookLabel ) ) . GetNavigations ( ) . Single ( VAR3 => VAR3 . Name == LITERAL ) . FindInverse ( ) ) ; Assert . Contains ( LITERAL , VAR0 . GetEntityType ( typeof ( BookLabel ) ) . GetNavigations ( ) . Select ( VAR1 => VAR1 . Name ) ) ; Assert . Equal ( LITERAL , VAR0 . GetEntityType ( typeof ( BookLabel ) ) . FindNavigation ( LITERAL ) . ForeignKey . PrincipalToDependent . Name ) ; Assert . Contains ( LITERAL , VAR0 . GetEntityType ( typeof ( Book ) ) . GetNavigations ( ) . Select ( VAR1 => VAR1 . Name ) ) ;
Assert . Equal ( LITERAL , VAR0 . GetNavigations ( ) . Single ( ) . Name ) ; Assert . Equal ( LITERAL , VAR1 . GetNavigations ( ) . Single ( ) . Name ) ; Assert . Same ( VAR2 , VAR0 . GetNavigations ( ) . Single ( ) . ForeignKey ) ; Assert . Same ( VAR2 , VAR1 . GetNavigations ( ) . Single ( ) . ForeignKey ) ; AssertEqual ( new [ ] { LITERAL , VAR3 . Properties . Single ( ) . Name } , VAR1 . GetProperties ( ) . Select ( VAR4 => VAR4 . Name ) ) ; AssertEqual ( new [ ] { VAR5 . Name , VAR6 . Properties . Single ( ) . Name } , VAR0 . GetProperties ( ) . Select ( VAR4 => VAR4 . Name ) ) ;
var VAR0 = VAR1 . GetNavigations ( ) . Single ( ) . ForeignKey ; Assert . Same ( VAR1 . GetProperty ( nameof ( Pickle . BurgerId ) ) , VAR0 . Properties . Single ( ) ) ; Assert . Equal ( nameof ( Pickle . BigMak ) , VAR0 . DependentToPrincipal . Name ) ; Assert . Null ( VAR0 . PrincipalToDependent ) ; Assert . NotSame ( VAR0 , VAR2 . GetNavigations ( ) . Single ( ) . ForeignKey ) ;
Assert . Same ( VAR0 , VAR1 . TryGetEntry ( new SimpleKeyValue < int > ( VAR0 . EntityType . GetPrimaryKey ( ) , - 1 ) ) ) ; VAR2 . VAR3 = LITERAL ; Assert . Equal ( LITERAL , VAR0 . RelationshipsSnapshot [ VAR0 . EntityType . GetProperty ( LITERAL ) ] ) ; Assert . Same ( VAR0 , VAR1 . TryGetEntry ( new SimpleKeyValue < int > ( VAR0 . EntityType . GetPrimaryKey ( ) , - 1 ) ) ) ;
Assert . False ( VAR0 . IsModified ( VAR1 ) ) ; VAR0 . SetEntityState ( EntityState . Unchanged , true ) ; Assert . False ( VAR0 . IsModified ( VAR1 ) ) ; VAR0 . SetPropertyModified ( VAR1 ) ; Assert . True ( VAR0 . IsModified ( VAR1 ) ) ;
Assert . False ( VAR0 . IsModified ( VAR1 ) ) ; Assert . False ( VAR0 . IsModified ( VAR2 ) ) ; VAR0 . MarkAsTemporary ( VAR1 ) ; Assert . True ( VAR0 . HasTemporaryValue ( VAR1 ) ) ; Assert . False ( VAR0 . HasTemporaryValue ( VAR2 ) ) ; Assert . False ( VAR0 . IsModified ( VAR1 ) ) ; Assert . False ( VAR0 . IsModified ( VAR2 ) ) ; VAR0 . MarkAsTemporary ( VAR2 ) ; VAR0 . MarkAsTemporary ( VAR1 , isTemporary : false ) ; Assert . False ( VAR0 . HasTemporaryValue ( VAR1 ) ) ; Assert . True ( VAR0 . HasTemporaryValue ( VAR2 ) ) ; Assert . False ( VAR0 . IsModified ( VAR1 ) ) ; Assert . False ( VAR0 . IsModified ( VAR2 ) ) ;
Assert . False ( VAR0 . IsModified ( VAR1 ) ) ; Assert . False ( VAR0 . IsModified ( VAR2 ) ) ; VAR0 . MarkAsTemporary ( VAR1 ) ; VAR0 . MarkAsTemporary ( VAR2 ) ; Assert . False ( VAR0 . HasTemporaryValue ( VAR1 ) ) ; Assert . False ( VAR0 . HasTemporaryValue ( VAR2 ) ) ; Assert . False ( VAR0 . IsModified ( VAR1 ) ) ; Assert . False ( VAR0 . IsModified ( VAR2 ) ) ; VAR0 . SetEntityState ( EntityState . Added ) ; Assert . False ( VAR0 . HasTemporaryValue ( VAR1 ) ) ; Assert . False ( VAR0 . HasTemporaryValue ( VAR2 ) ) ; Assert . False ( VAR0 . IsModified ( VAR1 ) ) ; Assert . False ( VAR0 . IsModified ( VAR2 ) ) ;
Assert . False ( VAR0 . IsModified ( VAR1 ) ) ; Assert . False ( VAR0 . IsModified ( VAR2 ) ) ; VAR0 . SetEntityState ( EntityState . Added ) ; Assert . False ( VAR0 . HasTemporaryValue ( VAR1 ) ) ; Assert . False ( VAR0 . HasTemporaryValue ( VAR2 ) ) ; Assert . False ( VAR0 . IsModified ( VAR1 ) ) ; Assert . False ( VAR0 . IsModified ( VAR2 ) ) ;
Assert . Same ( VAR0 , VAR0 . HasBaseType ( VAR1 . Metadata , ConfigurationSource . Convention ) ) ; Assert . True ( new DiscriminatorConvention ( ) . Apply ( VAR0 , oldBaseType : null ) ) ; var VAR2 = VAR0 . ModelBuilder . Entity ( typeof ( DerivedEntity ) , ConfigurationSource . Explicit ) ; Assert . Same ( VAR2 , VAR2 . HasBaseType ( VAR0 . Metadata , ConfigurationSource . Convention ) ) ;
Assert . NotNull ( VAR0 . Relational ( ConfigurationSource . Convention ) . HasDiscriminator ( LITERAL , typeof ( string ) ) ) ; Assert . Equal ( LITERAL , VAR0 . Metadata . Relational ( ) . DiscriminatorProperty . Name ) ; Assert . Equal ( typeof ( string ) , VAR0 . Metadata . Relational ( ) . DiscriminatorProperty . ClrType ) ; Assert . Null ( VAR0 . Relational ( ConfigurationSource . Convention ) . HasDiscriminator ( LITERAL , typeof ( int ? ) ) ) ;
var VAR0 = VAR1 . HasForeignKey ( typeof ( VAR2 ) . FullName , new [ ] { Order . VAR3 . Name , Order . VAR4 . Name } , ConfigurationSource . DataAnnotation ) ; Assert . Same ( VAR0 , VAR1 . Navigation ( Order . VAR5 . Name , VAR0 . Metadata , pointsToPrincipal : true , configurationSource : ConfigurationSource . DataAnnotation ) ) ; Assert . Same ( VAR0 , VAR6 . Navigation ( VAR2 . VAR7 . Name , VAR0 . Metadata , pointsToPrincipal : false , configurationSource : ConfigurationSource . DataAnnotation ) ) ; Assert . True ( VAR1 . Ignore ( Order . VAR5 . Name , ConfigurationSource . Explicit ) ) ; Assert . True ( VAR6 . Ignore ( VAR2 . VAR7 . Name , ConfigurationSource . Explicit ) ) ; Assert . Null ( VAR1 . Metadata . FindNavigation ( Order . VAR5 . Name ) ) ; Assert . Null ( VAR6 . Metadata . FindNavigation ( VAR2 . VAR7 . Name ) ) ; Assert . True ( VAR1 . Ignore ( Order . VAR5 . Name , ConfigurationSource . Convention ) ) ; Assert . True ( VAR6 . Ignore ( VAR2 . VAR7 . Name , ConfigurationSource . Convention ) ) ; Assert . Empty ( VAR1 . Metadata . GetForeignKeys ( ) ) ; VAR0 = VAR1 . HasForeignKey ( typeof ( VAR2 ) . FullName , new [ ] { Order . VAR3 . Name , Order . VAR4 . Name } , ConfigurationSource . DataAnnotation ) ;
Assert . True ( VAR0 . HasAnnotation ( LITERAL , 1 , ConfigurationSource . DataAnnotation ) ) ; Assert . False ( VAR0 . HasAnnotation ( LITERAL , LITERAL , ConfigurationSource . DataAnnotation ) ) ; Assert . Equal ( 1 , VAR1 . Annotations . Single ( ) . Value ) ; Assert . True ( VAR0 . HasAnnotation ( LITERAL , LITERAL , ConfigurationSource . Explicit ) ) ;
VAR0 = new LazyRef < ILogger > ( ( ) => VAR1 . CreateCommandsLogger ( ) ) ; VAR2 = VAR3 ; VAR4 = VAR5 ; VAR6 = VAR7 ; VAR8 = VAR9 ; VAR12 = new DesignTimeServicesBuilder ( VAR11 ) ;
VAR0 . Entity < Animal > ( ) . HasKey ( VAR1 => VAR1 . Species ) ; VAR0 . Entity < Rose > ( ) . BaseType < Flower > ( ) ; VAR0 . Entity < Daisy > ( ) . BaseType < Flower > ( ) ; VAR0 . Entity < Flower > ( ) . BaseType < Plant > ( ) ; VAR0 . Entity < Plant > ( ) . HasKey ( VAR1 => VAR1 . Species ) ;
Check . NotNull ( VAR13 , nameof ( VAR13 ) ) ; Check . NotNull ( VAR1 , nameof ( VAR1 ) ) ; VAR2 = VAR3 ; VAR4 = VAR5 ; VAR6 = VAR7 ; VAR8 = VAR9 ; VAR10 = VAR11 ; VAR14 = VAR13 ;
VAR0 . Entity < Pickle > ( ) . HasOne < BigMak > ( ) . WithMany ( VAR1 => VAR1 . Pickles ) ; var VAR2 = VAR3 . GetForeignKeys ( ) . Single ( ) ; var VAR4 = ( IProperty ) VAR2 . Properties . Single ( ) ; Assert . Equal ( LITERAL , VAR4 . Name ) ; Assert . True ( VAR4 . IsShadowProperty ) ; Assert . Same ( typeof ( int ? ) , VAR4 . ClrType ) ; Assert . Same ( VAR3 , VAR4 . DeclaringEntityType ) ;
VAR0 . Entity < Pickle > ( ) . HasOne < BigMak > ( ) . WithMany ( ) ; var VAR1 = VAR2 . GetForeignKeys ( ) . Single ( VAR3 => VAR3 != VAR4 ) ; var VAR5 = ( IProperty ) VAR1 . Properties . Single ( ) ; Assert . True ( VAR5 . IsShadowProperty ) ; Assert . Same ( typeof ( int ? ) , VAR5 . ClrType ) ; Assert . Same ( VAR2 , VAR5 . DeclaringEntityType ) ;
VAR0 . Property ( VAR1 => VAR1 . Up ) . IsRequired ( ) ; VAR0 . Property ( VAR1 => VAR1 . Down ) . IsRequired ( ) ; VAR0 . Property < int > ( LITERAL ) . IsRequired ( ) ; VAR0 . Property < string > ( LITERAL ) . IsRequired ( ) ; VAR0 . Property < int > ( LITERAL ) . IsRequired ( ) ; VAR0 . Property < string > ( LITERAL ) . IsRequired ( ) ;
VAR0 . Property ( VAR1 => VAR1 . Up ) . HasMaxLength ( 0 ) ; VAR0 . Property ( VAR1 => VAR1 . Down ) . HasMaxLength ( LITERAL ) ; VAR0 . Property < int > ( LITERAL ) . HasMaxLength ( 0 ) ; VAR0 . Property < string > ( LITERAL ) . HasMaxLength ( LITERAL ) ; VAR0 . Property < int > ( LITERAL ) . HasMaxLength ( 0 ) ; VAR0 . Property < string > ( LITERAL ) . HasMaxLength ( LITERAL ) ;
VAR0 . Entity < Customer > ( ) . HasMany ( VAR1 => VAR1 . Orders ) . WithOne ( VAR1 => VAR1 . Customer ) ; Assert . Same ( VAR2 , VAR3 . GetForeignKeys ( ) . Single ( ) ) ; Assert . Equal ( VAR4 . Name , VAR3 . Navigations . Single ( ) . Name ) ; Assert . Same ( VAR5 , VAR6 . Navigations . Single ( ) ) ; Assert . Same ( VAR2 , VAR3 . Navigations . Single ( ) . ForeignKey ) ; Assert . Same ( VAR2 , VAR6 . Navigations . Single ( ) . ForeignKey ) ; AssertEqual ( new [ ] { LITERAL , VAR7 . Properties . Single ( ) . Name , Customer . NameProperty . Name } , VAR6 . Properties . Select ( VAR8 => VAR8 . Name ) ) ; AssertEqual ( new [ ] { LITERAL , VAR2 . Properties . Single ( ) . Name , VAR9 . Properties . Single ( ) . Name } , VAR3 . Properties . Select ( VAR8 => VAR8 . Name ) ) ; Assert . Empty ( VAR6 . GetForeignKeys ( ) ) ;
VAR0 . Entity < Customer > ( ) . HasMany ( VAR1 => VAR1 . Orders ) . WithOne ( VAR1 => VAR1 . Customer ) ; var VAR2 = VAR3 . GetForeignKeys ( ) . Single ( ) ; AssertEqual ( VAR4 . Properties , VAR2 . Properties ) ; Assert . Equal ( LITERAL , VAR3 . Navigations . Single ( ) . Name ) ; Assert . Equal ( VAR5 . Name , VAR6 . Navigations . Single ( ) . Name ) ; Assert . Same ( VAR2 , VAR3 . Navigations . Single ( ) . ForeignKey ) ; Assert . Same ( VAR2 , VAR6 . Navigations . Single ( ) . ForeignKey ) ; AssertEqual ( new [ ] { LITERAL , VAR7 . Properties . Single ( ) . Name , Customer . NameProperty . Name } , VAR6 . Properties . Select ( VAR8 => VAR8 . Name ) ) ; AssertEqual ( new [ ] { LITERAL , VAR4 . Properties . Single ( ) . Name , VAR9 . Properties . Single ( ) . Name } , VAR3 . Properties . Select ( VAR8 => VAR8 . Name ) ) ; Assert . Empty ( VAR6 . GetForeignKeys ( ) ) ;
VAR0 . Entity < VAR1 > ( ) . HasKey ( VAR2 => VAR2 . VAR3 ) ; VAR0 . Entity < VAR4 > ( ) . HasKey ( VAR2 => VAR2 . VAR5 ) ; VAR0 . Entity < VAR6 > ( ) . HasKey ( VAR7 => VAR7 . VAR8 ) ; VAR0 . Entity < VAR9 > ( ) . HasKey ( VAR10 => VAR10 . VAR11 ) ; VAR0 . Entity < OrderDetail > ( ) . HasKey ( VAR7 => VAR7 . VAR12 ) ;
VAR0 . HasKey ( LITERAL ) ; VAR0 . Property < int > ( LITERAL ) ; VAR1 . Entity ( LITERAL , VAR0 => { VAR0 . Property < int > ( LITERAL ) ; VAR0 . HasKey ( LITERAL ) ; VAR0 . Property < int > ( LITERAL ) ; } ) ; VAR1 . Entity ( LITERAL ) . HasOne ( LITERAL ) . WithMany ( ) . ForeignKey ( LITERAL ) ; VAR1 . Entity ( LITERAL ) . HasOne ( LITERAL ) . WithMany ( ) . ForeignKey ( LITERAL ) ;
VAR0 . HasKey ( LITERAL ) ; VAR0 . Property < int > ( LITERAL ) ; VAR0 . HasAlternateKey ( LITERAL ) ; VAR0 . Property < int ? > ( LITERAL ) ; VAR0 . HasOne ( LITERAL ) . WithMany ( ) . ForeignKey ( LITERAL ) ;
Check . NotNull ( VAR8 , nameof ( VAR8 ) ) ; Check . NotNull ( VAR1 , nameof ( VAR1 ) ) ; Check . NotNull ( VAR10 , nameof ( VAR10 ) ) ; VAR2 = VAR3 ; VAR7 = VAR8 ; VAR9 = VAR1 ; VAR11 = VAR10 ;
VAR0 . Attach ( VAR1 , behavior : GraphBehavior . SingleObject ) ; Assert . Equal ( LITERAL , VAR1 . VAR2 ) ; Assert . Same ( VAR1 , VAR3 . VAR4 . Single ( ) ) ; Assert . Null ( VAR1 . VAR5 ) ; Assert . Equal ( EntityState . Detached , VAR0 . Entry ( VAR3 ) . State ) ; Assert . Equal ( EntityState . Unchanged , VAR0 . Entry ( VAR1 ) . State ) ; VAR0 . Attach ( VAR3 , behavior : GraphBehavior . SingleObject ) ;
var VAR0 = VAR1 . Attach ( new VAR2 { VAR3 = LITERAL , VAR4 = new List < Product > ( ) } , behavior : GraphBehavior . SingleObject ) . Entity ; var VAR5 = new VAR2 { VAR3 = 1 , VAR6 = LITERAL } ; var VAR7 = new Product { VAR3 = 1 , VAR8 = LITERAL , VAR6 = LITERAL , VAR2 = VAR5 } ; VAR5 . VAR4 = new List < Product > { VAR7 } ; VAR1 . Attach ( VAR5 , behavior : GraphBehavior . SingleObject ) ;
var VAR0 = VAR1 . Attach ( new VAR2 { VAR3 = LITERAL , VAR4 = new List < Product > ( ) } , behavior : GraphBehavior . SingleObject ) . Entity ; var VAR5 = new VAR2 { VAR3 = 1 , VAR6 = LITERAL } ; var VAR7 = new Product { VAR3 = 1 , VAR8 = LITERAL , VAR6 = LITERAL , VAR2 = VAR5 } ; VAR5 . VAR4 = new List < Product > { VAR7 } ; VAR1 . Attach ( VAR7 , behavior : GraphBehavior . SingleObject ) ;
VAR0 . Attach ( VAR1 , behavior : GraphBehavior . SingleObject ) ; Assert . Equal ( LITERAL , VAR1 . VAR2 ) ; Assert . Same ( VAR1 , VAR3 . VAR4 . Single ( ) ) ; Assert . Same ( VAR5 , VAR1 . VAR6 ) ; Assert . Same ( VAR1 , VAR5 . VAR4 . Single ( ) ) ; Assert . Equal ( EntityState . Detached , VAR0 . Entry ( VAR3 ) . State ) ; Assert . Equal ( EntityState . Unchanged , VAR0 . Entry ( VAR1 ) . State ) ; VAR0 . Attach ( VAR3 , behavior : GraphBehavior . SingleObject ) ;
var VAR0 = VAR1 . Attach ( new VAR2 { VAR3 = LITERAL , VAR4 = new List < Product > ( ) } , behavior : GraphBehavior . SingleObject ) . Entity ; var VAR5 = new VAR2 { VAR3 = 1 , VAR6 = LITERAL } ; var VAR7 = new Product { VAR3 = 1 , VAR8 = LITERAL , VAR6 = LITERAL , VAR2 = VAR5 } ; VAR5 . VAR4 = new List < Product > ( ) ; VAR1 . Attach ( VAR7 , behavior : GraphBehavior . SingleObject ) ;
var VAR0 = VAR1 . Attach ( new VAR2 { VAR3 = LITERAL , VAR4 = new List < Product > ( ) } , behavior : GraphBehavior . SingleObject ) . Entity ; var VAR5 = new VAR2 { VAR3 = 1 , VAR6 = LITERAL } ; var VAR7 = new Product { VAR3 = 1 , VAR8 = LITERAL , VAR6 = LITERAL } ; VAR5 . VAR4 = new List < Product > { VAR7 } ; VAR1 . Attach ( VAR7 , behavior : GraphBehavior . SingleObject ) ; Assert . Equal ( LITERAL , VAR7 . VAR8 ) ; Assert . Same ( VAR7 , VAR5 . VAR4 . Single ( ) ) ; Assert . Same ( VAR0 , VAR7 . VAR2 ) ; Assert . Same ( VAR7 , VAR0 . VAR4 . Single ( ) ) ; Assert . Equal ( EntityState . Detached , VAR1 . Entry ( VAR5 ) . State ) ; Assert . Equal ( EntityState . Unchanged , VAR1 . Entry ( VAR7 ) . State ) ; VAR1 . Attach ( VAR5 , behavior : GraphBehavior . SingleObject ) ;
VAR0 . Attach ( VAR1 , behavior : GraphBehavior . SingleObject ) ; Assert . Equal ( LITERAL , VAR1 . VAR2 ) ; Assert . Same ( VAR1 , VAR3 . VAR4 . Single ( ) ) ; Assert . Same ( VAR5 , VAR1 . VAR6 ) ; Assert . Same ( VAR1 , VAR5 . VAR4 . Single ( ) ) ; Assert . Equal ( EntityState . Detached , VAR0 . Entry ( VAR3 ) . State ) ; Assert . Equal ( EntityState . Unchanged , VAR0 . Entry ( VAR1 ) . State ) ; VAR0 . Attach ( VAR3 , behavior : GraphBehavior . SingleObject ) ;
var VAR0 = new ModificationCommand ( LITERAL , null , new ParameterNameGenerator ( ) , VAR1 => VAR1 . TestProvider ( ) , new UntypedRelationalValueBufferFactoryFactory ( ) ) ; VAR0 . AddEntry ( VAR2 ) ; var VAR3 = VAR4 . GetOrCreateEntry ( new object ( ) ) ; VAR3 [ VAR5 ] = LITERAL ; VAR3 . SetEntityState ( EntityState . Modified ) ; var VAR6 = new ModificationCommand ( LITERAL , null , new ParameterNameGenerator ( ) , VAR1 => VAR1 . TestProvider ( ) , new UntypedRelationalValueBufferFactoryFactory ( ) ) ; VAR6 . AddEntry ( VAR3 ) ; var VAR7 = VAR4 . GetOrCreateEntry ( new object ( ) ) ; VAR7 [ VAR5 ] = LITERAL ; VAR7 . SetEntityState ( EntityState . Deleted ) ; var VAR8 = new ModificationCommand ( LITERAL , null , new ParameterNameGenerator ( ) , VAR1 => VAR1 . TestProvider ( ) , new UntypedRelationalValueBufferFactoryFactory ( ) ) ;
var VAR0 = new ModificationCommand ( LITERAL , null , new ParameterNameGenerator ( ) , VAR1 => VAR1 . TestProvider ( ) , new UntypedRelationalValueBufferFactoryFactory ( ) ) ; VAR0 . AddEntry ( VAR2 ) ; Assert . Equal ( LITERAL , VAR0 . TableName ) ; Assert . Null ( VAR0 . Schema ) ; Assert . Equal ( EntityState . Added , VAR0 . EntityState ) ; Assert . Equal ( LITERAL , VAR0 . ColumnModifications . Count ) ;
VAR0 . Attach ( VAR1 , includeDependents : false ) ; Assert . Equal ( LITERAL , VAR2 . VAR3 ) ; Assert . Same ( VAR2 , VAR1 . VAR4 . Single ( ) ) ; Assert . Same ( VAR1 , VAR2 . VAR5 ) ; Assert . Equal ( EntityState . Unchanged , VAR0 . Entry ( VAR1 ) . State ) ; Assert . Equal ( EntityState . Detached , VAR0 . Entry ( VAR2 ) . State ) ; VAR0 . Attach ( VAR2 , includeDependents : false ) ;
VAR0 . Attach ( VAR1 , includeDependents : false ) ; Assert . Equal ( LITERAL , VAR2 . VAR3 ) ; Assert . Empty ( VAR1 . VAR4 ) ; Assert . Same ( VAR1 , VAR2 . VAR5 ) ; Assert . Equal ( EntityState . Unchanged , VAR0 . Entry ( VAR1 ) . State ) ; Assert . Equal ( EntityState . Detached , VAR0 . Entry ( VAR2 ) . State ) ; VAR0 . Attach ( VAR2 , includeDependents : false ) ;
var VAR0 = VAR1 . Attach ( new VAR2 { VAR3 = LITERAL , VAR4 = new List < Product > ( ) } , includeDependents : false ) . Entity ; var VAR5 = new VAR2 { VAR3 = 1 , VAR6 = LITERAL } ; var VAR7 = new Product { VAR3 = 1 , VAR8 = LITERAL , VAR6 = LITERAL , VAR2 = VAR5 } ; VAR5 . VAR4 = new List < Product > { VAR7 } ; VAR1 . Attach ( VAR5 , includeDependents : false ) ;
VAR0 . Attach ( VAR1 , includeDependents : false ) ; Assert . Equal ( LITERAL , VAR2 . VAR3 ) ; Assert . Same ( VAR2 , VAR1 . VAR4 . Single ( ) ) ; Assert . Same ( VAR1 , VAR2 . VAR5 ) ; Assert . Empty ( VAR6 . VAR4 ) ; Assert . Equal ( EntityState . Unchanged , VAR0 . Entry ( VAR1 ) . State ) ; Assert . Equal ( EntityState . Detached , VAR0 . Entry ( VAR2 ) . State ) ; VAR0 . Attach ( VAR2 , includeDependents : false ) ;
var VAR0 = VAR1 . Attach ( new VAR2 { VAR3 = LITERAL , VAR4 = new List < Product > ( ) } , includeDependents : false ) . Entity ; var VAR5 = new VAR2 { VAR3 = 1 , VAR6 = LITERAL } ; var VAR7 = new Product { VAR3 = 1 , VAR8 = LITERAL , VAR6 = LITERAL , VAR2 = VAR5 } ; VAR5 . VAR4 = new List < Product > { VAR7 } ; VAR1 . Attach ( VAR7 , includeDependents : false ) ;
Assert . Equal ( LITERAL , VAR0 . VAR1 ) ; Assert . Empty ( VAR2 . VAR3 ) ; Assert . Same ( VAR2 , VAR0 . VAR4 ) ; Assert . Equal ( EntityState . Detached , VAR5 . Entry ( VAR2 ) . State ) ; Assert . Equal ( EntityState . Unchanged , VAR5 . Entry ( VAR0 ) . State ) ; VAR5 . Attach ( VAR2 ) ; Assert . Equal ( LITERAL , VAR0 . VAR1 ) ; Assert . Empty ( VAR2 . VAR3 ) ; Assert . Same ( VAR2 , VAR0 . VAR4 ) ; Assert . Equal ( EntityState . Unchanged , VAR5 . Entry ( VAR2 ) . State ) ; Assert . Equal ( EntityState . Unchanged , VAR5 . Entry ( VAR0 ) . State ) ;
Assert . Equal ( LITERAL , VAR0 . VAR1 ) ; Assert . Same ( VAR0 , VAR2 . VAR3 . Single ( ) ) ; Assert . Same ( VAR2 , VAR0 . VAR4 ) ; Assert . Equal ( EntityState . Detached , VAR5 . Entry ( VAR2 ) . State ) ; Assert . Equal ( EntityState . Unchanged , VAR5 . Entry ( VAR0 ) . State ) ; VAR5 . Entry ( VAR2 ) . State = EntityState . Unchanged ; Assert . Equal ( LITERAL , VAR0 . VAR1 ) ; Assert . Same ( VAR0 , VAR2 . VAR3 . Single ( ) ) ; Assert . Same ( VAR2 , VAR0 . VAR4 ) ; Assert . Equal ( EntityState . Unchanged , VAR5 . Entry ( VAR2 ) . State ) ; Assert . Equal ( EntityState . Unchanged , VAR5 . Entry ( VAR0 ) . State ) ;
Assert . Equal ( LITERAL , VAR0 . VAR1 ) ; Assert . Empty ( VAR2 . VAR3 ) ; Assert . Same ( VAR2 , VAR0 . VAR4 ) ; Assert . Equal ( EntityState . Unchanged , VAR5 . Entry ( VAR2 ) . State ) ; Assert . Equal ( EntityState . Unchanged , VAR5 . Entry ( VAR0 ) . State ) ;
Assert . Equal ( LITERAL , VAR0 . VAR1 ) ; Assert . Same ( VAR0 , VAR2 . VAR3 . Single ( ) ) ; Assert . Same ( VAR5 , VAR0 . VAR4 ) ; Assert . Same ( VAR0 , VAR5 . VAR3 . Single ( ) ) ; Assert . Equal ( EntityState . Unchanged , VAR6 . Entry ( VAR2 ) . State ) ; Assert . Equal ( EntityState . Unchanged , VAR6 . Entry ( VAR0 ) . State ) ;
var VAR0 = new RelationalTypeMapping ( LITERAL ) . CreateParameter ( CreateTestCommand ( ) , LITERAL , LITERAL , isNullable : true ) ; Assert . Equal ( ParameterDirection . Input , VAR0 . VAR1 ) ; Assert . Equal ( LITERAL , VAR0 . VAR2 ) ; Assert . Equal ( LITERAL , VAR0 . VAR3 ) ; Assert . Equal ( VAR5 , VAR0 . VAR4 ) ;
VAR0 . AddProperty ( C . VAR3 ) ; VAR0 . AddProperty ( C . VAR4 ) ; var VAR1 = VAR2 . AddEntityType ( typeof ( D ) ) ; VAR1 . AddProperty ( A . VAR5 ) ; VAR1 . AddProperty ( A . VAR6 ) ;
var VAR0 = VAR1 . GetOrAddProperty ( Order . VAR2 ) ; VAR1 . GetOrAddForeignKey ( VAR0 , VAR4 , VAR5 ) ; var VAR6 = VAR7 . GetOrAddProperty ( Order . VAR8 ) ; VAR7 . GetOrAddForeignKey ( VAR6 , VAR4 , VAR5 ) ;
Assert . Same ( VAR0 , VAR1 . TryGetEntry ( new SimpleEntityKey < int > ( VAR0 . EntityType . GetPrimaryKey ( ) , - 1 ) ) ) ; VAR2 . VAR3 = LITERAL ; VAR4 . DetectChanges ( VAR0 ) ; Assert . Equal ( LITERAL , VAR0 . RelationshipsSnapshot [ VAR0 . EntityType . GetProperty ( LITERAL ) ] ) ; Assert . Same ( VAR0 , VAR1 . TryGetEntry ( new SimpleEntityKey < int > ( VAR0 . EntityType . GetPrimaryKey ( ) , - 1 ) ) ) ;
Assert . Same ( VAR0 , VAR1 . TryGetEntry ( new SimpleEntityKey < int > ( VAR0 . EntityType . GetPrimaryKey ( ) , - 1 ) ) ) ; VAR2 . VAR3 = LITERAL ; Assert . Equal ( LITERAL , VAR0 . RelationshipsSnapshot [ VAR0 . EntityType . GetProperty ( LITERAL ) ] ) ; Assert . Same ( VAR0 , VAR1 . TryGetEntry ( new SimpleEntityKey < int > ( VAR0 . EntityType . GetPrimaryKey ( ) , - 1 ) ) ) ;
Assert . Null ( VAR0 . Relational ( ) . FindSequence ( LITERAL ) ) ; Assert . Null ( ( ( IModel ) VAR0 ) . Relational ( ) . FindSequence ( LITERAL ) ) ; Assert . Null ( VAR0 . SqlServer ( ) . FindSequence ( LITERAL ) ) ; Assert . Null ( ( ( IModel ) VAR0 ) . SqlServer ( ) . FindSequence ( LITERAL ) ) ; var VAR1 = VAR0 . SqlServer ( ) . GetOrAddSequence ( LITERAL ) ; Assert . Null ( VAR0 . Relational ( ) . FindSequence ( LITERAL ) ) ; Assert . Null ( ( ( IModel ) VAR0 ) . Relational ( ) . FindSequence ( LITERAL ) ) ; Assert . Equal ( LITERAL , VAR0 . SqlServer ( ) . FindSequence ( LITERAL ) . VAR2 ) ; Assert . Equal ( LITERAL , ( ( IModel ) VAR0 ) . SqlServer ( ) . FindSequence ( LITERAL ) . VAR2 ) ;
Assert . Null ( VAR0 . Relational ( ) . FindSequence ( LITERAL , LITERAL ) ) ; Assert . Null ( ( ( IModel ) VAR0 ) . Relational ( ) . FindSequence ( LITERAL , LITERAL ) ) ; Assert . Null ( VAR0 . SqlServer ( ) . FindSequence ( LITERAL , LITERAL ) ) ; Assert . Null ( ( ( IModel ) VAR0 ) . SqlServer ( ) . FindSequence ( LITERAL , LITERAL ) ) ; var VAR1 = VAR0 . SqlServer ( ) . GetOrAddSequence ( LITERAL , LITERAL ) ; Assert . Null ( VAR0 . Relational ( ) . FindSequence ( LITERAL , LITERAL ) ) ; Assert . Null ( ( ( IModel ) VAR0 ) . Relational ( ) . FindSequence ( LITERAL , LITERAL ) ) ; Assert . Equal ( LITERAL , VAR0 . SqlServer ( ) . FindSequence ( LITERAL , LITERAL ) . VAR2 ) ; Assert . Equal ( LITERAL , ( ( IModel ) VAR0 ) . SqlServer ( ) . FindSequence ( LITERAL , LITERAL ) . VAR2 ) ;
VAR0 . Model . SqlServer ( ) . GetOrAddSequence ( LITERAL , LITERAL ) ; VAR1 . SqlServer ( ) . HiLoSequenceName = LITERAL ; VAR1 . SqlServer ( ) . HiLoSequenceSchema = LITERAL ; VAR1 . SqlServer ( ) . IdentityStrategy = SqlServerIdentityStrategy . SequenceHiLo ; Assert . Equal ( LITERAL , VAR1 . SqlServer ( ) . FindHiLoSequence ( ) . VAR2 ) ; Assert . Equal ( LITERAL , ( ( IProperty ) VAR1 ) . SqlServer ( ) . FindHiLoSequence ( ) . VAR2 ) ; Assert . Equal ( LITERAL , VAR1 . SqlServer ( ) . FindHiLoSequence ( ) . Schema ) ; Assert . Equal ( LITERAL , ( ( IProperty ) VAR1 ) . SqlServer ( ) . FindHiLoSequence ( ) . Schema ) ;
VAR0 . Model . SqlServer ( ) . GetOrAddSequence ( LITERAL , LITERAL ) ; VAR0 . Model . SqlServer ( ) . HiLoSequenceName = LITERAL ; VAR0 . Model . SqlServer ( ) . HiLoSequenceSchema = LITERAL ; VAR1 . SqlServer ( ) . IdentityStrategy = SqlServerIdentityStrategy . SequenceHiLo ; Assert . Equal ( LITERAL , VAR1 . SqlServer ( ) . FindHiLoSequence ( ) . VAR2 ) ; Assert . Equal ( LITERAL , ( ( IProperty ) VAR1 ) . SqlServer ( ) . FindHiLoSequence ( ) . VAR2 ) ; Assert . Equal ( LITERAL , VAR1 . SqlServer ( ) . FindHiLoSequence ( ) . Schema ) ; Assert . Equal ( LITERAL , ( ( IProperty ) VAR1 ) . SqlServer ( ) . FindHiLoSequence ( ) . Schema ) ;
Assert . Same ( typeof ( long ) , VAR0 . ClrType ) ; VAR1 . SqlServer ( ) . AddOrReplaceSequence ( new Sequence ( LITERAL , LITERAL , LITERAL , LITERAL , LITERAL , LITERAL , typeof ( int ) ) ) ; Assert . Null ( VAR1 . Relational ( ) . TryGetSequence ( LITERAL , LITERAL ) ) ; VAR0 = VAR1 . SqlServer ( ) . GetOrAddSequence ( LITERAL , LITERAL ) ; Assert . Equal ( LITERAL , VAR0 . VAR2 ) ; Assert . Equal ( LITERAL , VAR0 . Schema ) ; Assert . Equal ( LITERAL , VAR0 . IncrementBy ) ; Assert . Equal ( LITERAL , VAR0 . StartValue ) ; Assert . Equal ( LITERAL , VAR0 . MinValue ) ; Assert . Equal ( LITERAL , VAR0 . MaxValue ) ; Assert . Same ( typeof ( int ) , VAR0 . ClrType ) ;
var VAR8 = VAR1 . Schema ; var VAR2 = VAR1 . ColumnModifications ; var VAR3 = VAR2 . Where ( VAR4 => VAR4 . IsWrite ) . ToArray ( ) ; var VAR5 = VAR2 . Where ( VAR4 => VAR4 . IsRead ) . ToArray ( ) ; AppendInsertCommand ( VAR6 , VAR7 , VAR8 , VAR3 ) ;
Assert . Equal ( LITERAL , VAR0 . Relational ( ) . TableName ) ; Assert . Equal ( LITERAL , ( ( IEntityType ) VAR0 ) . Relational ( ) . TableName ) ; VAR0 . Relational ( ) . TableName = LITERAL ; Assert . Equal ( LITERAL , VAR0 . DisplayName ( ) ) ; Assert . Equal ( LITERAL , ( ( IEntityType ) VAR0 ) . DisplayName ( ) ) ; Assert . Equal ( LITERAL , VAR0 . Relational ( ) . TableName ) ; Assert . Equal ( LITERAL , ( ( IEntityType ) VAR0 ) . Relational ( ) . TableName ) ; VAR0 . Relational ( ) . TableName = null ; Assert . Equal ( LITERAL , VAR0 . Relational ( ) . TableName ) ; Assert . Equal ( LITERAL , ( ( IEntityType ) VAR0 ) . Relational ( ) . TableName ) ;
Assert . Same ( typeof ( long ) , VAR0 . ClrType ) ; VAR1 . AddOrReplaceSequence ( new Sequence ( LITERAL , LITERAL , LITERAL , LITERAL , LITERAL , LITERAL , typeof ( int ) ) ) ; VAR0 = VAR1 . GetOrAddSequence ( LITERAL , LITERAL ) ; Assert . Equal ( LITERAL , VAR0 . VAR2 ) ; Assert . Equal ( LITERAL , VAR0 . Schema ) ; Assert . Equal ( LITERAL , VAR0 . IncrementBy ) ; Assert . Equal ( LITERAL , VAR0 . StartValue ) ; Assert . Equal ( LITERAL , VAR0 . MinValue ) ; Assert . Equal ( LITERAL , VAR0 . MaxValue ) ; Assert . Same ( typeof ( int ) , VAR0 . ClrType ) ;
Assert . Same ( typeof ( long ) , VAR0 . ClrType ) ; VAR1 . AddOrReplaceSequence ( new Sequence ( LITERAL , null , LITERAL , LITERAL , LITERAL , LITERAL , typeof ( int ) ) ) ; VAR0 = VAR1 . TryGetSequence ( LITERAL ) ; Assert . Equal ( LITERAL , VAR0 . VAR2 ) ; Assert . Null ( VAR0 . Schema ) ; Assert . Equal ( LITERAL , VAR0 . IncrementBy ) ; Assert . Equal ( LITERAL , VAR0 . StartValue ) ; Assert . Equal ( LITERAL , VAR0 . MinValue ) ; Assert . Equal ( LITERAL , VAR0 . MaxValue ) ; Assert . Same ( typeof ( int ) , VAR0 . ClrType ) ;
Assert . Same ( typeof ( long ) , VAR0 . ClrType ) ; VAR1 . AddOrReplaceSequence ( new Sequence ( LITERAL , LITERAL , LITERAL , LITERAL , LITERAL , LITERAL , typeof ( int ) ) ) ; VAR0 = VAR1 . TryGetSequence ( LITERAL , LITERAL ) ; Assert . Equal ( LITERAL , VAR0 . VAR2 ) ; Assert . Equal ( LITERAL , VAR0 . Schema ) ; Assert . Equal ( LITERAL , VAR0 . IncrementBy ) ; Assert . Equal ( LITERAL , VAR0 . StartValue ) ; Assert . Equal ( LITERAL , VAR0 . MinValue ) ; Assert . Equal ( LITERAL , VAR0 . MaxValue ) ; Assert . Same ( typeof ( int ) , VAR0 . ClrType ) ;
Assert . Null ( VAR0 . Sqlite ( ) . GeneratedValueSql ) ; Assert . Null ( ( ( IProperty ) VAR0 ) . Sqlite ( ) . GeneratedValueSql ) ; VAR0 . Relational ( ) . GeneratedValueSql = LITERAL ; Assert . Equal ( LITERAL , VAR0 . Sqlite ( ) . GeneratedValueSql ) ; Assert . Equal ( LITERAL , ( ( IProperty ) VAR0 ) . Sqlite ( ) . GeneratedValueSql ) ; VAR0 . Sqlite ( ) . GeneratedValueSql = LITERAL ; Assert . Equal ( LITERAL , VAR0 . Sqlite ( ) . GeneratedValueSql ) ; Assert . Equal ( LITERAL , ( ( IProperty ) VAR0 ) . Sqlite ( ) . GeneratedValueSql ) ; VAR0 . Sqlite ( ) . GeneratedValueSql = null ; Assert . Equal ( LITERAL , VAR0 . Sqlite ( ) . GeneratedValueSql ) ; Assert . Equal ( LITERAL , ( ( IProperty ) VAR0 ) . Sqlite ( ) . GeneratedValueSql ) ;
VAR4 . BaseType = VAR1 ; Assert . Equal ( new [ ] { LITERAL , LITERAL } , VAR1 . Properties . Select ( VAR2 => VAR2 . VAR3 ) . ToArray ( ) ) ; Assert . Equal ( new [ ] { LITERAL , LITERAL , LITERAL , LITERAL } , VAR4 . Properties . Select ( VAR2 => VAR2 . VAR3 ) . ToArray ( ) ) ; Assert . Equal ( new [ ] { LITERAL , LITERAL } , VAR5 . Properties . Select ( VAR2 => VAR2 . VAR3 ) . ToArray ( ) ) ; Assert . Equal ( new [ ] { 0 , 1 } , VAR1 . Properties . Select ( VAR2 => VAR2 . Index ) ) ; Assert . Equal ( new [ ] { 0 , 1 , LITERAL , LITERAL } , VAR4 . Properties . Select ( VAR2 => VAR2 . Index ) ) ; Assert . Equal ( new [ ] { 0 , 1 } , VAR5 . Properties . Select ( VAR2 => VAR2 . Index ) ) ;
Assert . Null ( VAR0 . Relational ( ) . FindSequence ( LITERAL , LITERAL ) ) ; var VAR1 = VAR2 . GetOrAddSequence ( LITERAL , LITERAL ) ; Assert . Equal ( LITERAL , VAR2 . FindSequence ( LITERAL , LITERAL ) . VAR3 ) ; Assert . Equal ( LITERAL , VAR0 . Relational ( ) . FindSequence ( LITERAL , LITERAL ) . VAR3 ) ;
Assert . False ( VAR0 . IsRequired ) ; Assert . False ( ( ( IForeignKey ) VAR0 ) . IsRequired ) ; VAR1 . IsNullable = false ; Assert . True ( VAR0 . IsRequired ) ;
var VAR2 = CreateInternalEntityTypeBuilder < A > ( ) ; var VAR1 = VAR2 . Property ( typeof ( string ) , LITERAL , ConfigurationSource . Explicit ) ; VAR1 . Required ( false , ConfigurationSource . Explicit ) ; new RequiredPropertyAttributeConvention ( ) . Apply ( VAR1 ) ;
Assert . Null ( VAR0 . SqlServer ( ) . TryGetHiLoSequence ( ) ) ; Assert . Null ( ( ( IProperty ) VAR0 ) . SqlServer ( ) . TryGetHiLoSequence ( ) ) ; VAR0 . SqlServer ( ) . HiLoSequenceName = LITERAL ; Assert . Null ( VAR0 . SqlServer ( ) . TryGetHiLoSequence ( ) ) ; Assert . Null ( ( ( IProperty ) VAR0 ) . SqlServer ( ) . TryGetHiLoSequence ( ) ) ; VAR1 . Model . SqlServer ( ) . IdentityStrategy = SqlServerIdentityStrategy . IdentityColumn ; Assert . Null ( VAR0 . SqlServer ( ) . TryGetHiLoSequence ( ) ) ; Assert . Null ( ( ( IProperty ) VAR0 ) . SqlServer ( ) . TryGetHiLoSequence ( ) ) ; VAR1 . Model . SqlServer ( ) . IdentityStrategy = null ; VAR0 . SqlServer ( ) . IdentityStrategy = SqlServerIdentityStrategy . IdentityColumn ; Assert . Null ( VAR0 . SqlServer ( ) . TryGetHiLoSequence ( ) ) ; Assert . Null ( ( ( IProperty ) VAR0 ) . SqlServer ( ) . TryGetHiLoSequence ( ) ) ;
VAR0 . SqlServer ( ) . HiLoSequenceName = LITERAL ; VAR0 . SqlServer ( ) . HiLoSequenceSchema = LITERAL ; Assert . Equal ( LITERAL , VAR0 . SqlServer ( ) . TryGetHiLoSequence ( ) . VAR1 ) ; Assert . Equal ( LITERAL , ( ( IProperty ) VAR0 ) . SqlServer ( ) . TryGetHiLoSequence ( ) . VAR1 ) ; Assert . Equal ( LITERAL , VAR0 . SqlServer ( ) . TryGetHiLoSequence ( ) . Schema ) ; Assert . Equal ( LITERAL , ( ( IProperty ) VAR0 ) . SqlServer ( ) . TryGetHiLoSequence ( ) . Schema ) ;
VAR0 . RequiresValueGenerator = true ; VAR1 . GetOrSetPrimaryKey ( VAR0 ) ; VAR1 . GetOrAddProperty ( LITERAL , typeof ( string ) ) . IsConcurrencyToken = true ; var VAR2 = VAR3 . AddEntityType ( typeof ( SomeDependentEntity ) ) ; var VAR4 = VAR2 . GetOrAddProperty ( LITERAL , typeof ( int ) ) ; var VAR5 = VAR2 . GetOrAddProperty ( LITERAL , typeof ( string ) ) ; VAR2 . GetOrSetPrimaryKey ( new [ ] { VAR4 , VAR5 } ) ; var VAR6 = VAR2 . GetOrAddProperty ( LITERAL , typeof ( int ) ) ; VAR2 . GetOrAddForeignKey ( new [ ] { VAR6 } , VAR1 . GetPrimaryKey ( ) ) ; var VAR7 = VAR2 . GetOrAddProperty ( LITERAL , typeof ( int ) ) ; VAR7 . RequiresValueGenerator = true ;
VAR0 . RequiresValueGenerator = true ; VAR1 . GetOrSetPrimaryKey ( VAR0 ) ; VAR1 . GetOrAddProperty ( LITERAL , typeof ( string ) , shadowProperty : true ) . IsConcurrencyToken = true ; var VAR2 = VAR3 . AddEntityType ( typeof ( SomeDependentEntity ) . FullName ) ; var VAR4 = VAR2 . GetOrAddProperty ( LITERAL , typeof ( int ) , shadowProperty : true ) ; var VAR5 = VAR2 . GetOrAddProperty ( LITERAL , typeof ( string ) , shadowProperty : true ) ; VAR2 . GetOrSetPrimaryKey ( new [ ] { VAR4 , VAR5 } ) ; var VAR6 = VAR2 . GetOrAddProperty ( LITERAL , typeof ( int ) , shadowProperty : true ) ; VAR2 . GetOrAddForeignKey ( new [ ] { VAR6 } , VAR1 . GetPrimaryKey ( ) ) ; var VAR7 = VAR2 . GetOrAddProperty ( LITERAL , typeof ( int ) , shadowProperty : true ) ; VAR7 . RequiresValueGenerator = true ;
VAR0 . ValueGenerated ( ValueGenerated . OnAdd , ConfigurationSource . Convention ) ; new DatabaseGeneratedAttributeConvention ( ) . Apply ( VAR0 ) ; Assert . Equal ( ValueGenerated . OnAddOrUpdate , VAR0 . Metadata . ValueGenerated ) ;
VAR0 . Property ( VAR1 => VAR1 . Up ) . ValueGeneratedOnAddOrUpdate ( ) ; VAR0 . Property ( VAR1 => VAR1 . Down ) . ValueGeneratedNever ( ) ; VAR0 . Property < int > ( LITERAL ) . ValueGeneratedOnAdd ( ) ; VAR0 . Property < string > ( LITERAL ) . ValueGeneratedNever ( ) ; VAR0 . Property < int > ( LITERAL ) . ValueGeneratedOnAddOrUpdate ( ) ; VAR0 . Property < string > ( LITERAL ) . ValueGeneratedNever ( ) ;
Assert . Null ( VAR0 . RequiresValueGenerator ) ; VAR0 . SqlServer ( ) . IdentityStrategy = null ; Assert . Null ( VAR0 . SqlServer ( ) . IdentityStrategy ) ; Assert . Null ( ( ( IProperty ) VAR0 ) . SqlServer ( ) . IdentityStrategy ) ; Assert . Null ( VAR0 . RequiresValueGenerator ) ;
Assert . Null ( VAR0 . RequiresValueGenerator ) ; Assert . False ( ( ( IProperty ) VAR0 ) . RequiresValueGenerator ) ; VAR0 . SqlServer ( ) . IdentityStrategy = SqlServerIdentityStrategy . SequenceHiLo ; Assert . Equal ( SqlServerIdentityStrategy . SequenceHiLo , VAR0 . SqlServer ( ) . IdentityStrategy ) ; Assert . Equal ( SqlServerIdentityStrategy . SequenceHiLo , ( ( IProperty ) VAR0 ) . SqlServer ( ) . IdentityStrategy ) ; Assert . Null ( VAR0 . RequiresValueGenerator ) ;
Assert . Null ( VAR0 . RequiresValueGenerator ) ; Assert . False ( ( ( IProperty ) VAR0 ) . RequiresValueGenerator ) ; VAR0 . SqlServer ( ) . IdentityStrategy = SqlServerIdentityStrategy . SequenceHiLo ; Assert . Equal ( SqlServerIdentityStrategy . SequenceHiLo , VAR0 . SqlServer ( ) . IdentityStrategy ) ; Assert . Equal ( SqlServerIdentityStrategy . SequenceHiLo , ( ( IProperty ) VAR0 ) . SqlServer ( ) . IdentityStrategy ) ; Assert . Null ( VAR0 . RequiresValueGenerator ) ; VAR0 . SqlServer ( ) . IdentityStrategy = null ; Assert . Null ( VAR0 . SqlServer ( ) . IdentityStrategy ) ; Assert . Null ( ( ( IProperty ) VAR0 ) . SqlServer ( ) . IdentityStrategy ) ; Assert . Null ( VAR0 . RequiresValueGenerator ) ;
Assert . Same ( VAR0 . Metadata , VAR1 . Metadata . DeclaringEntityType ) ; VAR1 = VAR1 . Invert ( ConfigurationSource . DataAnnotation ) ; Assert . Same ( VAR2 . Metadata , VAR1 . Metadata . DeclaringEntityType ) ; VAR1 = VAR1 . Invert ( ConfigurationSource . DataAnnotation ) ; Assert . Same ( VAR0 . Metadata , VAR1 . Metadata . DeclaringEntityType ) ; Assert . Null ( VAR1 . Invert ( ConfigurationSource . Convention ) ) ; Assert . Same ( VAR0 . Metadata , VAR1 . Metadata . DeclaringEntityType ) ; VAR1 = VAR1 . ForeignKey ( new [ ] { VAR3 . VAR4 } , ConfigurationSource . DataAnnotation ) ; Assert . Null ( VAR1 . Invert ( ConfigurationSource . DataAnnotation ) ) ; Assert . Same ( VAR0 . Metadata , VAR1 . Metadata . DeclaringEntityType ) ;
VAR0 . GetOrAddForeignKey ( VAR0 . GetOrAddProperty ( LITERAL , typeof ( int ) ) , VAR1 . GetPrimaryKey ( ) , VAR1 ) ; VAR1 . GetOrAddForeignKey ( VAR1 . GetOrAddProperty ( LITERAL , typeof ( int ) ) , VAR2 . GetPrimaryKey ( ) , VAR2 ) ; VAR2 . GetOrAddForeignKey ( VAR2 . GetOrAddProperty ( LITERAL , typeof ( int ) ) , VAR0 . GetPrimaryKey ( ) , VAR0 ) ; VAR0 . GetOrAddForeignKey ( VAR0 . GetOrAddProperty ( LITERAL , typeof ( int ) ) , VAR3 . GetPrimaryKey ( ) , VAR3 ) ; VAR3 . GetOrAddForeignKey ( VAR3 . GetOrAddProperty ( LITERAL , typeof ( int ) ) , VAR4 . GetPrimaryKey ( ) , VAR4 ) ; VAR4 . GetOrAddForeignKey ( VAR4 . GetOrAddProperty ( LITERAL , typeof ( int ) ) , VAR0 . GetPrimaryKey ( ) , VAR0 ) ;
Assert . Null ( VAR0 . SqlServer ( ) . IdentityStrategy ) ; Assert . Null ( ( ( IProperty ) VAR0 ) . SqlServer ( ) . IdentityStrategy ) ; Assert . Null ( VAR0 . IsValueGeneratedOnAdd ) ; Assert . False ( ( ( IProperty ) VAR0 ) . IsValueGeneratedOnAdd ) ; VAR0 . SqlServer ( ) . IdentityStrategy = SqlServerIdentityStrategy . SequenceHiLo ; Assert . Equal ( SqlServerIdentityStrategy . SequenceHiLo , VAR0 . SqlServer ( ) . IdentityStrategy ) ; Assert . Equal ( SqlServerIdentityStrategy . SequenceHiLo , ( ( IProperty ) VAR0 ) . SqlServer ( ) . IdentityStrategy ) ; Assert . Null ( VAR0 . IsValueGeneratedOnAdd ) ; VAR0 . SqlServer ( ) . IdentityStrategy = null ; Assert . Null ( VAR0 . SqlServer ( ) . IdentityStrategy ) ; Assert . Null ( ( ( IProperty ) VAR0 ) . SqlServer ( ) . IdentityStrategy ) ;
Assert . Null ( VAR0 . SqlServer ( ) . IdentityStrategy ) ; Assert . Null ( ( ( IProperty ) VAR0 ) . SqlServer ( ) . IdentityStrategy ) ; Assert . Null ( VAR0 . IsValueGeneratedOnAdd ) ; Assert . False ( ( ( IProperty ) VAR0 ) . IsValueGeneratedOnAdd ) ; VAR0 . SqlServer ( ) . IdentityStrategy = SqlServerIdentityStrategy . SequenceHiLo ; Assert . Equal ( SqlServerIdentityStrategy . SequenceHiLo , VAR0 . SqlServer ( ) . IdentityStrategy ) ; Assert . Equal ( SqlServerIdentityStrategy . SequenceHiLo , ( ( IProperty ) VAR0 ) . SqlServer ( ) . IdentityStrategy ) ; Assert . Null ( VAR0 . IsValueGeneratedOnAdd ) ; VAR0 . SqlServer ( ) . IdentityStrategy = null ; Assert . Null ( VAR0 . SqlServer ( ) . IdentityStrategy ) ; Assert . Null ( ( ( IProperty ) VAR0 ) . SqlServer ( ) . IdentityStrategy ) ;
VerifyScoped < IDatabaseProviderSelector > ( ) ; VerifyScoped < ValueGeneratorSelector > ( ) ; VerifyScoped < IModel > ( ) ; VerifyScoped < DbContext > ( ) ; VerifyScoped < IDbContextOptions > ( ) ; VerifyScoped < IDatabaseProviderServices > ( ) ; VerifyScoped < IDatabase > ( ) ; VerifyScoped < IQueryContextFactory > ( ) ; VerifyScoped < IDatabaseConnection > ( ) ; VerifyScoped < IValueGeneratorSelector > ( ) ; VerifyScoped < IDatabaseCreator > ( ) ;
Assert . Null ( VAR0 . Database . GetCommandTimeout ( ) ) ; VAR0 . Database . SetCommandTimeout ( LITERAL ) ; Assert . Equal ( LITERAL , VAR0 . Database . GetCommandTimeout ( ) ) ; VAR0 . Database . SetCommandTimeout ( null ) ; Assert . Null ( VAR0 . Database . GetCommandTimeout ( ) ) ;
VAR0 . ToTable ( LITERAL , LITERAL ) ; VAR0 . Property < int > ( LITERAL ) ; VAR0 . Key ( LITERAL ) ; VAR0 . Property < int > ( LITERAL ) ; VAR0 . Property < int > ( LITERAL ) ; VAR0 . AlternateKey ( LITERAL ) . KeyName ( LITERAL ) ;
VAR0 . ToTable ( LITERAL , LITERAL ) ; VAR0 . Property < int > ( LITERAL ) ; VAR0 . Key ( LITERAL ) ; VAR0 . Property < int > ( LITERAL ) ; VAR0 . Index ( LITERAL ) . IndexName ( LITERAL ) ;
VAR0 . ToTable ( LITERAL , LITERAL ) ; VAR0 . Property < int > ( LITERAL ) ; VAR0 . Key ( LITERAL ) ; VAR0 . Property < int > ( LITERAL ) ; VAR0 . Property < int > ( LITERAL ) ; VAR0 . Index ( LITERAL ) . IndexName ( LITERAL ) ;
VAR0 . ToTable ( LITERAL , LITERAL ) ; VAR0 . Property < int > ( LITERAL ) ; VAR0 . Key ( LITERAL ) ; VAR0 . Property < int > ( LITERAL ) ; VAR0 . AlternateKey ( LITERAL ) . ForSqlServer ( ) . KeyName ( LITERAL ) ;
VAR0 . ToTable ( LITERAL , LITERAL ) ; VAR0 . Property < int > ( LITERAL ) ; VAR0 . Key ( LITERAL ) ; VAR0 . Property < int > ( LITERAL ) ; VAR0 . Reference ( LITERAL ) . InverseCollection ( ) . ForeignKey ( LITERAL ) . ForSqlServer ( ) . ConstraintName ( LITERAL ) ;
VAR0 . Property ( VAR1 => VAR1 . VAR2 ) . Metadata . IsValueGeneratedOnAdd = false ; VAR0 . Property ( VAR1 => VAR1 . VAR3 ) . Metadata . IsValueGeneratedOnAdd = true ; VAR0 . Property ( VAR1 => VAR1 . VAR4 ) . Metadata . IsValueGeneratedOnAdd = true ; VAR0 . Property < int > ( LITERAL ) . Metadata . IsValueGeneratedOnAdd = true ; VAR0 . Property < string > ( LITERAL ) . Metadata . IsValueGeneratedOnAdd = false ; VAR0 . Property ( typeof ( int ) , LITERAL ) . Metadata . IsValueGeneratedOnAdd = true ; VAR0 . Property ( typeof ( string ) , LITERAL ) . Metadata . IsValueGeneratedOnAdd = false ;
var VAR0 = new InMemoryDataStoreCreator ( CreateStore ( VAR1 , VAR2 : true ) , VAR3 ) ; Assert . True ( VAR0 . EnsureCreated ( ) ) ; Assert . False ( VAR0 . EnsureCreated ( ) ) ; Assert . False ( VAR0 . EnsureCreated ( ) ) ; VAR0 = new InMemoryDataStoreCreator ( CreateStore ( VAR1 , VAR2 : true ) , VAR3 ) ; Assert . False ( VAR0 . EnsureCreated ( ) ) ;
VAR0 . Verify ( VAR1 => VAR1 . CreateTables ( ) , Times . Once ) ; Assert . True ( VAR3 . HasTables ( ) ) ; VAR0 . Verify ( VAR1 => VAR1 . HasTables ( ) , Times . Once ) ; VAR3 . Delete ( ) ; VAR0 . Verify ( VAR1 => VAR1 . Delete ( ) , Times . Once ) ; Assert . True ( VAR3 . EnsureCreated ( ) ) ; VAR0 . Verify ( VAR1 => VAR1 . EnsureCreated ( ) , Times . Once ) ; Assert . True ( VAR3 . EnsureDeleted ( ) ) ; VAR0 . Verify ( VAR1 => VAR1 . EnsureDeleted ( ) , Times . Once ) ;
var VAR0 = new SqlServerTypeMapper ( ) . MapPropertyType ( VAR1 ) ; Assert . Null ( VAR0 . StoreType ) ; Assert . Equal ( LITERAL , VAR0 . DefaultTypeName ) ; Assert . Equal ( LITERAL , VAR0 . CreateParameter ( new TestCommand ( ) , LITERAL , LITERAL ) . Size ) ;
var VAR0 = new SqlServerTypeMapper ( ) . MapPropertyType ( VAR1 ) ; Assert . Equal ( DbType . Binary , VAR0 . StoreType ) ; Assert . Equal ( LITERAL , VAR0 . DefaultTypeName ) ; Assert . Equal ( LITERAL , VAR0 . CreateParameter ( new TestCommand ( ) , LITERAL , new byte [ LITERAL ] ) . Size ) ;
VerifySingleton < SqlServerModelSource > ( ) ; VerifySingleton < SqlServerMetadataExtensionProvider > ( ) ; VerifyScoped < SqlServerValueGeneratorSelector > ( ) ; VerifyScoped < SqlServerDataStoreServices > ( ) ;
var VAR0 = ( IForeignKey ) VAR1 . Metadata . GetForeignKeys ( ) . Single ( ) ; Assert . Same ( VAR0 , VAR2 . Metadata ) ; Assert . Same ( VAR3 . Metadata , VAR0 . Properties [ 0 ] ) ; Assert . Same ( VAR4 . Metadata , VAR0 . Properties [ 1 ] ) ; Assert . Same ( VAR5 [ 0 ] , VAR0 . PrincipalKey . Properties [ 0 ] ) ; Assert . Same ( VAR5 [ 1 ] , VAR0 . PrincipalKey . Properties [ 1 ] ) ; Assert . False ( VAR0 . IsUnique ) ;
var VAR0 = ( IForeignKey ) VAR1 . Metadata . GetForeignKeys ( ) . Single ( ) ; Assert . Same ( VAR0 , VAR2 . Metadata ) ; Assert . Same ( VAR3 . Metadata . GetPrimaryKey ( ) , VAR0 . PrincipalKey ) ; Assert . True ( VAR0 . IsUnique ) ; Assert . True ( VAR0 . IsRequired ) ; Assert . Empty ( VAR3 . Metadata . GetForeignKeys ( ) ) ;
var VAR0 = new ModificationCommand ( LITERAL , null , new ParameterNameGenerator ( ) , VAR1 => VAR1 . Relational ( ) , new NonTypedValueBufferFactoryFactory ( ) ) ; VAR0 . AddEntry ( VAR2 ) ; var VAR3 = VAR4 . GetOrCreateEntry ( new object ( ) ) ; VAR3 [ VAR5 ] = LITERAL ; VAR3 . SetEntityState ( EntityState . Modified ) ; var VAR6 = new ModificationCommand ( LITERAL , null , new ParameterNameGenerator ( ) , VAR1 => VAR1 . Relational ( ) , new NonTypedValueBufferFactoryFactory ( ) ) ; VAR6 . AddEntry ( VAR3 ) ; var VAR7 = VAR4 . GetOrCreateEntry ( new object ( ) ) ; VAR7 [ VAR5 ] = LITERAL ; VAR7 . SetEntityState ( EntityState . Deleted ) ; var VAR8 = new ModificationCommand ( LITERAL , null , new ParameterNameGenerator ( ) , VAR1 => VAR1 . Relational ( ) , new NonTypedValueBufferFactoryFactory ( ) ) ;
Assert . Equal ( VAR0 . VAR1 . VAR2 , VAR3 . Metadata . PrincipalToDependent . VAR2 ) ; Assert . Equal ( Order . VAR4 . VAR2 , VAR3 . Metadata . DependentToPrincipal . VAR2 ) ; Assert . Null ( VAR5 . Metadata . PrincipalToDependent ) ; Assert . Null ( VAR5 . Metadata . DependentToPrincipal ) ;
VerifySingleton < ISqlServerSequenceValueGeneratorFactory > ( ) ; VerifySingleton < ISqlServerSqlGenerator > ( ) ; VerifySingleton < ISqlStatementExecutor > ( ) ; VerifySingleton < ISqlServerTypeMapper > ( ) ; VerifySingleton < ISqlServerModificationCommandBatchFactory > ( ) ; VerifySingleton < ISqlServerCommandBatchPreparer > ( ) ;
VAR0 . Property ( VAR1 => VAR1 . VAR2 ) . StoreGeneratedPattern ( StoreGeneratedPattern . Computed ) ; VAR0 . Property ( VAR1 => VAR1 . VAR3 ) . StoreGeneratedPattern ( StoreGeneratedPattern . None ) ; VAR0 . Property < int > ( LITERAL ) . StoreGeneratedPattern ( StoreGeneratedPattern . Identity ) ; VAR0 . Property < string > ( LITERAL ) . StoreGeneratedPattern ( StoreGeneratedPattern . None ) ; VAR0 . Property ( typeof ( int ) , LITERAL ) . StoreGeneratedPattern ( StoreGeneratedPattern . Computed ) ; VAR0 . Property ( typeof ( string ) , LITERAL ) . StoreGeneratedPattern ( StoreGeneratedPattern . None ) ;
var VAR4 = ModelBuilder . Entity ( VAR1 . PrincipalEntityType . Name , ConfigurationSource . Convention ) ; var VAR2 = VAR1 . GetNavigationToDependent ( ) ; VAR2 ? . EntityType . RemoveNavigation ( VAR2 ) ; var VAR3 = VAR1 . GetNavigationToPrincipal ( ) ; VAR3 ? . EntityType . RemoveNavigation ( VAR3 ) ; Metadata . RemoveForeignKey ( VAR1 ) ; ModelBuilder . ConventionDispatcher . OnForeignKeyRemoved ( this , VAR1 ) ; RemoveShadowPropertiesIfUnused ( VAR1 . Properties ) ; VAR4 . RemoveKeyIfUnused ( VAR1 . PrincipalKey ) ;
Assert . Same ( typeof ( int ) , VAR0 . ClrType ) ; Assert . False ( VAR0 . IsConcurrencyToken ) ; Assert . Same ( VAR1 , VAR0 . EntityType ) ; Assert . Same ( VAR0 , VAR1 . GetOrAddProperty ( VAR2 . VAR3 ) ) ; Assert . Same ( VAR0 , VAR1 . GetOrAddProperty ( LITERAL , typeof ( int ) , shadowProperty : true ) ) ; Assert . False ( VAR0 . IsShadowProperty ) ; var VAR4 = ( IProperty ) VAR1 . GetOrAddProperty ( LITERAL , typeof ( string ) , shadowProperty : true ) ; Assert . True ( VAR4 . IsShadowProperty ) ; Assert . Equal ( LITERAL , VAR4 . VAR5 ) ; Assert . Same ( typeof ( string ) , VAR4 . ClrType ) ;
Assert . Null ( VAR0 . FindPrimaryKey ( ) ) ; Assert . Equal ( LITERAL , VAR0 . Keys . Count ) ; Assert . Null ( VAR0 . SetPrimaryKey ( new Property [ 0 ] ) ) ; Assert . Null ( VAR0 . FindPrimaryKey ( ) ) ;
Assert . NotNull ( VAR0 . Metadata . FindNavigation ( Order . VAR1 . VAR2 ) ) ; Assert . NotNull ( VAR3 . Metadata . FindNavigation ( VAR4 . VAR5 . VAR2 ) ) ; Assert . True ( VAR0 . Navigation ( null , VAR6 , pointsToPrincipal : true , configurationSource : ConfigurationSource . Explicit ) ) ; Assert . True ( VAR3 . Navigation ( null , VAR6 , pointsToPrincipal : false , configurationSource : ConfigurationSource . Explicit ) ) ; Assert . Null ( VAR0 . Metadata . FindNavigation ( Order . VAR1 . VAR2 ) ) ; Assert . Null ( VAR3 . Metadata . FindNavigation ( VAR4 . VAR5 . VAR2 ) ) ;
Assert . NotNull ( VAR0 . FindEntityType ( typeof ( Customer ) ) ) ; Assert . Same ( VAR0 , VAR1 . Model ) ; Assert . Same ( VAR1 , VAR0 . GetOrAddEntityType ( typeof ( Customer ) ) ) ; Assert . Equal ( new [ ] { VAR1 } , VAR0 . EntityTypes . ToArray ( ) ) ; Assert . Same ( VAR1 , VAR0 . RemoveEntityType ( VAR1 ) ) ; Assert . Null ( VAR0 . RemoveEntityType ( VAR1 ) ) ; Assert . Null ( VAR0 . FindEntityType ( typeof ( Customer ) ) ) ;
Assert . Equal ( 1 , VAR0 . GetProperties ( ) . Count ( ) ) ; Assert . Equal ( 1 , VAR0 . GetKeys ( ) . Count ( ) ) ; Assert . Empty ( VAR0 . GetForeignKeys ( ) ) ; Assert . Equal ( VAR1 . VAR2 . Name , VAR0 . GetNavigations ( ) . Single ( ) . Name ) ; Assert . Equal ( LITERAL , VAR3 . GetProperties ( ) . Count ( ) ) ;
var VAR0 = new ModificationCommand ( LITERAL , null , new ParameterNameGenerator ( ) , VAR1 => VAR1 . Relational ( ) , new BoxedValueReaderSource ( ) ) ; VAR0 . AddEntry ( VAR2 ) ; var VAR3 = VAR4 . GetOrCreateEntry ( new object ( ) ) ; VAR3 [ VAR5 ] = LITERAL ; VAR3 . SetEntityState ( EntityState . Modified ) ; var VAR6 = new ModificationCommand ( LITERAL , null , new ParameterNameGenerator ( ) , VAR1 => VAR1 . Relational ( ) , new BoxedValueReaderSource ( ) ) ;
VAR0 = VAR1 . GetRequiredService < IDataStore > ( ) ; VAR2 = VAR1 . GetRequiredService < IDataStoreCreator > ( ) ; VAR3 = VAR1 . GetRequiredService < IDataStoreConnection > ( ) ; Assert . Same ( VAR0 , VAR1 . GetRequiredService < IDataStore > ( ) ) ; Assert . Same ( VAR2 , VAR1 . GetRequiredService < IDataStoreCreator > ( ) ) ; Assert . Same ( VAR3 , VAR1 . GetRequiredService < IDataStoreConnection > ( ) ) ;
Check . NotNull ( VAR0 , nameof ( VAR0 ) ) ; Check . NotNull ( VAR1 , nameof ( VAR1 ) ) ; var VAR2 = ModelBuilder . Entity ( VAR0 . Name , VAR3 ) ; Debug . Assert ( VAR2 != null ) ; var VAR4 = ModelBuilder . Entity ( VAR1 . Name , VAR3 ) ; Debug . Assert ( VAR4 != null ) ;
Check . NotNull ( VAR0 , nameof ( VAR0 ) ) ; Check . NotNull ( VAR1 , nameof ( VAR1 ) ) ; Check . NotNull ( VAR2 , nameof ( VAR2 ) ) ; Check . NotNull ( VAR3 , nameof ( VAR3 ) ) ; Check . NotNull ( VAR4 , nameof ( VAR4 ) ) ; Check . NotNull ( VAR5 , nameof ( VAR5 ) ) ;
Assert . Equal ( 1 , VAR0 . Next ( ) ) ; Assert . Equal ( LITERAL , VAR0 . Next ( ) ) ; Assert . Equal ( LITERAL , VAR0 . Next ( ) ) ; Assert . Equal ( LITERAL , VAR0 . Next ( ) ) ; Assert . Equal ( LITERAL , VAR0 . Next ( ) ) ; Assert . Equal ( LITERAL , VAR0 . Next ( ) ) ; VAR0 = new InMemoryIntegerValueGenerator < int > ( ) ; Assert . Equal ( 1 , VAR0 . Next ( ) ) ; Assert . Equal ( LITERAL , VAR0 . Next ( ) ) ;
GenerateUsings ( VAR0 ) ; VAR3 . CSharpCodeGeneratorHelper . BeginNamespace ( VAR1 , VAR0 ) ; VAR3 . CSharpCodeGeneratorHelper . BeginClass ( AccessModifier . Public , VAR2 , isPartial : true , VAR0 : VAR0 , inheritsFrom : new string [  ] { LITERAL } ) ; GenerateProperties ( VAR0 ) ; GenerateMethods ( VAR0 ) ; VAR3 . CSharpCodeGeneratorHelper . EndClass ( VAR0 ) ; VAR3 . CSharpCodeGeneratorHelper . EndNamespace ( VAR0 ) ;
var VAR0 = new Mock < ValueGeneratorSelectorContract > ( ) ; VAR0 . Setup ( VAR1 => VAR1 . Select ( It . IsAny < IProperty > ( ) ) ) . Returns ( Mock . Of < ValueGenerator > ( ) ) ; var VAR2 = new Mock < DataStoreServices > ( ) ; VAR2 . Setup ( VAR1 => VAR1 . Store ) . Returns ( VAR3 . Object ) ; VAR2 . Setup ( VAR1 => VAR1 . ValueGeneratorSelector ) . Returns ( VAR0 . Object ) ;
VerifySingleton < TemporaryIntegerValueGeneratorFactory > ( ) ; VerifySingleton < SimpleValueGeneratorFactory < TemporaryStringValueGenerator > > ( ) ; VerifySingleton < SimpleValueGeneratorFactory < TemporaryBinaryValueGenerator > > ( ) ; VerifySingleton < SimpleValueGeneratorFactory < GuidValueGenerator > > ( ) ; VerifySingleton < SimpleValueGeneratorFactory < SequentialGuidValueGenerator > > ( ) ;
TrackEntity ( VAR0 , VAR1 : false ) ; Assert . Equal ( EntityState . Added , VAR0 . State ) ; Assert . Equal ( 1 , VAR0 . Entity . VAR2 ) ; VAR0 = VAR3 . Entry ( new Stoat { VAR2 = LITERAL } ) ; TrackEntity ( VAR0 , VAR1 : false ) ;
TrackEntity ( VAR0 , VAR1 : false ) ; Assert . Equal ( EntityState . Unchanged , VAR0 . State ) ; Assert . Equal ( VAR2 , VAR0 . Entity . VAR3 ) ; Assert . Equal ( LITERAL , VAR0 . Entity . VAR4 ) ; VAR0 = VAR5 . Entry ( new CompositeStoat { VAR3 = VAR2 , VAR4 = LITERAL } ) ; TrackEntity ( VAR0 , VAR1 : true ) ;
var VAR0 = VAR1 . PropertyCount ; var VAR2 = VAR3 . PropertyCount ; var VAR4 = VAR1 . Keys . Single ( ) ; var VAR5 = VAR3 . Keys . Single ( ) ; VAR6 . Entity ( typeof ( VAR7 ) ) . HasMany ( typeof ( VAR8 ) , null ) . WithOne ( null ) ; var VAR9 = VAR3 . ForeignKeys . Single ( ) ; Assert . Same ( VAR10 , VAR9 . Properties . Single ( ) ) ; Assert . Empty ( VAR3 . Navigations ) ; Assert . Empty ( VAR1 . Navigations ) ; Assert . Equal ( VAR0 , VAR1 . PropertyCount ) ; Assert . Equal ( VAR2 , VAR3 . PropertyCount ) ;
var VAR0 = VAR1 . PropertyCount ; var VAR2 = VAR3 . PropertyCount ; var VAR4 = VAR1 . Keys . Single ( ) ; var VAR5 = VAR3 . Keys . Single ( ) ; VAR6 . Entity ( typeof ( VAR7 ) ) . HasOne ( typeof ( VAR8 ) , LITERAL ) . WithMany ( LITERAL ) ; Assert . Same ( VAR9 , VAR3 . ForeignKeys . Single ( ) ) ; Assert . Equal ( LITERAL , VAR3 . Navigations . Single ( ) . VAR10 ) ; Assert . Equal ( LITERAL , VAR1 . Navigations . Single ( ) . VAR10 ) ; Assert . Same ( VAR9 , VAR3 . Navigations . Single ( ) . ForeignKey ) ; Assert . Same ( VAR9 , VAR1 . Navigations . Single ( ) . ForeignKey ) ; Assert . Equal ( VAR0 , VAR1 . PropertyCount ) ; Assert . Equal ( VAR2 , VAR3 . PropertyCount ) ;
var VAR0 = VAR1 . PropertyCount ; var VAR2 = VAR3 . PropertyCount ; var VAR4 = VAR1 . Keys . Single ( ) ; var VAR5 = VAR3 . Keys . Single ( ) ; VAR6 . Entity ( typeof ( VAR7 ) ) . HasOne ( typeof ( CustomerDetails ) , LITERAL ) . WithOne ( null ) ; var VAR8 = VAR3 . ForeignKeys . Single ( ) ; Assert . Same ( VAR9 , VAR8 . Properties . Single ( ) ) ; Assert . Empty ( VAR3 . Navigations ) ; Assert . Equal ( LITERAL , VAR1 . Navigations . Single ( ) . VAR10 ) ; Assert . Same ( VAR8 , VAR1 . Navigations . Single ( ) . ForeignKey ) ; Assert . Equal ( VAR0 , VAR1 . PropertyCount ) ; Assert . Equal ( VAR2 , VAR3 . PropertyCount ) ;
var VAR0 = VAR1 . PropertyCount ; var VAR2 = VAR3 . PropertyCount ; var VAR4 = VAR1 . Keys . Single ( ) ; var VAR5 = VAR3 . Keys . Single ( ) ; VAR6 . Entity ( typeof ( VAR7 ) ) . HasOne ( typeof ( CustomerDetails ) , null ) . WithOne ( LITERAL ) ; var VAR8 = VAR3 . ForeignKeys . Single ( ) ; Assert . Same ( VAR9 , VAR8 . Properties . Single ( ) ) ; Assert . Equal ( LITERAL , VAR3 . Navigations . Single ( ) . VAR10 ) ; Assert . Empty ( VAR1 . Navigations ) ; Assert . Same ( VAR8 , VAR3 . Navigations . Single ( ) . ForeignKey ) ; Assert . Equal ( VAR0 , VAR1 . PropertyCount ) ; Assert . Equal ( VAR2 , VAR3 . PropertyCount ) ;
var VAR0 = VAR1 . PropertyCount ; var VAR2 = VAR3 . PropertyCount ; var VAR4 = VAR1 . Keys . Single ( ) ; var VAR5 = VAR3 . Keys . Single ( ) ; VAR6 . Entity ( typeof ( VAR7 ) . FullName ) . HasMany ( typeof ( VAR8 ) . FullName , LITERAL ) . WithOne ( LITERAL ) ; Assert . Same ( VAR9 , VAR3 . ForeignKeys . Single ( ) ) ; Assert . Same ( VAR10 , VAR3 . Navigations . Single ( ) ) ; Assert . Same ( VAR11 , VAR1 . Navigations . Single ( ) ) ; Assert . Same ( VAR9 , VAR3 . Navigations . Single ( ) . ForeignKey ) ; Assert . Same ( VAR9 , VAR1 . Navigations . Single ( ) . ForeignKey ) ; Assert . Equal ( VAR0 , VAR1 . PropertyCount ) ; Assert . Equal ( VAR2 , VAR3 . PropertyCount ) ;
var VAR0 = VAR1 . PropertyCount ; var VAR2 = VAR3 . PropertyCount ; var VAR4 = VAR1 . Keys . Single ( ) ; var VAR5 = VAR3 . Keys . Single ( ) ; VAR6 . Entity ( typeof ( VAR7 ) . FullName ) . HasMany ( typeof ( VAR8 ) . FullName , null ) . WithOne ( LITERAL ) ; var VAR9 = VAR3 . ForeignKeys . Single ( ) ; Assert . Same ( VAR10 , VAR9 . Properties . Single ( ) ) ; Assert . Equal ( LITERAL , VAR3 . Navigations . Single ( ) . VAR11 ) ; Assert . Empty ( VAR1 . Navigations ) ; Assert . Same ( VAR9 , VAR3 . Navigations . Single ( ) . ForeignKey ) ; Assert . Equal ( VAR0 , VAR1 . PropertyCount ) ; Assert . Equal ( VAR2 , VAR3 . PropertyCount ) ;
var VAR0 = VAR1 . PropertyCount ; var VAR2 = VAR3 . PropertyCount ; var VAR4 = VAR1 . Keys . Single ( ) ; var VAR5 = VAR3 . Keys . Single ( ) ; VAR6 . Entity ( typeof ( VAR7 ) . FullName ) . HasOne ( typeof ( VAR8 ) . FullName , LITERAL ) . WithMany ( LITERAL ) ; Assert . Same ( VAR9 , VAR3 . ForeignKeys . Single ( ) ) ; Assert . Same ( VAR10 , VAR3 . Navigations . Single ( ) ) ; Assert . Equal ( LITERAL , VAR1 . Navigations . Single ( ) . VAR11 ) ; Assert . Same ( VAR9 , VAR3 . Navigations . Single ( ) . ForeignKey ) ; Assert . Same ( VAR9 , VAR1 . Navigations . Single ( ) . ForeignKey ) ; Assert . Equal ( VAR0 , VAR1 . PropertyCount ) ; Assert . Equal ( VAR2 , VAR3 . PropertyCount ) ;
var VAR0 = VAR1 . PropertyCount ; var VAR2 = VAR3 . PropertyCount ; var VAR4 = VAR1 . Keys . Single ( ) ; var VAR5 = VAR3 . Keys . Single ( ) ; VAR6 . Entity ( typeof ( VAR7 ) . FullName ) . HasOne ( typeof ( VAR8 ) . FullName , LITERAL ) . WithMany ( LITERAL ) ; Assert . Same ( VAR9 , VAR3 . ForeignKeys . Single ( ) ) ; Assert . Equal ( LITERAL , VAR3 . Navigations . Single ( ) . VAR10 ) ; Assert . Same ( VAR11 , VAR1 . Navigations . Single ( ) ) ; Assert . Same ( VAR9 , VAR3 . Navigations . Single ( ) . ForeignKey ) ; Assert . Same ( VAR9 , VAR1 . Navigations . Single ( ) . ForeignKey ) ; Assert . Equal ( VAR0 , VAR1 . PropertyCount ) ; Assert . Equal ( VAR2 , VAR3 . PropertyCount ) ;
var VAR0 = VAR1 . PropertyCount ; var VAR2 = VAR3 . PropertyCount ; var VAR4 = VAR1 . Keys . Single ( ) ; var VAR5 = VAR3 . Keys . Single ( ) ; VAR6 . Entity ( typeof ( VAR7 ) . FullName ) . HasOne ( typeof ( VAR8 ) . FullName , LITERAL ) . WithMany ( LITERAL ) ; Assert . Same ( VAR9 , VAR3 . ForeignKeys . Single ( ) ) ; Assert . Equal ( LITERAL , VAR3 . Navigations . Single ( ) . VAR10 ) ; Assert . Equal ( LITERAL , VAR1 . Navigations . Single ( ) . VAR10 ) ; Assert . Same ( VAR9 , VAR3 . Navigations . Single ( ) . ForeignKey ) ; Assert . Same ( VAR9 , VAR1 . Navigations . Single ( ) . ForeignKey ) ; Assert . Equal ( VAR0 , VAR1 . PropertyCount ) ; Assert . Equal ( VAR2 , VAR3 . PropertyCount ) ;
Assert . Same ( VAR0 , VAR1 . Properties . Single ( ) ) ; Assert . Same ( VAR2 , VAR1 . ReferencedProperties . Single ( ) ) ; Assert . Equal ( LITERAL , VAR3 . Navigations . Single ( ) . VAR4 ) ; Assert . Equal ( LITERAL , VAR5 . Navigations . Single ( ) . VAR4 ) ; Assert . Same ( VAR1 , VAR3 . Navigations . Single ( ) . ForeignKey ) ; Assert . Same ( VAR1 , VAR5 . Navigations . Single ( ) . ForeignKey ) ; Assert . Equal ( VAR6 , VAR5 . PropertyCount ) ; Assert . Equal ( VAR7 , VAR3 . PropertyCount ) ;
var VAR0 = VAR1 . PropertyCount ; var VAR2 = VAR3 . PropertyCount ; var VAR4 = VAR1 . Keys . Single ( ) ; var VAR5 = VAR3 . Keys . Single ( ) ; VAR6 . Entity ( typeof ( VAR7 ) . FullName ) . HasOne ( typeof ( CustomerDetails ) . FullName , LITERAL ) . WithOne ( LITERAL ) ; var VAR8 = VAR3 . ForeignKeys . Single ( ) ; Assert . Same ( VAR9 , VAR8 . Properties . Single ( ) ) ; Assert . Equal ( LITERAL , VAR3 . Navigations . Single ( ) . VAR10 ) ; Assert . Equal ( LITERAL , VAR1 . Navigations . Single ( ) . VAR10 ) ; Assert . Same ( VAR8 , VAR3 . Navigations . Single ( ) . ForeignKey ) ; Assert . Same ( VAR8 , VAR1 . Navigations . Single ( ) . ForeignKey ) ; Assert . Equal ( VAR0 , VAR1 . PropertyCount ) ; Assert . Equal ( VAR2 , VAR3 . PropertyCount ) ;
var VAR0 = VAR1 . PropertyCount ; var VAR2 = VAR3 . PropertyCount ; var VAR4 = VAR1 . Keys . Single ( ) ; var VAR5 = VAR3 . Keys . Single ( ) ; VAR6 . Entity ( typeof ( VAR7 ) . FullName ) . HasOne ( typeof ( OrderDetails ) . FullName , LITERAL ) . WithOne ( LITERAL ) ; var VAR8 = VAR3 . ForeignKeys . Single ( ) ; Assert . Same ( VAR9 , VAR8 . Properties . Single ( ) ) ; Assert . Equal ( LITERAL , VAR3 . Navigations . Single ( ) . VAR10 ) ; Assert . Equal ( LITERAL , VAR1 . Navigations . Single ( ) . VAR10 ) ; Assert . Same ( VAR8 , VAR3 . Navigations . Single ( ) . ForeignKey ) ; Assert . Same ( VAR8 , VAR1 . Navigations . Single ( ) . ForeignKey ) ; Assert . Equal ( VAR0 , VAR1 . PropertyCount ) ; Assert . Equal ( VAR2 , VAR3 . PropertyCount ) ;
VAR0 . Protected ( ) . Verify ( LITERAL , Times . Never ( ) , true ) ; Assert . Equal ( 0 , VAR1 . VAR2 ) ; Assert . Same ( VAR0 . Object , VAR1 . DbConnection ) ; VAR1 . Open ( ) ; VAR1 . Close ( ) ; VAR1 . Dispose ( ) ; VAR0 . Verify ( VAR3 => VAR3 . Open ( ) , Times . Exactly ( LITERAL ) ) ; VAR0 . Verify ( VAR3 => VAR3 . Close ( ) , Times . Exactly ( LITERAL ) ) ; VAR0 . Protected ( ) . Verify ( LITERAL , Times . Never ( ) , true ) ;
VAR0 . UpdateRange ( VAR1 ) ; VAR0 . UpdateRange ( VAR1 ) ; VAR0 . UpdateRange ( new List < Product > { VAR1 } ) ; VAR0 . UpdateRange ( new List < object > { VAR1 } ) ; VAR0 . Remove ( VAR1 ) ; VAR0 . Remove ( ( object ) VAR1 ) ; VAR0 . RemoveRange ( VAR1 ) ; VAR0 . RemoveRange ( VAR1 ) ;
Assert . Same ( VAR3 , VAR1 . Entry ) ; Assert . Equal ( LITERAL , VAR1 . Property . Name ) ; Assert . False ( VAR1 . IsCondition ) ; Assert . True ( VAR1 . IsKey ) ; Assert . False ( VAR1 . IsRead ) ; Assert . True ( VAR1 . IsWrite ) ; VAR1 = VAR2 . ColumnModifications [ 1 ] ; Assert . Equal ( LITERAL , VAR1 . ColumnName ) ; Assert . Same ( VAR3 , VAR1 . Entry ) ;
var VAR4 = Createentry ( EntityState . Added , VAR1 : true ) ; VAR4 . MarkAsTemporary ( VAR4 . EntityType . GetPrimaryKey ( ) . Properties [ 0 ] ) ; var VAR2 = new ModificationCommand ( new SchemaQualifiedName ( LITERAL ) , new ParameterNameGenerator ( ) , VAR3 => VAR3 . Relational ( ) ) ; VAR2 . AddEntry ( VAR4 ) ;
var VAR4 = Createentry ( EntityState . Added , VAR1 : true ) ; VAR4 . MarkAsTemporary ( VAR4 . EntityType . GetPrimaryKey ( ) . Properties [ 0 ] ) ; var VAR2 = new ModificationCommand ( new SchemaQualifiedName ( LITERAL ) , new ParameterNameGenerator ( ) , VAR3 => VAR3 . Relational ( ) ) ; VAR2 . AddEntry ( VAR4 ) ;
ChangeStateWithMethod ( ( VAR0 , VAR1 ) => VAR0 . Remove ( VAR1 ) , EntityState . Detached , EntityState . Deleted ) ; ChangeStateWithMethod ( ( VAR0 , VAR1 ) => VAR0 . Remove ( VAR1 ) , EntityState . Unchanged , EntityState . Deleted ) ; ChangeStateWithMethod ( ( VAR0 , VAR1 ) => VAR0 . Remove ( VAR1 ) , EntityState . Deleted , EntityState . Deleted ) ; ChangeStateWithMethod ( ( VAR0 , VAR1 ) => VAR0 . Remove ( VAR1 ) , EntityState . Modified , EntityState . Deleted ) ; ChangeStateWithMethod ( ( VAR0 , VAR1 ) => VAR0 . Remove ( VAR1 ) , EntityState . Added , EntityState . Detached ) ;
var VAR0 = new NotifyingProduct { VAR13 = Guid . NewGuid ( ) , VAR1 = LITERAL } ; var VAR2 = new NotifyingProduct { VAR13 = Guid . NewGuid ( ) , VAR1 = LITERAL } ; var VAR3 = new NotifyingCategory { VAR13 = 1 , VAR4 = LITERAL , VAR5 = { VAR0 , VAR2 } } ; var VAR6 = VAR7 . GetOrCreateEntry ( VAR3 ) ; VAR6 . SetEntityState ( EntityState . Unchanged ) ; var VAR8 = new NotifyingProduct { VAR9 = new NotifyingProductTag ( ) } ; VAR3 . VAR5 . Add ( VAR8 ) ; VAR10 . DetectChanges ( VAR6 ) ; Assert . Equal ( EntityState . Unchanged , VAR6 . EntityState ) ; Assert . Equal ( VAR3 . VAR4 , VAR8 . VAR1 ) ; Assert . Same ( VAR3 , VAR8 . VAR11 ) ; Assert . Equal ( new [ ] { VAR0 , VAR2 , VAR8 } . OrderBy ( VAR12 => VAR12 . VAR13 ) , VAR3 . VAR5 . OrderBy ( VAR12 => VAR12 . VAR13 ) . ToArray ( ) ) ;
var VAR0 = ( ( IAccessor < IServiceProvider > ) VAR1 ) . Service ; var VAR2 = VAR0 . GetRequiredService < IModelSource > ( ) ; VAR1 . Dispose ( ) ; VAR1 = new EarlyLearningCenter ( VAR3 ) ; VAR0 = ( ( IAccessor < IServiceProvider > ) VAR1 ) . Service ;
VAR0 . Entry ( VAR1 ) . State = EntityState . Unchanged ; Assert . Equal ( 1 , VAR2 . VAR3 ) ; Assert . Same ( VAR2 , VAR1 . VAR4 . Single ( ) ) ; Assert . Same ( VAR1 , VAR2 . VAR5 ) ; Assert . Empty ( VAR6 . VAR4 ) ; Assert . Equal ( EntityState . Unchanged , VAR0 . Entry ( VAR1 ) . State ) ; Assert . Equal ( EntityState . Unknown , VAR0 . Entry ( VAR2 ) . State ) ; VAR0 . Entry ( VAR2 ) . State = EntityState . Unchanged ;
var VAR0 = VAR1 . Add ( new Unicorn { VAR2 = VAR3 , VAR4 = LITERAL } ) . Entity ; Assert . True ( VAR0 . VAR5 > 0 ) ; Assert . NotEqual ( Guid . Empty , VAR0 . VAR6 ) ; await VAR1 . SaveChangesAsync ( ) ; VAR7 = VAR0 . VAR5 ; VAR8 = VAR0 . VAR6 ;
VAR0 . Entry ( VAR1 ) . State = EntityState . Unknown ; var VAR2 = await CreateBlogDatabaseAsync < Blog > ( VAR0 ) ; var VAR3 = VAR2 [ 0 ] ; VAR3 . VAR4 = LITERAL ; VAR5 = VAR3 . VAR6 ; var VAR7 = VAR2 [ 1 ] ; VAR7 . VAR4 = LITERAL ; VAR8 = VAR7 . VAR6 ; VAR0 . Remove ( VAR7 ) ; VAR0 . Entry ( VAR1 ) . State = EntityState . Added ;
Assert . False ( ( ( IForeignKey ) VAR0 ) . IsUnique ) ; VAR0 . IsRequired = true ; VAR0 . IsUnique = true ; new RelationshipDiscoveryConvention ( ) . Apply ( VAR1 ) ; var VAR2 = ( IForeignKey ) VAR3 . ForeignKeys . Single ( ) ; Assert . True ( VAR2 . IsRequired ) ; Assert . True ( VAR2 . IsUnique ) ;
Assert . Equal ( - 1 , VAR0 [ VAR1 ] ) ; VAR2 . VAR3 = LITERAL ; VAR0 . EnsureSnapshot ( VAR1 ) ; Assert . True ( VAR0 . HasValue ( VAR1 ) ) ; Assert . Equal ( - 1 , VAR0 [ VAR1 ] ) ;
VAR0 . Entity ( typeof ( VAR1 ) ) . HasMany ( typeof ( VAR2 ) , LITERAL ) . WithOne ( LITERAL ) ; Assert . Same ( VAR3 , VAR4 . ForeignKeys . Single ( ) ) ; Assert . Equal ( LITERAL , VAR4 . Navigations . Single ( ) . VAR5 ) ; Assert . Same ( VAR6 , VAR7 . Navigations . Single ( ) ) ; Assert . Same ( VAR3 , VAR4 . Navigations . Single ( ) . ForeignKey ) ; Assert . Same ( VAR3 , VAR7 . Navigations . Single ( ) . ForeignKey ) ; Assert . Equal ( VAR8 , VAR7 . Properties . Count ) ;
VAR0 . Entity ( typeof ( VAR1 ) ) . HasOne ( typeof ( OrderDetails ) , LITERAL ) . WithOne ( LITERAL ) ; Assert . Same ( VAR2 , VAR3 . ForeignKeys . Single ( ) ) ; Assert . Equal ( LITERAL , VAR3 . Navigations . Single ( ) . VAR4 ) ; Assert . Equal ( LITERAL , VAR5 . Navigations . Single ( ) . VAR4 ) ; Assert . Same ( VAR2 , VAR3 . Navigations . Single ( ) . ForeignKey ) ; Assert . Same ( VAR2 , VAR5 . Navigations . Single ( ) . ForeignKey ) ; Assert . Equal ( VAR6 , VAR5 . Properties . Count ) ;
VAR0 . Entity ( typeof ( VAR1 ) . FullName ) . HasMany ( typeof ( VAR2 ) . FullName , LITERAL ) . WithOne ( LITERAL ) ; Assert . Same ( VAR3 , VAR4 . ForeignKeys . Single ( ) ) ; Assert . Same ( VAR5 , VAR4 . Navigations . Single ( ) ) ; Assert . Same ( VAR6 , VAR7 . Navigations . Single ( ) ) ; Assert . Same ( VAR3 , VAR4 . Navigations . Single ( ) . ForeignKey ) ; Assert . Same ( VAR3 , VAR7 . Navigations . Single ( ) . ForeignKey ) ; Assert . Equal ( VAR8 , VAR7 . Properties . Count ) ;
var VAR0 = CreateModelBuilder ( VAR1 ) ; VAR0 . Entity < VAR2 > ( ) ; VAR0 . Entity < VAR3 > ( ) ; VAR0 . Ignore < OrderDetails > ( ) ; VAR0 . Ignore < CustomerDetails > ( ) ; var VAR4 = VAR1 . GetEntityType ( typeof ( VAR3 ) ) ; var VAR5 = VAR1 . GetEntityType ( typeof ( VAR2 ) ) ; var VAR6 = VAR4 . GetProperty ( LITERAL ) ; var VAR7 = VAR5 . Keys . Single ( ) ; var VAR8 = VAR4 . Keys . Single ( ) ;
var VAR0 = TestHelpers . CreateConventionBuilder ( VAR1 ) ; VAR0 . Entity < Product > ( ) ; VAR0 . Entity < VAR2 > ( ) ; var VAR3 = VAR1 . GetEntityType ( typeof ( VAR2 ) ) ; var VAR4 = VAR1 . GetEntityType ( typeof ( Product ) ) ; var VAR5 = VAR4 . GetOrAddForeignKey ( VAR4 . GetProperty ( LITERAL ) , VAR3 . GetPrimaryKey ( ) ) ; var VAR6 = VAR3 . GetOrAddForeignKey ( VAR3 . GetProperty ( LITERAL ) , VAR4 . GetPrimaryKey ( ) ) ;
Assert . Equal ( 1 , VAR0 . ForeignKeys . Count ) ; var VAR1 = VAR0 . ForeignKeys . Single ( VAR2 => VAR2 != VAR3 ) ; Assert . False ( VAR1 . IsUnique ) ; Assert . NotSame ( VAR3 , VAR1 ) ; Assert . Equal ( LITERAL , VAR0 . Navigations . Single ( ) . VAR4 ) ;
VAR0 . Entity < VAR1 > ( ) ; VAR0 . Ignore < OrderDetails > ( ) ; VAR0 . Ignore < CustomerDetails > ( ) ; var VAR2 = VAR3 . GetEntityType ( typeof ( VAR1 ) ) ; var VAR4 = VAR3 . GetEntityType ( typeof ( VAR5 ) ) ; var VAR6 = VAR2 . GetProperty ( LITERAL ) ; var VAR9 = VAR4 . Keys . Single ( ) ;
VAR0 = await VAR1 . NextAsync ( VAR2 , new ContextService < DataStoreServices > ( ( ) => null ) ) ; Assert . Equal ( 1 , VAR0 . Value ) ; Assert . False ( VAR0 . IsTemporary ) ; VAR0 = await VAR1 . NextAsync ( VAR2 , new ContextService < DataStoreServices > ( ( ) => null ) ) ;
Assert . True ( VAR0 . Ignore ( typeof ( VAR1 ) . FullName , ConfigurationSource . Convention ) ) ; Assert . NotNull ( VAR0 . Entity ( typeof ( VAR1 ) . FullName , ConfigurationSource . Convention ) ) ; Assert . NotNull ( VAR0 . Entity ( typeof ( VAR1 ) . FullName , ConfigurationSource . DataAnnotation ) ) ; Assert . False ( VAR0 . Ignore ( typeof ( VAR1 ) . FullName , ConfigurationSource . Convention ) ) ;
var VAR11 = CreateContextServices ( ) ; var VAR1 = VAR11 . GetRequiredService < StateManager > ( ) ; var VAR2 = new VAR3 { VAR4 = LITERAL } ; var VAR5 = new VAR3 { VAR4 = LITERAL } ; var VAR6 = new VAR7 { VAR4 = LITERAL , VAR8 = LITERAL } ; VAR1 . StartTracking ( VAR1 . GetOrCreateEntry ( VAR2 ) ) ; VAR1 . StartTracking ( VAR1 . GetOrCreateEntry ( VAR5 ) ) ; var VAR9 = VAR1 . StartTracking ( VAR1 . GetOrCreateEntry ( VAR6 ) ) ; var VAR10 = CreateNavigationFixer ( VAR11 ) ;
var VAR5 = TestHelpers . CreateContextServices ( VAR1 ) ; var VAR2 = CreateStateEntry ( VAR5 , VAR3 , new SomeEntity ( ) ) ; VAR2 [ VAR4 ] = 1 ; VAR2 . EntityState = EntityState . Added ; Assert . Equal ( EntityState . Added , VAR2 . EntityState ) ; Assert . Contains ( VAR2 , VAR5 . GetRequiredService < StateManager > ( ) . StateEntries ) ;
VAR0 . Property < int > ( VAR2 . IdProperty . VAR5 ) ; VAR0 . Key ( VAR2 . IdProperty . VAR5 ) ; VAR1 . Entity ( typeof ( VAR2 ) , VAR0 => { VAR0 . Property < int > ( VAR2 . IdProperty . VAR5 ) ; VAR0 . Key ( VAR2 . IdProperty . VAR5 ) ; } ) ; var VAR3 = VAR4 . GetEntityType ( typeof ( VAR2 ) ) ; Assert . Equal ( 1 , VAR3 . GetPrimaryKey ( ) . Properties . Count ( ) ) ; Assert . Equal ( VAR2 . IdProperty . VAR5 , VAR3 . GetPrimaryKey ( ) . Properties . First ( ) . VAR5 ) ;
VAR0 . Property < string > ( VAR2 . NameProperty . VAR7 ) ; VAR0 . Key ( VAR2 . IdProperty . VAR7 , VAR2 . NameProperty . VAR7 ) ; VAR1 . Entity < VAR2 > ( VAR0 => { VAR0 . Property ( VAR3 => VAR3 . VAR4 ) ; VAR0 . Property < string > ( VAR2 . NameProperty . VAR7 ) ; VAR0 . Key ( VAR2 . IdProperty . VAR7 , VAR2 . NameProperty . VAR7 ) ; } ) ; var VAR5 = VAR6 . GetEntityType ( typeof ( VAR2 ) ) ; Assert . Equal ( LITERAL , VAR5 . GetPrimaryKey ( ) . Properties . Count ( ) ) ; Assert . Equal ( VAR2 . IdProperty . VAR7 , VAR5 . GetPrimaryKey ( ) . Properties . First ( ) . VAR7 ) ; Assert . Equal ( VAR2 . NameProperty . VAR7 , VAR5 . GetPrimaryKey ( ) . Properties . Last ( ) . VAR7 ) ;
VAR0 . Entity < VAR10 > ( ) . Property ( VAR2 => VAR2 . VAR11 ) ; var VAR4 = VAR5 . GetEntityType ( typeof ( VAR10 ) ) ; var VAR6 = VAR5 . GetEntityType ( typeof ( VAR12 ) ) ; var VAR8 = VAR4 . GetProperty ( LITERAL ) ; var VAR9 = VAR6 . GetProperty ( VAR12 . IdProperty . VAR13 ) ;
var VAR5 = CreateConfiguration ( VAR1 ) . ScopedServiceProvider . GetRequiredService < StateManager > ( ) ; var VAR2 = new object [  ] { LITERAL , LITERAL , LITERAL } ; var VAR3 = VAR1 . GetEntityType ( typeof ( GuidKeysPoco ) ) ; var VAR4 = VAR5 . GetOrMaterializeEntry ( VAR3 , new AtsObjectArrayValueReader ( VAR2 ) ) ;
var VAR8 = new Mock < StateEntryNotifier > ( ) ; new StateEntrySubscriber ( VAR8 . Object ) . SnapshotAndSubscribe ( VAR1 . Object ) ; VAR2 . VAR3 = LITERAL ; VAR8 . Verify ( VAR4 => VAR4 . VAR5 ( VAR1 . Object , VAR6 ) ) ; VAR8 . Verify ( VAR4 => VAR4 . VAR7 ( VAR1 . Object , VAR6 ) ) ;
var VAR0 = new Sequence ( LITERAL , typeof ( int ) , LITERAL , LITERAL ) ; var VAR1 = VAR0 . Clone ( new CloneContext ( ) ) ; Assert . NotSame ( VAR0 , VAR1 ) ; Assert . Equal ( LITERAL , VAR1 . Name ) ; Assert . Equal ( typeof ( int ) , VAR1 . Type ) ;
Assert . Equal ( typeof ( long ) , VAR0 . Type ) ; Assert . Equal ( 1 , VAR0 . StartWith ) ; Assert . Equal ( LITERAL , VAR0 . IncrementBy ) ; var VAR1 = VAR2 . Sequences [ 1 ] ; Assert . Equal ( LITERAL , VAR1 . Name ) ; Assert . Equal ( typeof ( long ) , VAR0 . Type ) ;
Assert . Equal ( typeof ( int ) , VAR0 . Type ) ; Assert . Equal ( LITERAL , VAR0 . StartWith ) ; Assert . Equal ( LITERAL , VAR0 . IncrementBy ) ; var VAR1 = VAR2 . Sequences [ 1 ] ; Assert . Equal ( LITERAL , VAR1 . Name ) ; Assert . Equal ( typeof ( short ) , VAR1 . Type ) ;
Assert . Equal ( typeof ( long ) , VAR0 . Type ) ; Assert . Equal ( 1 , VAR0 . StartWith ) ; Assert . Equal ( LITERAL , VAR0 . IncrementBy ) ; var VAR1 = VAR2 . Sequences [ 1 ] ; Assert . Equal ( LITERAL , VAR1 . Name ) ; Assert . Equal ( typeof ( long ) , VAR0 . Type ) ;
var VAR12 = CreateStoreServices ( ) ; var VAR13 = VAR14 . GetEntityType ( typeof ( AnEntity ) ) ; var VAR1 = VAR13 . GetProperty ( LITERAL ) ; var VAR2 = RedisDatabase . ConstructRedisValueGeneratorKeyName ( VAR1 ) ; const int VAR3 = 1 ; var VAR4 = VAR13 . GetProperty ( LITERAL ) ; var VAR5 = VAR13 . GetProperty ( LITERAL ) ; var VAR6 = VAR13 . GetProperty ( LITERAL ) ; var VAR7 = VAR13 . GetProperty ( LITERAL ) ; var VAR8 = VAR13 . GetProperty ( LITERAL ) ; var VAR9 = VAR13 . GetProperty ( LITERAL ) ; var VAR10 = VAR13 . GetProperty ( LITERAL ) ; var VAR11 = VAR13 . GetProperty ( LITERAL ) ;
VAR0 . GenerateValueOnAdd = VAR5 ; VAR0 . Relational ( ) . Column = LITERAL ; VAR2 . GetOrSetPrimaryKey ( VAR0 ) ; var VAR3 = VAR2 . GetOrAddProperty ( LITERAL , typeof ( string ) ) ; VAR3 . Relational ( ) . Column = LITERAL ; VAR3 . IsStoreComputed = VAR6 ;
VAR0 . Property ( VAR1 => VAR1 . VAR2 ) . GenerateValueOnAdd ( false ) ; VAR0 . Property ( VAR1 => VAR1 . VAR3 ) . GenerateValueOnAdd ( ) ; VAR0 . Property ( VAR1 => VAR1 . VAR4 ) . GenerateValueOnAdd ( true ) ; VAR0 . Property < int > ( LITERAL ) . GenerateValueOnAdd ( ) ; VAR0 . Property < string > ( LITERAL ) . GenerateValueOnAdd ( false ) ; VAR0 . Property ( typeof ( int ) , LITERAL ) . GenerateValueOnAdd ( ) ; VAR0 . Property ( typeof ( string ) , LITERAL ) . GenerateValueOnAdd ( false ) ;
VAR0 . Property ( VAR1 => VAR1 . VAR2 ) . GenerateValueOnAdd ( false ) ; VAR0 . Property ( VAR1 => VAR1 . VAR3 ) . GenerateValueOnAdd ( ) ; VAR0 . Property ( VAR1 => VAR1 . VAR4 ) . GenerateValueOnAdd ( true ) ; VAR0 . Property < int > ( LITERAL ) . GenerateValueOnAdd ( ) ; VAR0 . Property < string > ( LITERAL ) . GenerateValueOnAdd ( false ) ; VAR0 . Property ( typeof ( int ) , LITERAL ) . GenerateValueOnAdd ( ) ; VAR0 . Property ( typeof ( string ) , LITERAL ) . GenerateValueOnAdd ( false ) ;
VAR0 . GenerateValueOnAdd = false ; var VAR1 = VAR2 . GetEntityType ( typeof ( Resolution ) ) . GetProperty ( LITERAL ) ; VAR1 . GenerateValueOnAdd = false ; var VAR3 = VAR2 . GetEntityType ( typeof ( CustomerInfo ) ) . GetProperty ( LITERAL ) ; VAR3 . GenerateValueOnAdd = false ;
Assert . Equal ( LITERAL , TestSqlLoggerFactory . SqlStatements . Count ) ; Assert . True ( TestSqlLoggerFactory . SqlStatements [ 0 ] . Contains ( LITERAL ) ) ; Assert . True ( TestSqlLoggerFactory . SqlStatements [ 1 ] . Contains ( LITERAL ) ) ; Assert . True ( TestSqlLoggerFactory . SqlStatements [ LITERAL ] . Contains ( LITERAL ) ) ; Assert . True ( TestSqlLoggerFactory . SqlStatements [ LITERAL ] . Contains ( LITERAL ) ) ; Assert . True ( TestSqlLoggerFactory . SqlStatements [ LITERAL ] . Contains ( LITERAL ) ) ;
Assert . Equal ( typeof ( int ? ) , VAR0 . Properties . Single ( ) . PropertyType ) ; Assert . True ( VAR0 . Properties . Single ( ) . IsShadowProperty ) ; Assert . False ( VAR0 . Properties . Single ( ) . IsConcurrencyToken ) ; Assert . Same ( VAR1 , VAR0 . ReferencedProperties . Single ( ) ) ; Assert . False ( VAR0 . IsUnique ) ; Assert . False ( VAR0 . IsRequired ) ;
var VAR2 = CreateInternalEntityBuilder < EntityWithId > ( ) ; new KeyConvention ( ) . Apply ( VAR2 ) ; var VAR1 = VAR2 . Metadata . TryGetPrimaryKey ( ) ;
var VAR1 = CreateInternalEntityBuilder < EntityWithInvalidProperties > ( ) ; new PropertiesConvention ( ) . Apply ( VAR1 ) ; Assert . Empty ( VAR1 . Metadata . Properties ) ;
VAR0 [ LITERAL ] = LITERAL ; VAR0 [ LITERAL ] = LITERAL ; var VAR1 = VAR0 . GetOrAddProperty ( VAR0 . Type . GetProperty ( LITERAL + VAR2 ) ) ; VAR1 [ LITERAL + VAR2 + LITERAL ] = LITERAL + VAR2 + LITERAL ; VAR1 [ LITERAL + VAR2 + LITERAL ] = LITERAL + VAR2 + LITERAL ;
VAR0 . Property < string > ( LITERAL ) . ForRelational ( ) . Column ( LITERAL ) ; VAR0 . Key ( LITERAL ) . ForRelational ( ) . Name ( LITERAL ) ; VAR0 . ForRelational ( ) . Table ( LITERAL , LITERAL ) ; VAR0 . ForeignKey ( LITERAL , LITERAL ) . ForRelational ( ) . Name ( LITERAL ) ; VAR0 . Index ( LITERAL ) . IsUnique ( ) . ForRelational ( ) . Name ( LITERAL ) ;
VAR0 . Entity < PocoTestType > ( ) . ForAzureTableStorage ( ) . PartitionAndRowKey ( VAR1 => VAR1 . BigCount , VAR1 => VAR1 . IsEnchanted ) ; var VAR2 = VAR3 . EntityTypes . First ( ) . GetPrimaryKey ( ) ; Assert . Equal ( LITERAL , VAR2 . Properties . Count ) ; Assert . Equal ( LITERAL , VAR2 . Properties . First ( VAR1 => VAR1 . AzureTableStorage ( ) . Column == LITERAL ) . Name ) ; Assert . Equal ( LITERAL , VAR2 . Properties . First ( VAR1 => VAR1 . AzureTableStorage ( ) . Column == LITERAL ) . Name ) ;
VAR0 . Relational ( ) . Column = LITERAL ; VAR1 . GetOrSetPrimaryKey ( VAR0 ) ; var VAR2 = VAR1 . GetOrAddProperty ( LITERAL , typeof ( string ) ) ; VAR2 . IsConcurrencyToken = VAR3 == ValueGeneration . OnAddAndUpdate ; VAR2 . Relational ( ) . Column = LITERAL ; VAR2 . ValueGeneration = VAR3 ;
var VAR3 = CreateConfiguration ( new DbContextOptions ( ) . UseInMemoryStore ( persist : true ) ) ; var VAR1 = new InMemoryDatabase ( new [ ] { new NullLoggerFactory ( ) } ) ; var VAR2 = new InMemoryDataStore ( VAR3 , VAR1 ) ;
Assert . Equal ( LITERAL , VAR0 . DataType ) ; Assert . Equal ( LITERAL , VAR0 . StartWith ) ; Assert . Equal ( LITERAL , VAR0 . IncrementBy ) ; var VAR1 = VAR2 . Sequences [ 1 ] ; Assert . Equal ( LITERAL , VAR1 . Name ) ; Assert . Equal ( LITERAL , VAR1 . DataType ) ; Assert . Equal ( LITERAL , VAR1 . StartWith ) ;
VAR0 . Entity ( typeof ( VAR1 ) , ConfigurationSource . Explicit ) . Key ( new [ ] { VAR1 . VAR2 , VAR1 . VAR3 } ) ; var VAR4 = VAR0 . Entity ( typeof ( Order ) , ConfigurationSource . Explicit ) ; var VAR5 = VAR4 . ForeignKey ( typeof ( VAR1 ) , new [ ] { Order . VAR6 , Order . VAR7 } , ConfigurationSource . Explicit ) ; Assert . NotNull ( VAR5 ) ; Assert . Same ( VAR5 , VAR4 . ForeignKey ( typeof ( VAR1 ) . FullName , new [ ] { Order . VAR6 . VAR8 , Order . VAR7 . VAR8 } , ConfigurationSource . Explicit ) ) ;
VAR0 . AddNavigation ( LITERAL , VAR1 , pointsToPrincipal : false ) ; VAR2 . AddNavigation ( LITERAL , VAR1 , pointsToPrincipal : true ) ; var VAR3 = VAR4 . GetEntityType ( typeof ( Customer ) ) ; var VAR5 = VAR4 . GetEntityType ( typeof ( Order ) ) ; var VAR6 = VAR5 . ForeignKeys . Single ( ) ; VAR3 . AddNavigation ( LITERAL , VAR6 , pointsToPrincipal : false ) ; VAR5 . AddNavigation ( LITERAL , VAR6 , pointsToPrincipal : true ) ;
var VAR0 = VAR1 . GetOrAddForeignKey ( VAR2 , VAR1 . GetPrimaryKey ( ) ) ; VAR1 . GetOrAddProperty ( LITERAL , typeof ( string ) ) ; VAR3 . AddEntityType ( VAR1 ) ; VAR1 . AddNavigation ( LITERAL , VAR0 , pointsToPrincipal : false ) ; VAR1 . AddNavigation ( LITERAL , VAR0 , pointsToPrincipal : true ) ;
var VAR0 = new Banana { VAR2 = LITERAL , VAR3 = LITERAL } ; var VAR4 = CreateSidecar ( CreateStateEntry ( VAR0 ) ) ; VAR4 . TakeSnapshot ( VAR5 ) ; Assert . Equal ( 1 , VAR4 [ VAR6 ] ) ; Assert . Equal ( LITERAL , VAR4 [ VAR5 ] ) ; VAR4 [ VAR5 ] = LITERAL ; Assert . Equal ( 1 , VAR4 [ VAR6 ] ) ; Assert . Equal ( LITERAL , VAR4 [ VAR5 ] ) ; Assert . Equal ( 1 , VAR0 . VAR1 ) ;
Assert . Equal ( ValueGeneration . None , VAR0 . Columns [ 0 ] . ValueGenerationStrategy ) ; Assert . NotNull ( VAR1 . PrimaryKey . Name ) ; Assert . Equal ( LITERAL , VAR0 . PrimaryKey . Name ) ; Assert . Same ( VAR0 . Columns [ 0 ] , VAR0 . PrimaryKey . Columns [ 0 ] ) ; Assert . Equal ( 1 , VAR0 . ForeignKeys . Count ) ; Assert . Equal ( LITERAL , VAR1 . Name ) ; Assert . Equal ( 1 , VAR1 . Columns . Count ) ; Assert . Equal ( LITERAL , VAR1 . Columns [ 0 ] . Name ) ; Assert . Equal ( LITERAL , VAR1 . Columns [ 0 ] . DataType ) ; Assert . Equal ( ValueGeneration . OnAdd , VAR1 . Columns [ 0 ] . ValueGenerationStrategy ) ;
VAR0 . GetOrAddProperty ( LITERAL , typeof ( string ) , shadowProperty : true ) ; VAR0 . GetOrAddProperty ( LITERAL , typeof ( string ) , shadowProperty : true ) ; VAR1 . Apply ( VAR0 ) ; var VAR2 = VAR0 . GetPrimaryKey ( ) ;
VAR0 . GetOrSetPrimaryKey ( VAR1 ) ; VAR2 . GetOrSetPrimaryKey ( VAR3 ) ; VAR0 . GetPrimaryKey ( ) . SetKeyName ( LITERAL ) ; VAR2 . GetPrimaryKey ( ) . SetKeyName ( LITERAL ) ; var VAR4 = VAR0 . GetOrAddForeignKey ( VAR2 . GetPrimaryKey ( ) , VAR1 ) ;
var VAR0 = VAR1 . GetOrAddProperty ( LITERAL , typeof ( int ) , shadowProperty : true ) ; VAR1 . GetOrSetPrimaryKey ( VAR0 ) ; var VAR2 = new MixedStateEntry ( VAR3 , VAR1 , new object ( ) ) ; VAR2 [ VAR0 ] = 0 ; VAR2 . EntityState = EntityState . Modified ; var VAR4 = new ModificationCommand ( new SchemaQualifiedName ( LITERAL ) , new ParameterNameGenerator ( ) ) ; VAR4 . AddStateEntry ( VAR2 ) ; var VAR5 = new EntityType ( typeof ( object ) ) ; var VAR6 = VAR5 . GetOrAddProperty ( LITERAL , typeof ( int ) , shadowProperty : true ) ; VAR5 . GetOrSetPrimaryKey ( VAR6 ) ;
VAR0 . AddCommand ( VAR1 ) ; await VAR0 . ExecuteAsync ( new Mock < RelationalTransaction > ( ) . Object , new RelationalTypeMapper ( ) , new Mock < DbContext > ( ) . Object , new Mock < ILogger > ( ) . Object ) ; VAR2 . Verify ( VAR3 => VAR3 . ReadAsync ( It . IsAny < CancellationToken > ( ) ) , Times . Once ) ; VAR2 . Verify ( VAR3 => VAR3 . GetFieldValue < int > ( 0 ) , Times . Once ) ;
Assert . True ( VAR0 . GetProperty ( LITERAL ) . IsShadowProperty ) ; Assert . True ( VAR0 . GetProperty ( LITERAL ) . IsShadowProperty ) ; Assert . Equal ( LITERAL , VAR0 . GetProperty ( LITERAL ) . ShadowIndex ) ; Assert . Equal ( - 1 , VAR0 . GetProperty ( LITERAL ) . ShadowIndex ) ; Assert . Equal ( - 1 , VAR0 . GetProperty ( LITERAL ) . ShadowIndex ) ; Assert . Equal ( 0 , VAR0 . GetProperty ( LITERAL ) . ShadowIndex ) ; Assert . Equal ( 1 , VAR0 . GetProperty ( LITERAL ) . ShadowIndex ) ;
VAR0 . GetOrAddProperty ( LITERAL , typeof ( int ) , shadowProperty : true ) ; VAR0 . GetOrAddProperty ( LITERAL , typeof ( int ) , shadowProperty : true ) ; VAR0 . GetOrAddProperty ( LITERAL , typeof ( int ) , shadowProperty : true ) ; VAR0 . GetOrAddProperty ( LITERAL , typeof ( int ) , shadowProperty : true ) ; var VAR1 = VAR0 . GetOrAddProperty ( LITERAL , typeof ( int ) , shadowProperty : true ) ; var VAR2 = VAR0 . GetOrAddForeignKey ( VAR3 . GetPrimaryKey ( ) , VAR1 ) ;
var VAR0 = VAR1 . GetOrAddProperty ( LITERAL , typeof ( int ) , shadowProperty : true ) ; VAR1 . GetOrAddProperty ( LITERAL , typeof ( int ) , shadowProperty : true ) ; VAR1 . GetOrAddProperty ( LITERAL , typeof ( int ) , shadowProperty : true ) ; var VAR2 = VAR1 . GetOrAddForeignKey ( VAR3 . GetPrimaryKey ( ) , VAR0 ) ;
VAR0 . GetOrAddProperty ( LITERAL , typeof ( int ) , shadowProperty : true ) ; VAR0 . GetOrAddProperty ( LITERAL , typeof ( int ) , shadowProperty : true ) ; VAR0 . GetOrAddProperty ( LITERAL , typeof ( int ) , shadowProperty : true ) ; VAR0 . GetOrAddProperty ( LITERAL , typeof ( int ) , shadowProperty : true ) ; var VAR1 = VAR0 . GetOrAddProperty ( LITERAL , typeof ( int ) , shadowProperty : true ) ; var VAR2 = VAR0 . GetOrAddProperty ( LITERAL , typeof ( int ) , shadowProperty : true ) ;
VAR0 . GetOrAddProperty ( LITERAL , typeof ( int ) , shadowProperty : true ) ; VAR0 . GetOrAddProperty ( LITERAL , typeof ( int ) , shadowProperty : true ) ; VAR0 . GetOrAddProperty ( LITERAL , typeof ( int ) , shadowProperty : true ) ; VAR0 . GetOrAddProperty ( LITERAL , typeof ( int ) , shadowProperty : true ) ; var VAR1 = VAR0 . GetOrAddProperty ( LITERAL , typeof ( int ) , shadowProperty : true ) ; var VAR2 = VAR0 . GetOrAddProperty ( LITERAL , typeof ( int ) , shadowProperty : true ) ; var VAR3 = VAR4 . GetOrAddProperty ( LITERAL , typeof ( int ) , shadowProperty : true ) ; var VAR5 = VAR4 . GetOrAddProperty ( LITERAL , typeof ( int ) , shadowProperty : true ) ;
VAR0 . GetOrSetPrimaryKey ( VAR0 . GetOrAddProperty ( LITERAL , typeof ( int ) , shadowProperty : true ) ) ; var VAR1 = new NamedEntityType ( typeof ( B ) ) ; VAR1 . GetOrSetPrimaryKey ( VAR1 . GetOrAddProperty ( LITERAL , typeof ( int ) , shadowProperty : true ) ) ; var VAR2 = new NamedEntityType ( typeof ( C ) ) ; VAR2 . GetOrSetPrimaryKey ( VAR2 . GetOrAddProperty ( LITERAL , typeof ( int ) , shadowProperty : true ) ) ; VAR0 . GetOrAddForeignKey ( VAR1 . GetPrimaryKey ( ) , VAR0 . GetOrAddProperty ( LITERAL , typeof ( int ) ) ) ; VAR1 . GetOrAddForeignKey ( VAR2 . GetPrimaryKey ( ) , VAR1 . GetOrAddProperty ( LITERAL , typeof ( int ) ) ) ;
VAR0 . GetOrSetPrimaryKey ( VAR0 . GetOrAddProperty ( LITERAL , typeof ( int ) , shadowProperty : true ) ) ; var VAR1 = new NamedEntityType ( typeof ( B ) ) ; VAR1 . GetOrSetPrimaryKey ( VAR1 . GetOrAddProperty ( LITERAL , typeof ( int ) , shadowProperty : true ) ) ; var VAR2 = new NamedEntityType ( typeof ( C ) ) ; VAR2 . GetOrSetPrimaryKey ( VAR2 . GetOrAddProperty ( LITERAL , typeof ( int ) , shadowProperty : true ) ) ; VAR2 . GetOrAddForeignKey ( VAR0 . GetPrimaryKey ( ) , VAR2 . GetOrAddProperty ( LITERAL , typeof ( int ) ) ) ; VAR0 . GetOrAddForeignKey ( VAR1 . GetPrimaryKey ( ) , VAR0 . GetOrAddProperty ( LITERAL , typeof ( int ) ) ) ;
VAR0 . GetOrSetPrimaryKey ( VAR0 . GetOrAddProperty ( LITERAL , typeof ( int ) , shadowProperty : true ) ) ; var VAR1 = new NamedEntityType ( typeof ( B ) ) ; VAR1 . GetOrSetPrimaryKey ( VAR1 . GetOrAddProperty ( LITERAL , typeof ( int ) , shadowProperty : true ) ) ; var VAR2 = new NamedEntityType ( typeof ( C ) ) ; VAR2 . GetOrSetPrimaryKey ( VAR2 . GetOrAddProperty ( LITERAL , typeof ( int ) , shadowProperty : true ) ) ;
VAR3 = new LazyRef < DataStoreSource > ( ( ) => VAR1 . DataStoreSelector . SelectDataStore ( this ) ) ; VAR0 = new LazyRef < IModel > ( ( ) => VAR1 . ModelSource . GetModel ( VAR2 , VAR3 . Value . GetModelBuilderFactory ( this ) ) ) ; VAR4 = new LazyRef < VAR5 > ( ( ) => VAR3 . Value . GetStore ( this ) ) ; VAR6 = new LazyRef < DataStoreConnection > ( ( ) => VAR3 . Value . GetConnection ( this ) ) ; VAR7 = new LazyRef < ILoggerFactory > ( ( ) => VAR8 . TryGetService < ILoggerFactory > ( ) ?? new NullLoggerFactory ( ) ) ;
Assert . False ( VAR0 . IsCondition ) ; Assert . True ( VAR0 . IsKey ) ; Assert . True ( VAR0 . IsRead ) ; Assert . False ( VAR0 . IsWrite ) ; VAR0 = VAR1 . ColumnModifications [ 1 ] ; Assert . Equal ( LITERAL , VAR0 . ColumnName ) ; Assert . Same ( VAR2 , VAR0 . StateEntry ) ; Assert . Equal ( LITERAL , VAR0 . Property . VAR3 ) ; Assert . False ( VAR0 . IsCondition ) ;
var VAR0 = VAR1 . GetOrMaterializeEntry ( VAR2 , new ObjectArrayValueReader ( new object [  ] { LITERAL , LITERAL , null } ) ) ; Assert . Equal ( EntityState . Unchanged , VAR0 . EntityState ) ; Assert . Same ( VAR0 , VAR1 . GetOrMaterializeEntry ( VAR2 , new ObjectArrayValueReader ( new object [  ] { LITERAL , LITERAL , null } ) ) ) ; VAR0 . EntityState = EntityState . Modified ; Assert . Same ( VAR0 , VAR1 . GetOrMaterializeEntry ( VAR2 , new ObjectArrayValueReader ( new object [  ] { LITERAL , LITERAL , null } ) ) ) ; Assert . Equal ( EntityState . Modified , VAR0 . EntityState ) ; Assert . NotSame ( VAR0 , VAR1 . GetOrMaterializeEntry ( VAR2 , new ObjectArrayValueReader ( new object [  ] { LITERAL , LITERAL , null } ) ) ) ;
Check . NotNull ( VAR11 , LITERAL ) ; Check . NotNull ( VAR1 , LITERAL ) ; Check . NotNull ( VAR2 , LITERAL ) ; Check . NotNull ( VAR3 , LITERAL ) ; VAR4 = VAR5 ; VAR6 = VAR7 ; VAR8 = VAR9 ; VAR12 = VAR11 ;
AssertReceivedMessagesConsistent ( VAR2 , VAR1 ) ; AssertReceivedMessagesConsistent ( VAR3 , VAR4 , VAR5 ) ; AssertReceivedMessagesConsistent ( VAR0 ) ; AssertSentMessagesConsistent ( VAR2 , VAR4 , VAR5 ) ; AssertSentMessagesConsistent ( VAR3 ) ; AssertSentMessagesConsistent ( VAR0 , VAR1 ) ;
AssertReceivedMessagesConsistent ( VAR2 , VAR1 ) ; AssertReceivedMessagesConsistent ( VAR0 , VAR4 , VAR5 ) ; AssertReceivedMessagesConsistent ( VAR3 ) ; AssertSentMessagesConsistent ( VAR2 , VAR4 , VAR5 ) ; AssertSentMessagesConsistent ( VAR0 , VAR1 ) ; AssertSentMessagesConsistent ( VAR3 ) ;
var VAR0 = new Mock < RelationshipsSnapshot > ( ) ; var VAR1 = new Mock < StateEntry > ( ) ; VAR1 . Setup ( VAR2 => VAR2 . EntityType ) . Returns ( VAR3 . Object ) ; VAR1 . Setup ( VAR2 => VAR2 . OriginalValues ) . Returns ( VAR4 . Object ) ; VAR1 . Setup ( VAR2 => VAR2 . RelationshipsSnapshot ) . Returns ( VAR0 . Object ) ;
VAR0 . VAR1 . Add ( new Blog { VAR3 = LITERAL } ) ; VAR0 . SaveChanges ( ) ; var VAR4 = VAR0 . VAR1 . SingleOrDefault ( ) ; Assert . NotEqual ( 0 , VAR4 . VAR2 ) ;
VAR0 . ValueGenerationOnSave = VAR1 ; VAR0 . StorageName = LITERAL ; VAR2 . SetKey ( VAR0 ) ; var VAR3 = VAR2 . AddProperty ( LITERAL , typeof ( string ) ) ; VAR3 . StorageName = LITERAL ; VAR3 . ValueGenerationOnSave = VAR4 ;
VAR0 . ValueGenerationOnSave = VAR1 ; VAR0 . StorageName = LITERAL ; VAR2 . SetKey ( VAR0 ) ; var VAR3 = VAR2 . AddProperty ( LITERAL , typeof ( string ) ) ; VAR3 . StorageName = LITERAL ; VAR3 . ValueGenerationOnSave = VAR4 ;
var VAR0 = new ContextEntitySets ( ) ; var VAR1 = VAR0 . GetEntitySet < string > ( VAR2 ) ; Assert . IsType < EntitySet < string > > ( VAR1 ) ; Assert . Same ( VAR2 . Configuration , VAR1 . Configuration ) ;
var VAR0 = new ContextEntitySets ( ) ; var VAR1 = VAR0 . GetEntitySet ( VAR2 , typeof ( string ) ) ; Assert . IsType < EntitySet < string > > ( VAR1 ) ; Assert . Same ( VAR2 . Configuration , VAR1 . Configuration ) ;
VAR0 . EntityState = EntityState . Modified ; Assert . True ( VAR0 . IsPropertyModified ( VAR1 ) ) ; Assert . True ( VAR0 . IsPropertyModified ( VAR2 ) ) ; VAR0 . EntityState = EntityState . Unchanged ;
var VAR0 = TestHelpers . CreateContextConfiguration ( VAR1 ) ; var VAR2 = CreateStateEntry ( VAR0 , VAR3 , new SomeEntity ( ) ) ; VAR2 [ VAR4 ] = 1 ; VAR2 . EntityState = EntityState . Added ; Assert . Equal ( EntityState . Added , VAR2 . EntityState ) ; Assert . Contains ( VAR2 , VAR0 . Services . StateManager . StateEntries ) ;
var VAR0 = new SomeEntity { Id = LITERAL , Name = LITERAL } ; var VAR1 = CreateStateEntry ( VAR2 , VAR3 , VAR0 ) ; Assert . Null ( VAR1 . GetPropertyValue ( VAR4 ) ) ; Assert . Equal ( LITERAL , VAR1 . GetPropertyValue ( VAR5 ) ) ; VAR1 . SetPropertyValue ( VAR4 , LITERAL ) ; VAR1 . SetPropertyValue ( VAR5 , LITERAL ) ; Assert . Equal ( LITERAL , VAR0 . Id ) ; Assert . Equal ( LITERAL , VAR0 . Name ) ;
VAR0 . SetKey ( VAR0 . AddProperty ( LITERAL , typeof ( int ) , shadowProperty : true , concurrencyToken : false ) ) ; var VAR1 = new EntityType ( typeof ( B ) ) ; VAR1 . SetKey ( VAR1 . AddProperty ( LITERAL , typeof ( int ) , shadowProperty : true , concurrencyToken : false ) ) ; var VAR2 = new Model ( ) ; VAR2 . AddEntityType ( VAR0 ) ; VAR2 . AddEntityType ( VAR1 ) ; VAR0 . AddForeignKey ( VAR1 . GetKey ( ) , VAR0 . AddProperty ( LITERAL , typeof ( int ) ) ) ; VAR1 . AddForeignKey ( VAR0 . GetKey ( ) , VAR1 . AddProperty ( LITERAL , typeof ( int ) ) ) ;
var VAR3 = Mock . Of < ContextConfiguration > ( ) ; var VAR1 = new StateEntryFactory ( VAR3 ) . Create ( VAR2 . Object , new object [  ] { LITERAL } ) ; Assert . IsType < ShadowStateEntry > ( VAR1 ) ; Assert . Same ( VAR3 , VAR1 . Configuration ) ;
var VAR3 = Mock . Of < ContextConfiguration > ( ) ; var VAR1 = new StateEntryFactory ( VAR3 ) . Create ( VAR2 . Object , new object [  ] { LITERAL } ) ; Assert . IsType < MixedStateEntry > ( VAR1 ) ; Assert . Same ( VAR3 , VAR1 . Configuration ) ;
var VAR7 = CreateConfiguration ( ) ; var VAR2 = VAR1 . GetEntityType ( typeof ( Customer ) ) ; var VAR3 = new Customer { VAR4 = LITERAL , VAR5 = LITERAL } ; var VAR6 = new ClrStateEntry ( VAR7 , VAR2 , VAR3 ) ;
VAR0 . Setup ( VAR1 => VAR1 . IsClrProperty ) . Returns ( false ) ; var VAR2 = new [ ] { VAR0 . Object } ; VAR3 = VAR3 ?? new Mock < IProperty > ( ) ; VAR3 . Setup ( VAR1 => VAR1 . Index ) . Returns ( 1 ) ; VAR3 . Setup ( VAR1 => VAR1 . ShadowIndex ) . Returns ( 1 ) ; VAR3 . Setup ( VAR1 => VAR1 . IsClrProperty ) . Returns ( false ) ;
VAR0 . AddProperty ( Customer . VAR1 ) ; VAR0 . AddProperty ( LITERAL , typeof ( int ) , shadowProperty : false ) ; VAR0 . AddProperty ( LITERAL , typeof ( int ) , shadowProperty : true ) ; Assert . True ( VAR0 . GetProperty ( LITERAL ) . IsClrProperty ) ; Assert . True ( VAR0 . GetProperty ( LITERAL ) . IsClrProperty ) ; Assert . False ( VAR0 . GetProperty ( LITERAL ) . IsClrProperty ) ;
Assert . Equal ( 0 , VAR0 . TryGetProperty ( LITERAL ) . Index ) ; Assert . Equal ( 1 , VAR0 . TryGetProperty ( LITERAL ) . Index ) ; VAR0 . AddProperty ( new Property ( Customer . VAR1 ) ) ; Assert . Equal ( 0 , VAR0 . TryGetProperty ( LITERAL ) . Index ) ; Assert . Equal ( 1 , VAR0 . TryGetProperty ( LITERAL ) . Index ) ; Assert . Equal ( LITERAL , VAR0 . TryGetProperty ( LITERAL ) . Index ) ;
VAR0 = VAR1 . Connection ; VAR0 . Open ( ) ; VAR2 = VAR0 . DbConnection . CreateCommand ( ) ; VAR2 . CommandText = VAR3 ; VAR1 . Logger . WriteSql ( VAR3 ) ;
