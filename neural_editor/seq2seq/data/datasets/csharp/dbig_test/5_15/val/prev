var VAR0 = await GetError ( VAR1 , VAR2 ) ; var VAR3 = Current . User ; var VAR4 = VAR5 . Actions . FirstOrDefault ( VAR6 => VAR6 . Id == VAR7 ) ; var VAR8 = new JiraClient ( VAR5 ) ; var VAR9 = await VAR8 . CreateIssueAsync ( VAR4 , VAR0 , VAR3 == null ? LITERAL : VAR3 . AccountName ) ;
VAR0 = true ; Interlocked . Increment ( ref VAR1 ) ; VAR2 = LITERAL ; await VAR3 ( ) . ConfigureAwait ( false ) ; VAR2 = LITERAL ; VAR4 = false ;
int VAR0 = ( VAR1 != null ? VAR1 . GetHashCode ( ) : 0 ) ; VAR0 = ( VAR0 * LITERAL ) ^ ( VAR2 != null ? VAR2 . GetHashCode ( ) : 0 ) ; VAR0 = ( VAR0 * LITERAL ) ^ VAR3 . GetHashCode ( ) ; VAR0 = ( VAR0 * LITERAL ) ^ VAR4 ; VAR0 = ( VAR0 * LITERAL ) ^ ( VAR5 != null ? VAR5 . GetHashCode ( ) : 0 ) ;
int VAR0 = ( VAR1 != null ? VAR1 . GetHashCode ( ) : 0 ) ; VAR0 = ( VAR0 * LITERAL ) ^ VAR2 . GetHashCode ( ) ; VAR0 = ( VAR0 * LITERAL ) ^ ( VAR3 != null ? VAR3 . GetHashCode ( ) : 0 ) ; VAR0 = ( VAR0 * LITERAL ) ^ ( VAR4 != null ? VAR4 . GetHashCode ( ) : 0 ) ; VAR0 = ( VAR0 * LITERAL ) ^ ( VAR5 != null ? VAR5 . GetHashCode ( ) : 0 ) ; VAR0 = ( VAR0 * LITERAL ) ^ ( VAR6 != null ? VAR6 . GetHashCode ( ) : 0 ) ;
VAR0 = ( VAR0 * LITERAL ) ^ ( VAR1 != null ? VAR1 . GetHashCode ( ) : 0 ) ; VAR0 = ( VAR0 * LITERAL ) ^ ( VAR2 != null ? VAR2 . GetHashCode ( ) : 0 ) ; VAR0 = ( VAR0 * LITERAL ) ^ ( VAR3 != null ? VAR3 . GetHashCode ( ) : 0 ) ; VAR0 = ( VAR0 * LITERAL ) ^ ( VAR4 != null ? VAR4 . GetHashCode ( ) : 0 ) ; VAR0 = ( VAR0 * LITERAL ) ^ ( VAR5 != null ? VAR5 . GetHashCode ( ) : 0 ) ; VAR0 = ( VAR0 * LITERAL ) ^ ( VAR6 != null ? VAR6 . GetHashCode ( ) : 0 ) ; VAR0 = ( VAR0 * LITERAL ) ^ ( VAR7 != null ? VAR7 . GetHashCode ( ) : 0 ) ;
VAR0 . AppendJoin ( LITERAL , VAR1 . Select ( VAR2 => EscapeLiteral ( VAR2 . Table ) ) ) ; VAR0 . Append ( LITERAL ) ; VAR0 . Append ( VAR3 ) ; VAR0 . Append ( LITERAL ) ; VAR0 . Append ( VAR4 ) ; VAR0 . Append ( LITERAL ) ; VAR0 . AppendJoin ( LITERAL , VAR1 . Select ( VAR2 => EscapeLiteral ( LITERAL ) ) ) ;
VAR0 . AddEntry ( VAR1 ) ; var VAR2 = VAR3 . GetOrCreateEntry ( new object ( ) ) ; VAR2 [ VAR4 ] = VAR5 ; VAR2 . SetEntityState ( EntityState . Modified ) ; var VAR6 = new ModificationCommand ( LITERAL , null , new ParameterNameGenerator ( ) . GenerateNext , false , null ) ; VAR6 . AddEntry ( VAR2 ) ; var VAR7 = new ModificationCommand ( LITERAL , null , new ParameterNameGenerator ( ) . GenerateNext , false , null ) ; VAR7 . AddEntry ( VAR1 ) ;
Assert . Equal ( 0 , VAR0 . Count ) ; var VAR1 = new Driver { Id = - 1 , Name = LITERAL , TeamId = Team . Ferrari , CarNumber = LITERAL } ; VAR0 . Add ( VAR1 ) ; Assert . Same ( VAR1 , VAR2 . Drivers . Find ( - 1 ) ) ; Assert . Equal ( EntityState . Added , VAR2 . Entry ( VAR1 ) . State ) ; Assert . Equal ( 1 , VAR0 . Count ) ; Assert . Equal ( 1 , VAR3 . Count ) ; Assert . Equal ( 1 , VAR4 . Count ) ;
Assert . Equal ( 1 , VAR0 . OptionalChildren . Count ( ) ) ; Assert . DoesNotContain ( VAR1 , VAR0 . OptionalChildren . Select ( VAR2 => VAR2 . Id ) ) ; Assert . Empty ( VAR3 . Set < Optional1 > ( ) . Where ( VAR2 => VAR2 . Id == VAR1 ) ) ; var VAR4 = VAR3 . Set < Optional2 > ( ) . Where ( VAR2 => VAR5 . Contains ( VAR2 . Id ) ) . ToList ( ) ; Assert . Equal ( VAR5 . Count , VAR4 . Count ) ; Assert . True ( VAR4 . All ( VAR2 => VAR2 . ParentId == null ) ) ; Assert . Same ( VAR0 , VAR6 . Parent ) ; Assert . Equal ( 0 , VAR6 . Children . Count ( ) ) ;
Assert . True ( VAR0 . Any ( VAR1 => VAR1 == LITERAL ) ) ; Assert . True ( VAR0 . Any ( VAR1 => VAR1 == LITERAL ) ) ; Assert . True ( VAR0 . Any ( VAR1 => VAR1 == LITERAL ) ) ; Assert . True ( VAR0 . Any ( VAR1 => VAR1 == LITERAL ) ) ; Assert . True ( VAR0 . Any ( VAR1 => VAR1 == LITERAL ) ) ; Assert . True ( VAR0 . Any ( VAR1 => VAR1 == LITERAL ) ) ; Assert . True ( VAR0 . Any ( VAR1 => VAR1 == LITERAL ) ) ; Assert . True ( VAR0 . Any ( VAR1 => VAR1 == LITERAL ) ) ; Assert . True ( VAR0 . Any ( VAR1 => VAR1 == LITERAL ) ) ; Assert . True ( VAR0 . Any ( VAR1 => VAR1 == LITERAL ) ) ; Assert . True ( VAR0 . Any ( VAR1 => VAR1 == LITERAL ) ) ; Assert . True ( VAR0 . Any ( VAR1 => VAR1 == LITERAL ) ) ; Assert . True ( VAR0 . Any ( VAR1 => VAR1 == LITERAL ) ) ; Assert . True ( VAR0 . Any ( VAR1 => VAR1 == LITERAL ) ) ;
var VAR0 = VAR1 . VAR2 . ToArray ( ) ; Assert . Equal ( VAR0 . Length , VAR0 . Count ( VAR3 => VAR3 . VAR4 == LITERAL ) * LITERAL ) ; Assert . Equal ( LITERAL , VAR0 . Single ( VAR3 => VAR3 . VAR5 == VAR6 [ 0 ] ) . VAR4 ) ; Assert . Equal ( LITERAL , VAR0 . Single ( VAR3 => VAR3 . VAR5 == VAR6 [ 1 ] ) . VAR4 ) ; Assert . Equal ( LITERAL , VAR0 . Single ( VAR3 => VAR3 . VAR5 == VAR6 [ LITERAL ] ) . VAR4 ) ; VAR1 . VAR2 . RemoveRange ( VAR0 ) ;
VAR0 . Property < int > ( LITERAL ) . IsConcurrencyToken ( true ) ; VAR0 . Property < string > ( LITERAL ) . IsConcurrencyToken ( false ) ; VAR0 . Property < int > ( LITERAL ) . IsConcurrencyToken ( ) ; VAR0 . Property < string > ( LITERAL ) . IsConcurrencyToken ( false ) ; VAR0 . HasChangeTrackingStrategy ( ChangeTrackingStrategy . ChangingAndChangedNotifications ) ;
VAR0 = new EnumerableToQueryableReMappingExpressionVisitor ( ) . Visit ( VAR0 ) ; VAR0 = new QueryMetadataExtractingExpressionVisitor ( VAR1 ) . Visit ( VAR0 ) ; VAR0 = new AllAnyToContainsRewritingExpressionVisitor ( ) . Visit ( VAR0 ) ; VAR0 = new GroupJoinFlatteningExpressionVisitor ( ) . Visit ( VAR0 ) ; VAR0 = new NullCheckRemovingExpressionVisitor ( ) . Visit ( VAR0 ) ; VAR0 = new EntityEqualityRewritingExpressionVisitor ( VAR1 ) . Rewrite ( VAR0 ) ; VAR0 = new SubqueryMemberPushdownExpressionVisitor ( ) . Visit ( VAR0 ) ; VAR0 = new NavigationExpandingExpressionVisitor ( VAR1 , VAR2 . EvaluatableExpressionFilter ) . Expand ( VAR0 ) ; VAR0 = new FunctionPreprocessingVisitor ( ) . Visit ( VAR0 ) ;
VAR0 . StringBuilder . AppendLine ( LITERAL ) ; VAR0 . StringBuilder . Append ( LITERAL ) ; VAR0 . Visit ( VAR1 ) ; VAR0 . StringBuilder . AppendLine ( LITERAL ) ; VAR0 . StringBuilder . Append ( LITERAL ) ; VAR0 . Visit ( VAR2 ) ; VAR0 . StringBuilder . AppendLine ( LITERAL ) ;
VAR0 . SetSqlServerValueGenerationStrategy ( SqlServerValueGenerationStrategy . SequenceHiLo ) ; VAR0 . SetSqlServerHiLoSequenceName ( VAR1 ) ; VAR0 . SetSqlServerHiLoSequenceSchema ( VAR2 ) ; VAR0 . SetSqlServerIdentitySeed ( null ) ; VAR0 . SetSqlServerIdentityIncrement ( null ) ;
VAR0 . SetSqlServerValueGenerationStrategy ( SqlServerValueGenerationStrategy . IdentityColumn ) ; VAR0 . SetSqlServerIdentitySeed ( VAR1 ) ; VAR0 . SetSqlServerIdentityIncrement ( VAR2 ) ; VAR0 . SetSqlServerHiLoSequenceName ( null ) ; VAR0 . SetSqlServerHiLoSequenceSchema ( null ) ;
Assert . True ( VAR0 . Metadata . GetSqlServerIsClustered ( ) ) ; Assert . NotNull ( VAR0 . IsClustered ( false , fromDataAnnotation : true ) ) ; Assert . False ( VAR0 . Metadata . GetSqlServerIsClustered ( ) ) ; Assert . Null ( VAR0 . IsClustered ( true ) ) ; Assert . False ( VAR0 . Metadata . GetSqlServerIsClustered ( ) ) ;
Assert . Null ( VAR0 . GetSqliteSrid ( ) ) ; VAR0 . SetSqliteSrid ( 1 ) ; Assert . Equal ( 1 , VAR0 . GetSqliteSrid ( ) ) ; VAR0 . SetSqliteSrid ( null ) ; Assert . Null ( VAR0 . GetSqliteSrid ( ) ) ;
Assert . NotNull ( VAR0 . ForSqlServerIsClustered ( true ) ) ; Assert . True ( VAR0 . Metadata . GetSqlServerIsClustered ( ) ) ; Assert . NotNull ( VAR0 . ForSqlServerIsClustered ( false , fromDataAnnotation : true ) ) ; Assert . False ( VAR0 . Metadata . GetSqlServerIsClustered ( ) ) ; Assert . Null ( VAR0 . ForSqlServerIsClustered ( true ) ) ; Assert . False ( VAR0 . Metadata . GetSqlServerIsClustered ( ) ) ;
var VAR0 = CreateCommand ( VAR1 , VAR2 . ParameterValues ) ; VAR1 . Open ( ) ; var VAR3 = Guid . NewGuid ( ) ; var VAR4 = DateTimeOffset . UtcNow ;
VAR0 = VAR0 ?? new HashSet < ISupplier > ( ) ; VAR1 = VAR1 ?? new HashSet < IDiscontinuedProduct > ( ) ; VAR2 = VAR2 ?? new HashSet < IProductReview > ( ) ; VAR3 = VAR3 ?? new HashSet < IProductPhoto > ( ) ; VAR4 = VAR4 ?? new HashSet < IBarcode > ( ) ;
Assert . Contains ( VAR0 , VAR1 . VAR2 ) ; Assert . Same ( VAR1 , VAR0 . VAR3 ) ; Assert . Null ( VAR1 . VAR4 ) ; Assert . Equal ( VAR5 , VAR6 . Entry ( VAR1 ) . State ) ; Assert . Equal ( VAR7 == null ? EntityState . Added : VAR5 , VAR6 . Entry ( VAR0 ) . State ) ; Assert . Contains ( VAR8 , VAR0 . VAR9 ) ;
Assert . Contains ( VAR0 , VAR1 . VAR2 ) ; Assert . Null ( VAR1 . VAR3 ) ; Assert . Same ( VAR1 , VAR0 . VAR4 ) ; Assert . Equal ( VAR5 , VAR6 . Entry ( VAR1 ) . State ) ; Assert . Equal ( VAR7 == null ? EntityState . Added : VAR5 , VAR6 . Entry ( VAR0 ) . State ) ; Assert . Contains ( VAR8 , VAR0 . VAR9 ) ;
Assert . Equal ( LITERAL , VAR0 . Carbination ) ; var VAR1 = VAR2 . OfType < Lilt > ( ) . Single ( ) ; Assert . Equal ( LITERAL , VAR1 . SugarGrams ) ; Assert . Equal ( LITERAL , VAR1 . Carbination ) ;
IMutableModel VAR0 = new Model ( ) ; var VAR1 = VAR0 . AddEntityType ( typeof ( T1 ) ) ; var VAR2 = VAR1 . AddProperty ( LITERAL , typeof ( int ) ) ; VAR2 . ValueGenerated = VAR3 ? ValueGenerated . OnAdd : ValueGenerated . Never ; VAR2 . SetColumnName ( LITERAL ) ; VAR1 . SetPrimaryKey ( VAR2 ) ; var VAR4 = VAR1 . AddProperty ( LITERAL , typeof ( string ) ) ; VAR4 . IsConcurrencyToken = VAR5 ; VAR4 . SetColumnName ( LITERAL ) ; VAR4 . ValueGenerated = VAR5 ? ValueGenerated . OnAddOrUpdate : ValueGenerated . Never ; var VAR6 = VAR1 . AddProperty ( LITERAL , typeof ( string ) ) ;
var VAR0 = sqlite3_column_database_name ( VAR1 . VAR2 , VAR3 ) ; VAR4 [ VAR5 ] = VAR0 ; var VAR6 = sqlite3_column_origin_name ( VAR1 . VAR2 , VAR3 ) ; VAR4 [ VAR7 ] = VAR6 ; VAR4 [ VAR8 ] = DBNull . Value ; var VAR9 = sqlite3_column_table_name ( VAR1 . VAR2 , VAR3 ) ; VAR4 [ VAR10 ] = VAR9 ; VAR4 [ VAR11 ] = GetFieldType ( VAR3 ) ; VAR4 [ VAR12 ] = GetDataTypeName ( VAR3 ) ; VAR4 [ VAR13 ] = VAR6 != GetName ( VAR3 ) ; VAR4 [ VAR14 ] = VAR6 == null ; VAR4 [ VAR15 ] = DBNull . Value ;
ValueGeneratorConvention VAR0 = new SqlServerValueGeneratorConvention ( Dependencies , RelationalDependencies ) ; ReplaceConvention ( VAR1 . EntityTypeBaseTypeChangedConventions , VAR0 ) ; var VAR2 = new SqlServerMemoryOptimizedTablesConvention ( Dependencies ) ; VAR1 . EntityTypeAnnotationChangedConventions . Add ( VAR2 ) ; ReplaceConvention ( VAR1 . EntityTypePrimaryKeyChangedConventions , VAR0 ) ; VAR1 . KeyAddedConventions . Add ( VAR2 ) ; ReplaceConvention ( VAR1 . ForeignKeyAddedConventions , VAR0 ) ; ReplaceConvention ( VAR1 . ForeignKeyRemovedConventions , VAR0 ) ; var VAR3 = new SqlServerIndexConvention ( Dependencies , VAR4 ) ;
Assert . NotNull ( ( ( Index ) VAR0 ) . Builder ) ; Assert . NotNull ( ( ( Index ) VAR1 ) . Builder ) ; Assert . Equal ( LITERAL , VAR1 . Properties . Count ) ; Assert . Same ( VAR1 , VAR2 . FindIndex ( new [ ] { VAR3 , VAR4 } ) ) ; Assert . Same ( VAR3 , VAR1 . Properties [ 0 ] ) ; Assert . Same ( VAR4 , VAR1 . Properties [ 1 ] ) ; Assert . True ( VAR3 . IsIndex ( ) ) ; Assert . Equal ( new IIndex [  ] { VAR0 , VAR1 } , VAR3 . GetContainingIndexes ( ) . ToArray ( ) ) ;
VAR0 . EntityTypeAddedConventions . Add ( new DerivedTypeDiscoveryConvention ( VAR1 ) ) ; VAR0 . EntityTypeIgnoredConventions . Add ( VAR2 ) ; var VAR3 = new DiscriminatorConvention ( VAR1 ) ; VAR0 . EntityTypeRemovedConventions . Add ( new OwnedTypesConvention ( VAR1 ) ) ; VAR0 . EntityTypeRemovedConventions . Add ( VAR3 ) ; var VAR4 = new ForeignKeyIndexConvention ( VAR1 ) ; var VAR5 = new ValueGeneratorConvention ( VAR1 ) ;
VAR0 . ModelInitializedConventions . Add ( new RelationalMaxIdentifierLengthConvention ( LITERAL ) ) ; ValueGeneratorConvention VAR1 = new SqlServerValueGeneratorConvention ( VAR2 ) ; ReplaceConvention ( VAR0 . BaseEntityTypeChangedConventions , VAR1 ) ; var VAR3 = new SqlServerMemoryOptimizedTablesConvention ( VAR2 ) ; VAR0 . EntityTypeAnnotationChangedConventions . Add ( VAR3 ) ; ReplaceConvention ( VAR0 . PrimaryKeyChangedConventions , VAR1 ) ;
new DerivedTypeDiscoveryConvention ( new TestLogger < DbLoggerCategory . Model , TestLoggingDefinitions > ( ) ) . Apply ( VAR0 ) ; Assert . Same ( VAR0 . Metadata , VAR1 . Metadata . BaseType ) ; Assert . Same ( VAR0 . Metadata , VAR2 . Metadata . BaseType ) ; new DerivedTypeDiscoveryConvention ( new TestLogger < DbLoggerCategory . Model , TestLoggingDefinitions > ( ) ) . Apply ( VAR1 ) ;
var VAR0 = VAR1 . PrimaryKey ( VAR2 , ConfigurationSource . Convention ) ; Assert . True ( new ValueGeneratorConvention ( new TestLogger < DbLoggerCategory . Model , TestLoggingDefinitions > ( ) ) . Apply ( VAR1 , ( Key ) null ) ) ; var VAR3 = VAR0 . Metadata . Properties ;
Assert . Same ( VAR0 , new ValueGeneratorConvention ( new TestLogger < DbLoggerCategory . Model , TestLoggingDefinitions > ( ) ) . Apply ( VAR0 ) ) ; Assert . Equal ( ValueGenerated . Never , ( ( IProperty ) VAR1 ) . ValueGenerated ) ; VAR2 . RemoveForeignKey ( VAR0 . Metadata , ConfigurationSource . Convention ) ; Assert . True ( new ValueGeneratorConvention ( new TestLogger < DbLoggerCategory . Model , TestLoggingDefinitions > ( ) ) . Apply ( VAR2 , ( Key ) null ) ) ;
var VAR0 = VAR1 . Entry ( VAR2 ) . Collection ( VAR3 => VAR3 . VAR4 ) . GetTargetEntry ( VAR5 ) ; Assert . Equal ( VAR2 . VAR6 , VAR0 . Property ( LITERAL ) . CurrentValue ) ; Assert . Equal ( EntityState . Added , VAR0 . State ) ; Assert . Equal ( nameof ( VAR7 . VAR4 ) , VAR0 . Metadata . DefiningNavigationName ) ; Assert . Contains ( VAR8 , VAR5 . VAR9 ) ; Assert . Same ( VAR5 , VAR8 . VAR7 ) ; var VAR10 = VAR0 . Collection ( VAR3 => VAR3 . VAR9 ) . GetTargetEntry ( VAR8 ) ;
var VAR0 = VAR1 . Entry ( VAR2 ) . Collection ( VAR3 => VAR3 . VAR4 ) . GetTargetEntry ( VAR5 ) ; Assert . Equal ( VAR2 . VAR6 , VAR0 . Property ( LITERAL ) . CurrentValue ) ; Assert . Equal ( EntityState . Added , VAR0 . State ) ; Assert . Equal ( nameof ( ParentPN . VAR4 ) , VAR0 . Metadata . DefiningNavigationName ) ; Assert . Contains ( VAR7 , VAR5 . VAR8 ) ; var VAR9 = VAR0 . Collection ( VAR3 => VAR3 . VAR8 ) . GetTargetEntry ( VAR7 ) ;
ValidateSharedTableCompatibility ( VAR0 , VAR1 , VAR2 ) ; ValidateSharedColumnsCompatibility ( VAR0 , VAR1 , VAR2 ) ; ValidateSharedKeysCompatibility ( VAR0 , VAR1 , VAR2 ) ; ValidateSharedForeignKeysCompatibility ( VAR0 , VAR1 , VAR2 ) ; ValidateSharedIndexesCompatibility ( VAR0 , VAR1 , VAR2 ) ;
var VAR0 = VAR1 . Property ( VAR2 , typeof ( string ) , ConfigurationSource . Convention ) ; VAR0 . HasValueGenerator ( ( VAR3 , VAR4 ) => new IdValueGenerator ( ) , ConfigurationSource . Convention ) ; VAR1 . HasKey ( new [ ] { VAR0 . Metadata } , ConfigurationSource . Convention ) ; var VAR5 = VAR1 . Property ( VAR6 , typeof ( JObject ) , ConfigurationSource . Convention ) ;
Assert . Equal ( SqlServerValueGenerationStrategy . SequenceHiLo , VAR0 . SqlServer ( ) . ValueGenerationStrategy ) ; Assert . Equal ( ValueGenerated . OnAdd , VAR0 . ValueGenerated ) ; Assert . Equal ( LITERAL , VAR0 . SqlServer ( ) . HiLoSequenceName ) ; Assert . Equal ( LITERAL , VAR0 . SqlServer ( ) . HiLoSequenceSchema ) ; Assert . NotNull ( VAR1 . SqlServer ( ) . FindSequence ( LITERAL , LITERAL ) ) ; var VAR2 = VAR1 . Relational ( ) . FindSequence ( LITERAL , LITERAL ) ;
Assert . Null ( VAR0 . Property ( nameof ( SpecialOrder . VAR1 ) , typeof ( string ) , ConfigurationSource . DataAnnotation ) ) ; Assert . Null ( VAR2 . Metadata . FindPrimaryKey ( ) ) ; Assert . NotNull ( VAR2 . PrimaryKey ( new [ ] { VAR3 . Metadata . Name } , ConfigurationSource . Explicit ) ) ; VAR3 = VAR0 . Property ( nameof ( SpecialOrder . VAR1 ) , typeof ( string ) , ConfigurationSource . Explicit ) ;
var VAR0 = VAR1 . Scaffolding ( ) ; Assert . Null ( VAR0 . DatabaseName ) ; VAR0 . DatabaseName = LITERAL ; Assert . Equal ( LITERAL , VAR0 . DatabaseName ) ; VAR0 . DatabaseName = null ; Assert . Null ( VAR0 . DatabaseName ) ;
var VAR0 = VAR1 . Metadata . Relational ( ) . DiscriminatorProperty ; Assert . NotNull ( VAR0 ) ; Assert . Same ( VAR0 , VAR2 . Metadata . Relational ( ) . DiscriminatorProperty ) ; Assert . Equal ( typeof ( EntityBase ) . VAR3 , VAR2 . Metadata . Relational ( ) . DiscriminatorValue ) ; Assert . Equal ( typeof ( Entity ) . VAR3 , VAR1 . Metadata . Relational ( ) . DiscriminatorValue ) ; Assert . NotNull ( VAR1 . HasBaseType ( ( Type ) null , ConfigurationSource . DataAnnotation ) ) ; Assert . True ( new DiscriminatorConvention ( VAR4 ) . Apply ( VAR1 , oldBaseType : VAR2 . Metadata ) ) ; Assert . Null ( VAR2 . Metadata . Relational ( ) . DiscriminatorProperty ) ; Assert . Null ( VAR1 . Metadata . Relational ( ) . DiscriminatorProperty ) ;
Assert . Equal ( LITERAL , VAR0 . Relational ( ) . VAR1 ) ; VAR0 . Relational ( ) . VAR1 = LITERAL ; Assert . Equal ( LITERAL , VAR0 . Relational ( ) . VAR1 ) ; VAR0 . Relational ( ) . VAR1 = null ; Assert . Equal ( LITERAL , VAR0 . Relational ( ) . VAR1 ) ;
Assert . Equal ( VAR0 . Relational ( ) . ConstraintName , VAR1 . Relational ( ) . ConstraintName ) ; var VAR2 = VAR0 . DeclaringEntityType . GetDeclaredIndexes ( ) . Single ( ) ; var VAR3 = VAR1 . DeclaringEntityType . GetDeclaredIndexes ( ) . Single ( ) ; Assert . NotSame ( VAR2 , VAR3 ) ; Assert . Equal ( VAR2 . Relational ( ) . VAR4 , VAR3 . Relational ( ) . VAR4 ) ;
Assert . True ( VAR0 . ValueGenerated ( ValueGenerated . OnAddOrUpdate , ConfigurationSource . DataAnnotation ) ) ; Assert . True ( VAR0 . ValueGenerated ( ValueGenerated . Never , ConfigurationSource . DataAnnotation ) ) ; Assert . Equal ( ValueGenerated . Never , VAR1 . ValueGenerated ) ; Assert . False ( VAR0 . ValueGenerated ( ValueGenerated . OnAddOrUpdate , ConfigurationSource . Convention ) ) ;
Assert . True ( VAR0 . ValueGenerated ( ValueGenerated . OnAddOrUpdate , ConfigurationSource . DataAnnotation ) ) ; Assert . False ( VAR0 . ValueGenerated ( ValueGenerated . Never , ConfigurationSource . DataAnnotation ) ) ; Assert . Equal ( ValueGenerated . OnAddOrUpdate , VAR1 . ValueGenerated ) ; Assert . True ( VAR0 . ValueGenerated ( ValueGenerated . Never , ConfigurationSource . Explicit ) ) ;
Assert . True ( VAR0 . HasMaxLength ( 1 , ConfigurationSource . DataAnnotation ) ) ; Assert . True ( VAR0 . HasMaxLength ( LITERAL , ConfigurationSource . DataAnnotation ) ) ; Assert . Equal ( LITERAL , VAR1 . GetMaxLength ( ) . Value ) ; Assert . False ( VAR0 . HasMaxLength ( 1 , ConfigurationSource . Convention ) ) ;
Assert . True ( VAR0 . HasMaxLength ( 1 , ConfigurationSource . DataAnnotation ) ) ; Assert . False ( VAR0 . HasMaxLength ( LITERAL , ConfigurationSource . DataAnnotation ) ) ; Assert . Equal ( 1 , VAR1 . GetMaxLength ( ) . Value ) ; Assert . True ( VAR0 . HasMaxLength ( LITERAL , ConfigurationSource . Explicit ) ) ;
Assert . True ( VAR0 . IsRequired ( true , ConfigurationSource . DataAnnotation ) ) ; Assert . False ( VAR0 . IsRequired ( false , ConfigurationSource . DataAnnotation ) ) ; Assert . False ( VAR1 . IsNullable ) ; Assert . True ( VAR0 . IsRequired ( false , ConfigurationSource . Explicit ) ) ;
Assert . True ( VAR0 . BeforeSave ( PropertySaveBehavior . Throw , ConfigurationSource . DataAnnotation ) ) ; Assert . False ( VAR0 . BeforeSave ( PropertySaveBehavior . Ignore , ConfigurationSource . DataAnnotation ) ) ; Assert . Equal ( PropertySaveBehavior . Throw , VAR1 . GetBeforeSaveBehavior ( ) ) ; Assert . True ( VAR0 . BeforeSave ( PropertySaveBehavior . Ignore , ConfigurationSource . Explicit ) ) ;
Assert . True ( VAR0 . AfterSave ( PropertySaveBehavior . Throw , ConfigurationSource . DataAnnotation ) ) ; Assert . True ( VAR0 . AfterSave ( PropertySaveBehavior . Ignore , ConfigurationSource . DataAnnotation ) ) ; Assert . Equal ( PropertySaveBehavior . Ignore , VAR1 . GetAfterSaveBehavior ( ) ) ; Assert . False ( VAR0 . AfterSave ( PropertySaveBehavior . Save , ConfigurationSource . Convention ) ) ;
Assert . True ( VAR0 . IsUnique ( true , ConfigurationSource . Convention ) ) ; Assert . True ( VAR0 . IsUnique ( false , ConfigurationSource . DataAnnotation ) ) ; Assert . False ( VAR1 . IsUnique ) ; Assert . False ( VAR0 . IsUnique ( true , ConfigurationSource . Convention ) ) ;
Assert . True ( VAR0 . IsUnique ( true , ConfigurationSource . DataAnnotation ) ) ; Assert . False ( VAR0 . IsUnique ( false , ConfigurationSource . DataAnnotation ) ) ; Assert . True ( VAR1 . IsUnique ) ; Assert . True ( VAR0 . IsUnique ( false , ConfigurationSource . Explicit ) ) ;
Assert . True ( VAR0 . HasAnnotation ( LITERAL , 1 , ConfigurationSource . Convention ) ) ; Assert . True ( VAR0 . HasAnnotation ( LITERAL , LITERAL , ConfigurationSource . DataAnnotation ) ) ; Assert . Equal ( LITERAL , VAR1 . GetAnnotations ( ) . Single ( ) . Value ) ; Assert . False ( VAR0 . HasAnnotation ( LITERAL , 1 , ConfigurationSource . Convention ) ) ;
var VAR0 = VAR1 . AddEntityType ( typeof ( VAR2 ) . FullName ) ; var VAR3 = CreateModelBuilder ( VAR1 ) ; Assert . Same ( VAR0 , VAR3 . Entity ( typeof ( VAR2 ) . FullName , ConfigurationSource . Convention ) . Metadata ) ; Assert . False ( VAR3 . Ignore ( typeof ( VAR2 ) . FullName , ConfigurationSource . DataAnnotation ) ) ; Assert . NotNull ( VAR1 . FindEntityType ( typeof ( VAR2 ) . FullName ) ) ; Assert . True ( VAR3 . Ignore ( typeof ( VAR2 ) . FullName , ConfigurationSource . Explicit ) ) ;
Assert . Same ( VAR0 , new ValueGeneratorConvention ( new TestLogger < DbLoggerCategory . Model , LoggingDefinitions > ( ) ) . Apply ( VAR0 ) ) ; Assert . False ( VAR1 [ 0 ] . RequiresValueGenerator ( ) ) ; Assert . Equal ( ValueGenerated . Never , VAR1 [ 0 ] . ValueGenerated ) ; VAR2 . RemoveForeignKey ( VAR0 . Metadata , ConfigurationSource . Convention ) ; new ValueGeneratorConvention ( new TestLogger < DbLoggerCategory . Model , LoggingDefinitions > ( ) ) . Apply ( VAR2 , VAR0 . Metadata ) ;
var VAR0 = new Model ( ) ; var VAR1 = VAR0 . AddEntityType ( LITERAL ) ; VAR1 . AddProperty ( LITERAL , typeof ( int ) ) ; VAR1 . AddProperty ( LITERAL , typeof ( string ) ) ; var VAR2 = InMemoryTestHelpers . Instance . CreateContextServices ( VAR0 ) ; var VAR3 = VAR2 . GetRequiredService < IStateManager > ( ) ; var VAR4 = VAR2 . GetRequiredService < IInternalEntityEntryFactory > ( ) ; var VAR5 = VAR4 . Create ( VAR3 , VAR1 , new Random ( ) ) ;
var VAR0 = new Model ( ) . AddEntityType ( typeof ( TEntity ) ) ; VAR0 . AddProperty ( nameof ( Blog . VAR1 ) , typeof ( int ) ) ; VAR0 . AddProperty ( nameof ( Blog . VAR2 ) , typeof ( string ) ) ; VAR0 . AddProperty ( nameof ( Blog . VAR3 ) , typeof ( string ) ) ; VAR0 . AddProperty ( nameof ( Blog . VAR4 ) , typeof ( int ) ) ; VAR0 . AddProperty ( LITERAL , typeof ( Guid ? ) ) ; VAR0 . AddProperty ( LITERAL , typeof ( string ) ) ; VAR0 . AddProperty ( LITERAL , typeof ( string ) ) ; VAR0 . AddProperty ( LITERAL , typeof ( string ) ) ; VAR0 . AddProperty ( LITERAL , typeof ( string ) ) ; VAR0 . AddProperty ( LITERAL , typeof ( string ) ) ; VAR0 . AddProperty ( LITERAL , typeof ( string ) ) ; VAR5 . Apply ( VAR0 . Model . Builder ) ;
VAR0 . GetOrSetPrimaryKey ( new [ ] { VAR1 , VAR2 } ) ; var VAR3 = VAR4 . AddEntityType ( typeof ( SomeEntity ) ) ; VAR3 . BaseType = VAR5 ; var VAR6 = VAR3 . AddProperty ( LITERAL , typeof ( string ) ) ; VAR6 . IsConcurrencyToken = true ; VAR6 . ValueGenerated = ValueGenerated . OnAdd ; var VAR7 = VAR4 . AddEntityType ( typeof ( SomeDependentEntity ) ) ; VAR7 . BaseType = VAR0 ; var VAR8 = VAR7 . AddProperty ( LITERAL , typeof ( int ) ) ; VAR7 . GetOrAddForeignKey ( new [ ] { VAR8 } , VAR3 . FindPrimaryKey ( ) , VAR3 ) ;
Assert . True ( VAR0 . Properties . Single ( ) . IsShadowProperty ) ; Assert . Null ( VAR0 . GetPropertiesConfigurationSource ( ) ) ; Assert . Same ( VAR0 . DeclaringEntityType , VAR1 . Metadata ) ; Assert . Same ( VAR0 . PrincipalEntityType , VAR2 . Metadata ) ; Assert . True ( VAR0 . IsUnique ) ;
Assert . False ( VAR0 . IsShadowProperty ) ; Assert . Equal ( LITERAL , VAR0 . VAR1 ) ; Assert . Same ( typeof ( string ) , VAR0 . VAR2 ) ; Assert . Same ( VAR3 , VAR0 . DeclaringEntityType ) ; Assert . Same ( HiddenFieldBase . VAR4 , VAR0 . PropertyInfo ) ; Assert . Null ( VAR0 . FieldInfo ) ;
Assert . Equal ( LITERAL , VAR0 . Relational ( ) . VAR1 ) ; Assert . Equal ( LITERAL , ( ( IForeignKey ) VAR0 ) . Relational ( ) . VAR1 ) ; VAR0 . Relational ( ) . VAR1 = LITERAL ; Assert . Equal ( LITERAL , VAR0 . Relational ( ) . VAR1 ) ; Assert . Equal ( LITERAL , ( ( IForeignKey ) VAR0 ) . Relational ( ) . VAR1 ) ; VAR0 . Relational ( ) . VAR1 = LITERAL ; Assert . Equal ( LITERAL , VAR0 . Relational ( ) . VAR1 ) ; Assert . Equal ( LITERAL , ( ( IForeignKey ) VAR0 ) . Relational ( ) . VAR1 ) ; VAR0 . Relational ( ) . VAR1 = null ; Assert . Equal ( LITERAL , VAR0 . Relational ( ) . VAR1 ) ; Assert . Equal ( LITERAL , ( ( IForeignKey ) VAR0 ) . Relational ( ) . VAR1 ) ;
Assert . NotSame ( VAR0 . DeclaringEntityType , VAR1 . DeclaringEntityType ) ; Assert . Equal ( typeof ( int ) , VAR0 . DeclaringEntityType . GetForeignKeys ( ) . Single ( ) . Properties . Single ( ) . ClrType ) ; Assert . Equal ( typeof ( int ) , VAR0 . DeclaringEntityType . GetForeignKeys ( ) . Single ( ) . Properties . Single ( ) . ClrType ) ; Assert . Equal ( LITERAL , VAR0 [ LITERAL ] ) ; Assert . Equal ( LITERAL , VAR2 . GetEntityTypes ( ) . Count ( VAR3 => VAR3 . ClrType == typeof ( BookLabel ) ) ) ; Assert . Equal ( LITERAL , VAR2 . GetEntityTypes ( ) . Count ( ) ) ; VAR4 . Entity < Book > ( ) . OwnsOne ( VAR5 => VAR5 . Label ) . Ignore ( VAR6 => VAR6 . Book ) ; VAR4 . Entity < Book > ( ) . OwnsOne ( VAR5 => VAR5 . AlternateLabel ) . Ignore ( VAR6 => VAR6 . Book ) ; VAR4 . Validate ( ) ;
Assert . Same ( VAR0 , new ValueGeneratorConvention ( ) . Apply ( VAR0 ) ) ; Assert . False ( VAR1 [ 0 ] . RequiresValueGenerator ( ) ) ; Assert . Equal ( ValueGenerated . Never , VAR1 [ 0 ] . ValueGenerated ) ; VAR2 . RemoveForeignKey ( VAR0 . Metadata , ConfigurationSource . Convention ) ; new ValueGeneratorConvention ( ) . Apply ( VAR2 , VAR0 . Metadata ) ;
Assert . Same ( VAR0 , VAR1 . VAR2 ) ; Assert . Same ( VAR1 , VAR0 . VAR3 ) ; Assert . Same ( VAR4 , VAR5 . VAR2 ) ; Assert . Same ( VAR5 , VAR4 . VAR3 ) ; Assert . Equal ( VAR1 . VAR6 , VAR0 . VAR7 ) ; Assert . Equal ( VAR5 . VAR6 , VAR4 . VAR7 ) ; VAR8 . SetEntityState ( EntityState . Detached ) ; Assert . Null ( VAR1 . VAR2 ) ; Assert . Same ( VAR1 , VAR0 . VAR3 ) ; Assert . Same ( VAR4 , VAR5 . VAR2 ) ; Assert . Same ( VAR5 , VAR4 . VAR3 ) ; Assert . Equal ( VAR1 . VAR6 , VAR0 . VAR7 ) ;
var VAR0 = new Model ( ) ; var VAR1 = VAR0 . AddEntityType ( typeof ( Abstract ) ) ; SetPrimaryKey ( VAR1 ) ; var VAR2 = VAR0 . AddEntityType ( typeof ( Generic <  > ) ) ; VAR2 . HasBaseType ( VAR1 ) ;
var VAR0 = new Model ( ) ; var VAR1 = VAR0 . AddEntityType ( typeof ( ChangedOnlyEntity ) ) ; var VAR2 = VAR1 . AddProperty ( LITERAL ) ; VAR1 . SetPrimaryKey ( VAR2 ) ; VAR0 . ChangeTrackingStrategy = VAR3 ;
var VAR0 = new Model ( ) ; var VAR1 = VAR0 . AddEntityType ( typeof ( FullNotificationEntity ) ) ; var VAR2 = VAR1 . AddProperty ( LITERAL ) ; VAR1 . SetPrimaryKey ( VAR2 ) ; VAR0 . ChangeTrackingStrategy = VAR3 ;
VAR0 . UnionWith ( VAR1 . GetRuntimeProperties ( ) . Values . Where ( VAR2 => VAR2 . IsCandidateProperty ( ) ) . Select ( VAR2 => VAR2 . Name ) ) ; VAR0 . ExceptWith ( VAR1 . GetProperties ( ) . Select ( VAR3 => VAR3 . Name ) ) ; VAR0 . ExceptWith ( VAR1 . GetNavigations ( ) . Select ( VAR3 => VAR3 . Name ) ) ; VAR0 . ExceptWith ( VAR1 . GetServiceProperties ( ) . Select ( VAR3 => VAR3 . Name ) ) ; VAR0 . RemoveWhere ( VAR3 => VAR1 . Builder . IsIgnored ( VAR3 , ConfigurationSource . Convention ) ) ;
VAR0 . GetInfrastructure ( ) . Metadata . Validate ( ) ; var VAR1 = CreateModelBuilder ( ) ; VAR2 ( VAR1 ) ; VAR3 ( VAR1 ) ; VAR1 . GetInfrastructure ( ) . Metadata . Validate ( ) ;
VAR0 . Clear ( ) ; VAR1 . VAR2 = LITERAL ; VAR3 . ChangeTracker . DetectChanges ( ) ; var ( level , _ , message ) = VAR0 . Single ( VAR4 => VAR4 . VAR5 . VAR5 == CoreEventId . PropertyChangeDetected . VAR5 ) ;
var ( level , _ , message ) = VAR0 . Single ( VAR1 => VAR1 . VAR2 . VAR2 == CoreEventId . SaveChangesStarting . VAR2 ) ; Assert . Equal ( LogLevel . Debug , level ) ; Assert . Equal ( CoreStrings . LogSaveChangesStarting . GenerateMessage ( nameof ( LikeAZooContext ) ) , message ) ; ( level , _ , message ) = VAR0 . Single ( VAR1 => VAR1 . VAR2 . VAR2 == CoreEventId . SaveChangesCompleted . VAR2 ) ;
VAR0 [ 0 ] . OneToOne_Required_FK_Inverse = VAR1 [ 0 ] ; VAR0 [ 1 ] . OneToOne_Required_FK_Inverse = VAR1 [ 1 ] ; VAR0 [ LITERAL ] . OneToOne_Required_FK_Inverse = VAR1 [ LITERAL ] ; VAR0 [ LITERAL ] . OneToOne_Required_FK_Inverse = VAR1 [ LITERAL ] ; VAR0 [ LITERAL ] . OneToOne_Required_FK_Inverse = VAR1 [ LITERAL ] ; VAR0 [ LITERAL ] . OneToOne_Required_FK_Inverse = VAR1 [ LITERAL ] ; VAR0 [ LITERAL ] . OneToOne_Required_FK_Inverse = VAR1 [ LITERAL ] ; VAR0 [ LITERAL ] . OneToOne_Required_FK_Inverse = VAR1 [ LITERAL ] ; VAR0 [ LITERAL ] . OneToOne_Required_FK_Inverse = VAR1 [ LITERAL ] ; VAR0 [ LITERAL ] . OneToOne_Required_FK_Inverse = VAR1 [ LITERAL ] ;
VAR0 [ 0 ] . OneToOne_Optional_PK_Inverse = VAR1 [ 0 ] ; VAR0 [ LITERAL ] . OneToOne_Optional_PK_Inverse = VAR1 [ LITERAL ] ; VAR0 [ LITERAL ] . OneToOne_Optional_PK_Inverse = VAR1 [ LITERAL ] ; VAR0 [ LITERAL ] . OneToOne_Optional_PK_Inverse = VAR1 [ LITERAL ] ; VAR0 [ LITERAL ] . OneToOne_Optional_PK_Inverse = VAR1 [ LITERAL ] ; VAR0 [ LITERAL ] . OneToOne_Optional_FK_Inverse = VAR1 [ 1 ] ; VAR0 [ LITERAL ] . OneToOne_Optional_FK_Inverse = VAR1 [ LITERAL ] ; VAR0 [ LITERAL ] . OneToOne_Optional_FK_Inverse = VAR1 [ LITERAL ] ; VAR0 [ LITERAL ] . OneToOne_Optional_FK_Inverse = VAR1 [ LITERAL ] ; VAR0 [ 0 ] . OneToOne_Optional_FK_Inverse = VAR1 [ LITERAL ] ;
Assert . Equal ( RelationalTypeMapping . StoreTypeModifierKind . PrecisionAndScale , VAR0 . StoreTypeModifier ) ; var VAR1 = new FakeValueConverter ( ) ; VAR0 = ( RelationalTypeMapping ) VAR2 . Clone ( VAR1 ) ; Assert . NotSame ( VAR2 , VAR0 ) ; Assert . Same ( VAR2 . GetType ( ) , VAR0 . GetType ( ) ) ; Assert . Equal ( LITERAL , VAR0 . StoreType ) ; Assert . Equal ( DbType . VarNumeric , VAR0 . DbType ) ; Assert . Null ( VAR0 . Size ) ; Assert . NotSame ( VAR2 . Converter , VAR0 . Converter ) ; Assert . Same ( VAR2 . Comparer , VAR0 . Comparer ) ; Assert . Same ( VAR2 . KeyComparer , VAR0 . KeyComparer ) ; Assert . Same ( typeof ( object ) , VAR0 . ClrType ) ; Assert . Equal ( RelationalTypeMapping . StoreTypeModifierKind . PrecisionAndScale , VAR0 . StoreTypeModifier ) ;
var VAR0 = CreateModel ( ) ; var VAR1 = new InMemoryDatabaseCreator ( CreateStore ( VAR2 ) , VAR0 ) ; Assert . True ( await VAR1 . EnsureCreatedAsync ( ) ) ; Assert . False ( await VAR1 . EnsureCreatedAsync ( ) ) ; Assert . False ( await VAR1 . EnsureCreatedAsync ( ) ) ; VAR1 = new InMemoryDatabaseCreator ( CreateStore ( VAR2 ) , VAR0 ) ;
Assert . NotEqual ( default ( Guid ) , VAR0 ) ; Assert . Equal ( default ( Guid ) , VAR1 ) ; VAR2 . SaveChanges ( ) ; VAR3 = VAR4 . VAR5 ; var VAR6 = VAR4 . VAR7 ; Assert . NotEqual ( default ( Guid ) , VAR3 ) ; Assert . NotEqual ( default ( Guid ) , VAR6 ) ;
VAR0 . Process ( BenchmarkRunner . Run < InitializationTests > ( ) ) ; VAR0 . Process ( BenchmarkRunner . Run < DbSetOperationTests . AddDataVariations > ( ) ) ; VAR0 . Process ( BenchmarkRunner . Run < DbSetOperationTests . ExistingDataVariations > ( ) ) ; VAR0 . Process ( BenchmarkRunner . Run < FixupTests . ChildVariations > ( ) ) ; VAR0 . Process ( BenchmarkRunner . Run < FixupTests . ParentVariations > ( ) ) ; VAR0 . Process ( BenchmarkRunner . Run < FuncletizationTests > ( ) ) ; VAR0 . Process ( BenchmarkRunner . Run < NavigationsQueryTests > ( ) ) ; VAR0 . Process ( BenchmarkRunner . Run < QueryCompilationTests > ( ) ) ; VAR0 . Process ( BenchmarkRunner . Run < RawSqlQueryTests > ( ) ) ; VAR0 . Process ( BenchmarkRunner . Run < SimpleQueryTests > ( ) ) ; VAR0 . Process ( BenchmarkRunner . Run < SimpleUpdatePipelineTests . Insert > ( ) ) ; VAR0 . Process ( BenchmarkRunner . Run < SimpleUpdatePipelineTests . Update > ( ) ) ; VAR0 . Process ( BenchmarkRunner . Run < SimpleUpdatePipelineTests . Delete > ( ) ) ; VAR0 . Process ( BenchmarkRunner . Run < SimpleUpdatePipelineTests . Mixed > ( ) ) ;
Assert . Null ( VAR0 . GetStoreClrType ( ) ) ; VAR0 . SetStoreClrType ( typeof ( long ) ) ; Assert . Same ( typeof ( long ) , VAR0 . GetStoreClrType ( ) ) ; VAR0 . SetStoreClrType ( null ) ; Assert . Null ( VAR0 . GetStoreClrType ( ) ) ;
Assert . Equal ( LITERAL , VAR0 [ 0 ] . ConsumedProperty . Name ) ; Assert . Equal ( LITERAL , VAR0 [ 1 ] . ConsumedProperty . Name ) ; Assert . Equal ( LITERAL , VAR0 [ LITERAL ] . ConsumedProperty . Name ) ; Assert . Equal ( LITERAL , VAR0 [ LITERAL ] . ConsumedProperty . Name ) ; Assert . Equal ( LITERAL , VAR0 [ LITERAL ] . ConsumedProperty . Name ) ; Assert . Equal ( LITERAL , VAR0 [ LITERAL ] . ConsumedProperty . Name ) ; Assert . Equal ( LITERAL , VAR0 [ LITERAL ] . ConsumedProperty . Name ) ; Assert . Equal ( LITERAL , VAR0 [ LITERAL ] . ConsumedProperty . Name ) ; Assert . Equal ( LITERAL , VAR0 [ LITERAL ] . ConsumedProperty . Name ) ;
Assert . Equal ( nameof ( VAR0 . VAR1 ) , VAR2 . Metadata . DefiningNavigationName ) ; var VAR3 = VAR2 . Reference ( VAR4 => VAR4 . VAR5 ) . TargetEntry ; Assert . Equal ( VAR6 . VAR7 , VAR3 . Property ( LITERAL ) . CurrentValue ) ; Assert . Equal ( EntityState . Unchanged , VAR3 . State ) ; Assert . Equal ( nameof ( VAR1 . VAR5 ) , VAR3 . Metadata . DefiningNavigationName ) ; var VAR8 = VAR2 . Reference ( VAR4 => VAR4 . VAR9 ) . TargetEntry ; Assert . Equal ( VAR6 . VAR7 , VAR8 . Property ( LITERAL ) . CurrentValue ) ; Assert . Equal ( EntityState . Unchanged , VAR8 . State ) ; Assert . Equal ( nameof ( VAR1 . VAR9 ) , VAR8 . Metadata . DefiningNavigationName ) ; AssertFixup ( VAR10 , ( ) => { var VAR11 = VAR6 . VAR1 ; Assert . Same ( VAR6 , VAR11 . VAR0 ) ; var VAR12 = VAR11 . VAR5 ; var VAR13 = VAR11 . VAR9 ; Assert . Same ( VAR11 , VAR12 . VAR1 ) ; Assert . Same ( VAR11 , VAR13 . VAR1 ) ; Assert . Equal ( LITERAL , VAR12 . VAR14 ) ; Assert . Equal ( LITERAL , VAR13 . VAR14 ) ; Assert . Equal ( LITERAL , VAR10 . ChangeTracker . Entries ( ) . Count ( ) ) ; var VAR15 = VAR10 . Entry ( VAR6 ) ; Assert . Equal ( EntityState . Unchanged , VAR15 . State ) ; var VAR2 = VAR15 . Reference ( VAR4 => VAR4 . VAR1 ) . TargetEntry ; Assert . Equal ( VAR6 . VAR7 , VAR2 . Property ( LITERAL ) . CurrentValue ) ; Assert . Equal ( EntityState . Unchanged , VAR2 . State ) ; Assert . Equal ( nameof ( VAR0 . VAR1 ) , VAR2 . Metadata . DefiningNavigationName ) ; var VAR3 = VAR2 . Reference ( VAR4 => VAR4 . VAR5 ) . TargetEntry ; Assert . Equal ( VAR6 . VAR7 , VAR3 . Property ( LITERAL ) . CurrentValue ) ; Assert . Equal ( EntityState . Unchanged , VAR3 . State ) ; Assert . Equal ( nameof ( VAR1 . VAR5 ) , VAR3 . Metadata . DefiningNavigationName ) ; var VAR8 = VAR2 . Reference ( VAR4 => VAR4 . VAR9 ) . TargetEntry ; Assert . Equal ( VAR6 . VAR7 , VAR8 . Property ( LITERAL ) . CurrentValue ) ; Assert . Equal ( EntityState . Unchanged , VAR8 . State ) ; Assert . Equal ( nameof ( VAR1 . VAR9 ) , VAR8 . Metadata . DefiningNavigationName ) ; } ) ;
Assert . NotNull ( VAR0 . Set < MaxLengthDataTypes > ( ) . SingleOrDefault ( VAR1 => VAR1 . VAR2 == LITERAL && VAR1 . VAR3 == VAR4 ) ) ; Assert . NotNull ( VAR0 . Set < MaxLengthDataTypes > ( ) . SingleOrDefault ( VAR1 => VAR1 . VAR2 == LITERAL && VAR1 . VAR5 == VAR6 ) ) ; Assert . NotNull ( VAR0 . Set < MaxLengthDataTypes > ( ) . SingleOrDefault ( VAR1 => VAR1 . VAR2 == LITERAL && VAR1 . VAR7 == VAR8 ) ) ; Assert . NotNull ( VAR0 . Set < MaxLengthDataTypes > ( ) . SingleOrDefault ( VAR1 => VAR1 . VAR2 == LITERAL && VAR1 . VAR9 == VAR10 ) ) ;
var VAR0 = ValueConverter . Compose ( VAR1 , VAR2 ) . ConvertFromStore ; Assert . Equal ( Beatles . John , VAR0 ( LITERAL ) ) ; Assert . Equal ( Beatles . Paul , VAR0 ( LITERAL ) ) ; Assert . Equal ( Beatles . George , VAR0 ( 1 ) ) ; Assert . Equal ( Beatles . Ringo , VAR0 ( LITERAL ) ) ; Assert . Equal ( ( Beatles ) LITERAL , VAR0 ( LITERAL ) ) ; Assert . Equal ( default ( Beatles ) , VAR0 ( 0 ) ) ; Assert . Equal ( default ( Beatles ) , VAR0 ( null ) ) ;
Assert . True ( VAR0 . Sqlite ( ConfigurationSource . Convention ) . HasConstraintName ( LITERAL ) ) ; Assert . Equal ( LITERAL , VAR0 . Metadata . Relational ( ) . Name ) ; Assert . True ( VAR0 . Sqlite ( ConfigurationSource . DataAnnotation ) . HasConstraintName ( LITERAL ) ) ; Assert . Equal ( LITERAL , VAR0 . Metadata . Relational ( ) . Name ) ; Assert . False ( VAR0 . Sqlite ( ConfigurationSource . Convention ) . HasConstraintName ( LITERAL ) ) ;
var VAR0 = new Order { VAR1 = LITERAL , VAR2 = LITERAL , VAR3 = DateTime . Parse ( LITERAL ) } ; var VAR4 = new Order { VAR1 = LITERAL , VAR2 = LITERAL , VAR3 = DateTime . Parse ( LITERAL ) } ; var VAR5 = new Order { VAR1 = LITERAL , VAR2 = LITERAL , VAR3 = DateTime . Parse ( LITERAL ) } ; var VAR6 = new Order { VAR1 = LITERAL , VAR2 = LITERAL , VAR3 = DateTime . Parse ( LITERAL ) } ; var VAR7 = new Order { VAR1 = LITERAL , VAR2 = LITERAL , VAR3 = DateTime . Parse ( LITERAL ) } ; var VAR8 = new Order { VAR1 = LITERAL , VAR2 = LITERAL , VAR3 = DateTime . Parse ( LITERAL ) } ;
await VAR0 . OpenAsync ( default ( CancellationToken ) ) ; Assert . Equal ( 0 , VAR0 . DbConnections . Count ) ; Assert . Equal ( 1 , VAR1 . OpenCount ) ; VAR0 . Close ( ) ; Assert . Equal ( 1 , VAR1 . OpenCount ) ; Assert . Equal ( 1 , VAR1 . CloseCount ) ; VAR1 . SetState ( ConnectionState . Open ) ; await VAR0 . OpenAsync ( default ( CancellationToken ) ) ;
VAR0 = VAR1 . VAR2 . VAR3 ( VAR4 => VAR4 . VAR5 == VAR0 . VAR5 ) ; VAR6 = ( RequiredAk1Derived ) VAR1 . VAR2 . VAR3 ( VAR4 => VAR4 . VAR5 == VAR6 . VAR5 ) ; VAR7 = ( RequiredAk1MoreDerived ) VAR1 . VAR2 . VAR3 ( VAR4 => VAR4 . VAR5 == VAR7 . VAR5 ) ; VAR8 = VAR1 . VAR9 . VAR3 ( VAR4 => VAR4 . VAR5 == VAR8 . VAR5 ) ; VAR10 = VAR1 . VAR9 . VAR3 ( VAR4 => VAR4 . VAR5 == VAR10 . VAR5 ) ; VAR11 = VAR1 . VAR12 . VAR3 ( VAR4 => VAR4 . VAR5 == VAR11 . VAR5 ) ; VAR13 = VAR1 . VAR12 . VAR3 ( VAR4 => VAR4 . VAR5 == VAR13 . VAR5 ) ; VAR14 = ( RequiredAk2Derived ) VAR1 . VAR9 . VAR3 ( VAR4 => VAR4 . VAR5 == VAR14 . VAR5 ) ; VAR15 = ( RequiredAk2MoreDerived ) VAR1 . VAR9 . VAR3 ( VAR4 => VAR4 . VAR5 == VAR15 . VAR5 ) ;
VAR0 . IsUnique = false ; Assert . Same ( VAR1 , VAR0 . PrincipalEntityType ) ; Assert . Same ( VAR2 , VAR0 . PrincipalKey . Properties . Single ( ) ) ; Assert . Same ( VAR3 , VAR0 . Properties . Single ( ) ) ; Assert . False ( VAR0 . IsUnique ) ; Assert . Same ( VAR4 , VAR0 . PrincipalKey ) ;
Assert . Equal ( LITERAL , VAR0 . VAR1 ) ; Assert . Equal ( LITERAL , VAR0 . VAR2 ) ; Assert . False ( VAR3 . Property ( VAR4 => VAR4 . VAR5 ) . IsModified ) ; Assert . True ( VAR3 . Property ( VAR4 => VAR4 . VAR1 ) . IsModified ) ; Assert . True ( VAR3 . Property ( VAR4 => VAR4 . VAR2 ) . IsModified ) ; var VAR6 = VAR3 . GetInfrastructure ( ) ; Assert . False ( VAR6 . IsConceptualNull ( VAR3 . Property ( VAR4 => VAR4 . VAR5 ) . Metadata ) ) ; Assert . True ( VAR6 . IsConceptualNull ( VAR3 . Property ( VAR4 => VAR4 . VAR1 ) . Metadata ) ) ; Assert . False ( VAR6 . IsConceptualNull ( VAR3 . Property ( VAR4 => VAR4 . VAR2 ) . Metadata ) ) ;
Assert . Equal ( LITERAL , VAR0 . SchemaName ) ; Assert . Equal ( LITERAL , VAR0 . DataType ) ; Assert . Equal ( 1 , VAR0 . IncrementBy ) ; Assert . False ( VAR0 . IsCyclic ) ; Assert . Null ( VAR0 . Max ) ; Assert . Null ( VAR0 . Min ) ; Assert . Null ( VAR0 . Start ) ;
Assert . True ( await VAR0 . OpenAsync ( VAR1 ) ) ; Assert . Equal ( 1 , VAR0 . DbConnections . Count ) ; var VAR2 = VAR0 . DbConnections [ 0 ] ; Assert . Equal ( 1 , VAR2 . OpenAsyncCount ) ; Assert . False ( await VAR0 . OpenAsync ( VAR1 ) ) ; Assert . False ( await VAR0 . OpenAsync ( VAR1 ) ) ; Assert . Equal ( 1 , VAR2 . OpenAsyncCount ) ;
Assert . False ( await VAR0 . OpenAsync ( VAR1 ) ) ; Assert . False ( await VAR0 . OpenAsync ( VAR1 ) ) ; Assert . Equal ( 1 , VAR2 . OpenAsyncCount ) ;
Assert . Equal ( VAR0 . Index , 0 ) ; Assert . Equal ( VAR0 . Name , LITERAL ) ; Assert . Equal ( VAR0 . ParameterType , typeof ( string ) ) ; VAR0 . Index = LITERAL ; VAR0 . Name = LITERAL ; VAR0 . ParameterType = typeof ( int ) ; Assert . Equal ( VAR0 . Index , LITERAL ) ; Assert . Equal ( VAR0 . Name , LITERAL ) ; Assert . Equal ( VAR0 . ParameterType , typeof ( int ) ) ;
Assert . Equal ( false , VAR0 . IsNullable ) ; Assert . Equal ( DbType . Int32 , VAR0 . DbType ) ; VAR0 = VAR1 . DbConnections [ 0 ] . DbCommands [ 0 ] . Parameters [ 1 ] ; Assert . Equal ( LITERAL , VAR0 . ParameterName ) ; Assert . Equal ( LITERAL , VAR0 . Value ) ; Assert . Equal ( ParameterDirection . Input , VAR0 . Direction ) ; Assert . Equal ( true , VAR0 . IsNullable ) ;
Assert . Equal ( LITERAL , VAR0 . Sqlite ( ) . TableName ) ; Assert . Null ( VAR0 . FindProperty ( LITERAL ) . Sqlite ( ) . ColumnType ) ; Assert . Equal ( typeof ( string ) , VAR0 . FindProperty ( LITERAL ) . ClrType ) ; Assert . Equal ( LITERAL , VAR0 . FindProperty ( LITERAL ) . Sqlite ( ) . ColumnType ) ;
Assert . Equal ( LITERAL , VAR0 . Metadata . Sqlite ( ) . TableName ) ; Assert . True ( VAR0 . Sqlite ( ConfigurationSource . DataAnnotation ) . ToTable ( LITERAL ) ) ; Assert . Equal ( LITERAL , VAR0 . Metadata . Sqlite ( ) . TableName ) ; Assert . False ( VAR0 . Sqlite ( ConfigurationSource . Convention ) . ToTable ( LITERAL ) ) ; Assert . Equal ( LITERAL , VAR0 . Metadata . Sqlite ( ) . TableName ) ;
Assert . Null ( VAR0 . Sqlite ( ) . ColumnType ) ; Assert . Null ( ( ( IProperty ) VAR0 ) . Sqlite ( ) . ColumnType ) ; VAR0 . Relational ( ) . ColumnType = LITERAL ; Assert . Equal ( LITERAL , VAR0 . Sqlite ( ) . ColumnType ) ; Assert . Equal ( LITERAL , ( ( IProperty ) VAR0 ) . Sqlite ( ) . ColumnType ) ; VAR0 . Sqlite ( ) . ColumnType = LITERAL ; Assert . Equal ( LITERAL , VAR0 . Sqlite ( ) . ColumnType ) ; Assert . Equal ( LITERAL , ( ( IProperty ) VAR0 ) . Sqlite ( ) . ColumnType ) ; VAR0 . Sqlite ( ) . ColumnType = null ; Assert . Null ( VAR0 . Sqlite ( ) . ColumnType ) ; Assert . Null ( ( ( IProperty ) VAR0 ) . Sqlite ( ) . ColumnType ) ;
Assert . Equal ( LITERAL , VAR0 . Sqlite ( ) . VAR1 ) ; Assert . Equal ( LITERAL , ( ( IForeignKey ) VAR0 ) . Sqlite ( ) . VAR1 ) ; VAR0 . Relational ( ) . VAR1 = LITERAL ; Assert . Equal ( LITERAL , VAR0 . Sqlite ( ) . VAR1 ) ; Assert . Equal ( LITERAL , ( ( IForeignKey ) VAR0 ) . Sqlite ( ) . VAR1 ) ; VAR0 . Sqlite ( ) . VAR1 = LITERAL ; Assert . Equal ( LITERAL , VAR0 . Sqlite ( ) . VAR1 ) ; Assert . Equal ( LITERAL , ( ( IForeignKey ) VAR0 ) . Sqlite ( ) . VAR1 ) ; VAR0 . Sqlite ( ) . VAR1 = null ; Assert . Equal ( LITERAL , VAR0 . Sqlite ( ) . VAR1 ) ; Assert . Equal ( LITERAL , ( ( IForeignKey ) VAR0 ) . Sqlite ( ) . VAR1 ) ;
Assert . Equal ( PropertyValueBehavior . UseValue , VAR0 . BeforeSaveBehavior ) ; Assert . Equal ( PropertyValueBehavior . UseValue , VAR0 . AfterSaveBehavior ) ; VAR0 . ValueGenerated = ValueGenerated . OnAddOrUpdate ; Assert . Equal ( PropertyValueBehavior . Ignore , VAR0 . BeforeSaveBehavior ) ; Assert . Equal ( PropertyValueBehavior . Ignore , VAR0 . AfterSaveBehavior ) ; VAR0 . BeforeSaveBehavior = PropertyValueBehavior . UseValue ; Assert . Equal ( PropertyValueBehavior . UseValue , VAR0 . BeforeSaveBehavior ) ; Assert . Equal ( PropertyValueBehavior . Ignore , VAR0 . AfterSaveBehavior ) ; VAR0 . AfterSaveBehavior = PropertyValueBehavior . UseValue ; Assert . Equal ( PropertyValueBehavior . UseValue , VAR0 . BeforeSaveBehavior ) ; Assert . Equal ( PropertyValueBehavior . UseValue , VAR0 . AfterSaveBehavior ) ;
var VAR0 = new BaseTypeConvention ( VAR1 : false ) ; var VAR2 = new BaseTypeConvention ( VAR1 : true ) ; var VAR3 = new BaseTypeConvention ( VAR1 : false ) ; VAR4 . BaseEntityTypeSetConventions . Add ( VAR0 ) ; VAR4 . BaseEntityTypeSetConventions . Add ( VAR2 ) ; VAR4 . BaseEntityTypeSetConventions . Add ( VAR3 ) ;
Assert . False ( ( ( IProperty ) VAR0 ) . IsReadOnlyAfterSave ) ; Assert . False ( ( ( IProperty ) VAR0 ) . IsReadOnlyBeforeSave ) ; VAR0 . ValueGenerated = ValueGenerated . OnAddOrUpdate ; Assert . True ( ( ( IProperty ) VAR0 ) . IsReadOnlyAfterSave ) ; Assert . True ( ( ( IProperty ) VAR0 ) . IsReadOnlyBeforeSave ) ; VAR0 . IsReadOnlyBeforeSave = false ; Assert . True ( ( ( IProperty ) VAR0 ) . IsReadOnlyAfterSave ) ; Assert . False ( ( ( IProperty ) VAR0 ) . IsReadOnlyBeforeSave ) ; VAR0 . IsReadOnlyAfterSave = false ; Assert . False ( ( ( IProperty ) VAR0 ) . IsReadOnlyAfterSave ) ; Assert . False ( ( ( IProperty ) VAR0 ) . IsReadOnlyBeforeSave ) ;
Assert . Same ( VAR0 , new KeyConvention ( ) . Apply ( VAR0 ) ) ; Assert . Equal ( ValueGenerated . Never , ( ( IProperty ) VAR1 ) . ValueGenerated ) ; VAR2 . RemoveForeignKey ( VAR0 . Metadata , ConfigurationSource . Convention ) ; Assert . True ( new KeyConvention ( ) . Apply ( VAR2 , ( Key ) null ) ) ;
Assert . True ( new KeyConvention ( ) . Apply ( VAR0 , null ) ) ; var VAR1 = VAR0 . Metadata . Properties ; Assert . True ( VAR1 [ 0 ] . RequiresValueGenerator ( ) ) ; Assert . False ( VAR1 [ 1 ] . RequiresValueGenerator ( ) ) ; Assert . Equal ( ValueGenerated . OnAdd , VAR1 [ 0 ] . ValueGenerated ) ; Assert . Equal ( ValueGenerated . Never , VAR1 [ 1 ] . ValueGenerated ) ;
Assert . NotNull ( VAR0 [ 0 ] = VAR1 . GetService < IInMemoryStoreSource > ( ) ) ; Assert . NotNull ( VAR0 [ 1 ] = VAR1 . GetService < ILoggerFactory > ( ) ) ; Assert . NotNull ( VAR0 [ LITERAL ] = VAR1 . GetService < IMemoryCache > ( ) ) ; Assert . Same ( VAR2 , VAR1 . GetService < IDbContextOptions > ( ) ) ; Assert . NotNull ( VAR1 . GetService < ILogger < Random > > ( ) ) ; Assert . Same ( VAR0 [ 0 ] , VAR3 . GetService < IInMemoryStoreSource > ( ) ) ;
Assert . NotNull ( VAR0 [ 0 ] = VAR1 . GetService < IInMemoryStoreSource > ( ) ) ; Assert . NotNull ( VAR0 [ 1 ] = VAR1 . GetService < ILoggerFactory > ( ) ) ; Assert . NotNull ( VAR0 [ LITERAL ] = VAR1 . GetService < IMemoryCache > ( ) ) ; Assert . Same ( VAR2 , VAR1 . GetService < IDbContextOptions > ( ) ) ; Assert . NotNull ( VAR1 . GetService < ILogger < Random > > ( ) ) ; Assert . Same ( VAR0 [ 0 ] , VAR3 . GetService < IInMemoryStoreSource > ( ) ) ;
VAR0 . VAR1 = VAR1 ; VAR0 . VAR2 = VAR2 || ! VAR0 . VAR3 . Any ( ) ; VAR4 = null ; VAR5 = null ; VAR6 = false ; VAR1 = null ;
VAR0 . VAR1 = VAR1 ; VAR0 . VAR2 = VAR2 || ! VAR0 . VAR3 . Any ( ) ; VAR4 = null ; VAR5 = null ; VAR6 = false ; VAR1 = null ; VAR7 = null ; ClearTables ( ) ; ClearProjection ( ) ; ClearOrderBy ( ) ; VAR8 . Add ( VAR0 ) ; VAR1 = VAR0 . Alias ;
Check . NotNull ( VAR0 , nameof ( VAR0 ) ) ; VAR1 = VAR2 . Context . GetType ( ) ; VAR3 = VAR4 ; VAR5 = VAR6 ; VAR7 = VAR8 ; VAR9 = VAR10 ; VAR11 = VAR12 ; VAR13 = VAR14 ; VAR15 = VAR16 ; VAR17 = VAR0 . InvariantName ;
Assert . True ( VAR0 . RequiresValueGenerator ) ; Assert . False ( VAR1 . HasValueGenerator ( ( VAR2 , VAR3 ) => new CustomValueGenerator1 ( ) , ConfigurationSource . Convention ) ) ; Assert . IsType < CustomValueGenerator2 > ( VAR0 . GetValueGeneratorFactory ( ) ( null , null ) ) ; Assert . True ( VAR0 . RequiresValueGenerator ) ;
Assert . True ( VAR0 . RequiresValueGenerator ) ; Assert . True ( VAR1 . HasValueGenerator ( ( VAR2 , VAR3 ) => new CustomValueGenerator2 ( ) , ConfigurationSource . Explicit ) ) ; Assert . IsType < CustomValueGenerator2 > ( VAR0 . GetValueGeneratorFactory ( ) ( null , null ) ) ; Assert . True ( VAR0 . RequiresValueGenerator ) ;
Assert . Equal ( VAR0 , VAR1 . GetField ( ) ) ; var VAR2 = VAR1 . FieldInfo ; Assert . Equal ( VAR0 , VAR2 . Name ) ; Assert . Same ( VAR3 ?? ( MemberInfo ) VAR2 , VAR1 . MemberInfo ) ; VAR1 . SetField ( null , ConfigurationSource . Explicit ) ; Assert . Null ( VAR1 . GetField ( ) ) ;
var VAR0 = VAR1 . AddProperty ( LITERAL , typeof ( int ) , shadow : false ) ; VAR0 . ValueGenerated = VAR2 ? ValueGenerated . OnAdd : ValueGenerated . Never ; VAR0 . Relational ( ) . ColumnName = LITERAL ; VAR1 . GetOrSetPrimaryKey ( VAR0 ) ; var VAR3 = VAR1 . AddProperty ( LITERAL , typeof ( string ) , shadow : false ) ;
var VAR0 = VAR1 . GetFieldInfo ( ) ; Assert . Equal ( VAR2 , VAR0 . Name ) ; Assert . Same ( VAR3 ?? ( MemberInfo ) VAR0 , VAR1 . MemberInfo ) ; VAR1 . SetField ( null , ConfigurationSource . Explicit ) ; Assert . Null ( VAR1 . GetField ( ) ) ; Assert . Null ( VAR1 . GetFieldInfo ( ) ) ;
var VAR0 = VAR1 . GetForeignKeys ( ) . Single ( VAR2 => VAR2 . DependentToPrincipal == null ) ; var VAR3 = VAR1 . GetForeignKeys ( ) . Single ( VAR2 => VAR2 != VAR0 ) ; Assert . Same ( VAR3 . DependentToPrincipal , VAR1 . GetNavigations ( ) . Single ( ) ) ; Assert . Same ( VAR3 . PrincipalToDependent , VAR4 . GetNavigations ( ) . Single ( ) ) ; AssertEqual ( VAR5 , VAR4 . GetProperties ( ) ) ; VAR6 . Add ( VAR3 . Properties . Single ( ) ) ;
var VAR0 = VAR1 . GetForeignKeys ( ) . Single ( ) ; Assert . Equal ( VAR2 . Properties , VAR0 . Properties ) ; Assert . Equal ( VAR2 . PrincipalKey . Properties , VAR0 . PrincipalKey . Properties ) ; Assert . Equal ( LITERAL , VAR1 . GetNavigations ( ) . Single ( ) . Name ) ; Assert . Equal ( LITERAL , VAR3 . GetNavigations ( ) . Single ( ) . Name ) ; Assert . Same ( VAR0 , VAR1 . GetNavigations ( ) . Single ( ) . ForeignKey ) ; Assert . Same ( VAR0 , VAR3 . GetNavigations ( ) . Single ( ) . ForeignKey ) ;
var VAR0 = VAR1 . GetForeignKeys ( ) . Single ( VAR2 => VAR2 != VAR3 ) ; Assert . Same ( VAR1 . FindProperty ( nameof ( Customer . Id ) ) , VAR0 . Properties . Single ( ) ) ; Assert . Empty ( VAR1 . GetNavigations ( ) . Where ( VAR4 => VAR4 . ForeignKey == VAR0 ) ) ; Assert . Empty ( VAR5 . GetNavigations ( ) . Where ( VAR4 => VAR4 . ForeignKey == VAR0 ) ) ;
var VAR0 = CreateModelBuilder ( ) ; VAR0 . Entity < SRelated > ( ) ; Validate ( VAR0 . Model ) ; Assert . True ( GetProperty < OKeyBase > ( VAR0 , nameof ( OKeyBase . VAR1 ) ) . IsPrimaryKey ( ) ) ; Assert . True ( GetProperty < DODerived > ( VAR0 , nameof ( DODerived . VAR1 ) ) . IsPrimaryKey ( ) ) ;
Assert . True ( VAR0 . Ignore ( Order . VAR1 . Name , ConfigurationSource . DataAnnotation ) ) ; Assert . Null ( VAR2 . FindProperty ( Order . VAR1 . Name ) ) ; Assert . NotNull ( VAR0 . Property ( Order . VAR1 . Name , typeof ( int ) , ConfigurationSource . Explicit ) ) ; Assert . False ( VAR0 . Ignore ( Order . VAR1 . Name , ConfigurationSource . Convention ) ) ; Assert . False ( VAR0 . Ignore ( Order . VAR1 . Name , ConfigurationSource . DataAnnotation ) ) ; Assert . NotNull ( VAR2 . FindProperty ( Order . VAR1 . Name ) ) ;
AssertReceivedMessagesConsistent ( VAR0 , VAR1 ) ; AssertReceivedMessagesConsistent ( VAR2 , VAR3 , VAR4 ) ; AssertReceivedMessagesConsistent ( VAR5 ) ; AssertSentMessagesConsistent ( VAR0 , VAR3 , VAR4 ) ; AssertSentMessagesConsistent ( VAR2 , VAR1 ) ; AssertSentMessagesConsistent ( VAR5 ) ; VAR1 . ToUsername = null ;
var VAR0 = new VAR1 { VAR2 = LITERAL } ; var VAR3 = new VAR4 { VAR2 = LITERAL } ; VAR5 . Entry ( VAR0 ) . State = VAR6 ; VAR3 . VAR7 = VAR0 . VAR2 ; VAR3 . VAR1 = VAR0 ; VAR0 . VAR8 . Add ( VAR3 ) ;
var VAR0 = new VAR1 { VAR2 = LITERAL } ; var VAR3 = new VAR4 { VAR2 = LITERAL } ; VAR5 . Entry ( VAR0 ) . State = VAR6 ; VAR3 . VAR1 = VAR0 ; VAR0 . VAR7 . Add ( VAR3 ) ;
var VAR0 = new VAR1 { VAR2 = LITERAL } ; var VAR3 = new VAR4 { VAR2 = LITERAL } ; VAR5 . Entry ( VAR0 ) . State = VAR6 ; VAR3 . VAR7 = VAR0 . VAR2 ; VAR3 . VAR1 = VAR0 ;
var VAR0 = new VAR1 { VAR2 = LITERAL } ; var VAR3 = new VAR4 { VAR2 = LITERAL } ; VAR5 . Entry ( VAR3 ) . State = VAR6 ; VAR3 . VAR7 = VAR0 . VAR2 ; VAR0 . VAR4 = VAR3 ;
var VAR0 = new VAR1 { VAR2 = LITERAL } ; var VAR3 = new VAR4 { VAR2 = LITERAL } ; VAR5 . Entry ( VAR3 ) . State = VAR6 ; VAR3 . VAR7 = VAR0 . VAR2 ; VAR3 . VAR1 = VAR0 ;
var VAR0 = new VAR1 { VAR2 = LITERAL } ; var VAR3 = new VAR4 { VAR2 = LITERAL } ; VAR5 . Entry ( VAR0 ) . State = VAR6 ; VAR3 . VAR7 = VAR0 . VAR2 ; VAR0 . VAR4 = VAR3 ;
var VAR0 = VAR1 . StartTrackingFromQuery ( VAR2 , new Category { VAR3 = LITERAL , VAR4 = LITERAL } , new ValueBuffer ( new object [  ] { LITERAL , LITERAL , LITERAL } ) ) ; Assert . True ( VAR1 . IsSingleQueryMode ( VAR2 ) ) ; VAR0 . SetEntityState ( EntityState . Modified ) ; Assert . False ( VAR1 . IsSingleQueryMode ( VAR2 ) ) ;
Check . NotEmpty ( VAR0 , nameof ( VAR0 ) ) ; VAR1 = VAR2 ; VAR3 = VAR4 ; VAR5 = VAR6 ; VAR7 = VAR8 ; VAR9 = VAR0 ; VAR10 = new LazyRef < ILogger > ( ( ) => VAR1 . CreateCommandsLogger ( ) ) ; var VAR11 = new StartupInvoker ( VAR6 , VAR8 , VAR0 ) ;
var VAR0 = VAR1 ; VAR1 = InferUnicodeFromColumn ( VAR2 . Operand ) ?? VAR1 ; Visit ( VAR2 . Operand ) ; VAR3 . Append ( LITERAL ) ; Visit ( VAR2 . SubQuery ) ; VAR1 = VAR0 ;
Assert . Null ( VAR0 . Features ) ; Assert . Same ( VAR1 , VAR2 . Review ) ; Assert . Same ( VAR2 , VAR1 . Features . Single ( ) ) ; Assert . Null ( VAR3 . Features ) ; Assert . Null ( VAR4 . Features ) ;
Assert . NotNull ( VAR0 [ 0 ] = VAR1 . GetService < IInMemoryStore > ( ) ) ; Assert . NotNull ( VAR0 [ 1 ] = VAR1 . GetService < ILoggerFactory > ( ) ) ; Assert . NotNull ( VAR0 [ LITERAL ] = VAR1 . GetService < IMemoryCache > ( ) ) ; Assert . Same ( VAR2 , VAR1 . GetService < IDbContextOptions > ( ) ) ; Assert . NotNull ( VAR1 . GetService < ILogger < Random > > ( ) ) ; Assert . Same ( VAR0 [ 0 ] , VAR3 . GetService < IInMemoryStore > ( ) ) ;
Assert . Null ( VAR0 . VAR1 ) ; Assert . Null ( VAR0 . VAR2 ) ; VAR3 . VAR4 = new List < ChangedOnlyNotificationEntity > ( ) ; var VAR5 = VAR6 . EntityType . FindNavigation ( LITERAL ) ; Assert . Same ( VAR5 , VAR0 . VAR1 ) ; Assert . Same ( VAR5 , VAR0 . VAR2 ) ;
var VAR0 = new ModificationCommand ( LITERAL , null , new ParameterNameGenerator ( ) , VAR1 => VAR1 . TestProvider ( ) ) ; VAR0 . AddEntry ( VAR2 ) ; var VAR3 = VAR4 . GetOrCreateEntry ( new object ( ) ) ; VAR3 [ VAR5 ] = LITERAL ; VAR3 . SetEntityState ( EntityState . Deleted ) ; var VAR6 = new ModificationCommand ( LITERAL , null , new ParameterNameGenerator ( ) , VAR1 => VAR1 . TestProvider ( ) ) ;
var VAR0 = new ModificationCommand ( LITERAL , null , new ParameterNameGenerator ( ) , VAR1 => VAR1 . TestProvider ( ) ) ; VAR0 . AddEntry ( VAR2 ) ; var VAR3 = VAR4 . GetOrCreateEntry ( new object ( ) ) ; VAR3 [ VAR5 ] = LITERAL ; VAR3 . SetEntityState ( EntityState . Modified ) ; var VAR6 = new ModificationCommand ( LITERAL , null , new ParameterNameGenerator ( ) , VAR1 => VAR1 . TestProvider ( ) ) ; VAR6 . AddEntry ( VAR3 ) ; var VAR7 = VAR4 . GetOrCreateEntry ( new object ( ) ) ; VAR7 [ VAR5 ] = LITERAL ; VAR7 . SetEntityState ( EntityState . Deleted ) ; var VAR8 = new ModificationCommand ( LITERAL , null , new ParameterNameGenerator ( ) , VAR1 => VAR1 . TestProvider ( ) ) ;
var VAR0 = new Dictionary < string , string > ( ) ; var VAR1 = new Dictionary < string , string > ( ) ; var VAR2 = new Dictionary < string , string > ( ) ; var VAR3 = new Dictionary < string , List < string > > ( ) ; var VAR4 = new Dictionary < string , List < string > > ( ) ;
Assert . True ( VAR0 . Relational ( ConfigurationSource . Convention ) . Name ( LITERAL ) ) ; Assert . Equal ( LITERAL , VAR0 . Metadata . Relational ( ) . Name ) ; Assert . True ( VAR0 . Relational ( ConfigurationSource . DataAnnotation ) . Name ( LITERAL ) ) ; Assert . Equal ( LITERAL , VAR0 . Metadata . Relational ( ) . Name ) ; Assert . False ( VAR0 . Relational ( ConfigurationSource . Convention ) . Name ( LITERAL ) ) ;
Assert . True ( VAR0 . SqlServer ( ConfigurationSource . Convention ) . Clustered ( true ) ) ; Assert . True ( VAR0 . Metadata . SqlServer ( ) . IsClustered ) ; Assert . True ( VAR0 . SqlServer ( ConfigurationSource . DataAnnotation ) . Clustered ( false ) ) ; Assert . False ( VAR0 . Metadata . SqlServer ( ) . IsClustered ) ; Assert . False ( VAR0 . SqlServer ( ConfigurationSource . Convention ) . Clustered ( true ) ) ;
Check . NotNull ( VAR0 , nameof ( VAR0 ) ) ; VAR1 = VAR2 ; VAR3 = VAR4 ; VAR5 = VAR6 ; VAR7 = VAR8 ; VAR9 = VAR0 ;
Check . NotNull ( VAR0 , nameof ( VAR0 ) ) ; VAR1 = VAR2 ; VAR3 = VAR4 ; VAR5 = VAR6 ; VAR7 = VAR8 ; VAR9 = VAR10 ; VAR11 = VAR12 ; VAR13 = VAR0 . GetType ( ) ;
VAR0 . Attach ( VAR1 , behavior : GraphBehavior . SingleObject ) ; Assert . Equal ( LITERAL , VAR1 . VAR2 ) ; Assert . Same ( VAR1 , VAR3 . VAR4 . Single ( ) ) ; Assert . Same ( VAR5 , VAR1 . VAR6 ) ; Assert . Same ( VAR1 , VAR5 . VAR4 . Single ( ) ) ; Assert . Equal ( EntityState . Detached , VAR0 . Entry ( VAR3 ) . State ) ; Assert . Equal ( EntityState . Unchanged , VAR0 . Entry ( VAR1 ) . State ) ; VAR0 . Attach ( VAR3 , behavior : GraphBehavior . SingleObject ) ;
Assert . True ( SqliteTableSelectionSetExtensions . Allows ( VAR0 , LITERAL ) ) ; var VAR1 = VAR0 . Tables . First ( ) ; var VAR2 = VAR0 . Tables . Skip ( 1 ) . First ( ) ; var VAR3 = VAR0 . Tables . Last ( ) ; Assert . True ( VAR1 . IsMatched ) ; Assert . False ( VAR2 . IsMatched ) ; Assert . False ( VAR3 . IsMatched ) ; Assert . True ( SqliteTableSelectionSetExtensions . Allows ( VAR0 , LITERAL ) ) ;
Assert . Equal ( 1 , VAR0 . GetValue ( VAR1 , ValueSource . Original ) ) ; Assert . Equal ( LITERAL , VAR0 . GetValue ( VAR2 , ValueSource . Original ) ) ; Assert . Equal ( 1 , VAR0 [ VAR1 ] ) ; Assert . Equal ( LITERAL , VAR0 [ VAR2 ] ) ; VAR0 [ VAR2 ] = LITERAL ; Assert . Equal ( 1 , VAR0 . GetValue ( VAR1 , ValueSource . Original ) ) ; Assert . Equal ( LITERAL , VAR0 . GetValue ( VAR2 , ValueSource . Original ) ) ; Assert . Equal ( 1 , VAR0 [ VAR1 ] ) ; Assert . Equal ( LITERAL , VAR0 [ VAR2 ] ) ; VAR0 . SetValue ( VAR1 , LITERAL , ValueSource . Original ) ; VAR0 . SetValue ( VAR2 , LITERAL , ValueSource . Original ) ; Assert . Equal ( LITERAL , VAR0 . GetValue ( VAR1 , ValueSource . Original ) ) ; Assert . Equal ( LITERAL , VAR0 . GetValue ( VAR2 , ValueSource . Original ) ) ;
VAR0 . SetValue ( VAR1 , LITERAL , ValueSource . Original ) ; VAR0 . AcceptChanges ( ) ; Assert . Equal ( EntityState . Unchanged , VAR0 . EntityState ) ; Assert . Equal ( LITERAL , VAR0 [ VAR1 ] ) ; Assert . Equal ( LITERAL , VAR0 . GetValue ( VAR1 , ValueSource . Original ) ) ;
Assert . Equal ( LITERAL , VAR0 . GetValue ( VAR1 ) ) ; VAR2 . VAR3 = LITERAL ; Assert . Equal ( LITERAL , VAR0 . GetValue ( VAR1 , ValueSource . RelationshipSnapshot ) ) ; Assert . Equal ( LITERAL , VAR0 . GetValue ( VAR1 , ValueSource . Original ) ) ; Assert . Equal ( LITERAL , VAR0 . GetValue ( VAR1 ) ) ;
VAR0 . Value . LogVerbose ( CommandsStrings . WritingMigration ( VAR1 ) ) ; Directory . CreateDirectory ( VAR2 ) ; File . WriteAllText ( VAR1 , VAR3 . MigrationCode ) ; File . WriteAllText ( VAR4 , VAR3 . MetadataCode ) ; VAR0 . Value . LogVerbose ( CommandsStrings . WritingSnapshot ( VAR5 ) ) ;
var VAR0 = VAR1 . AddProperty ( typeof ( Duck ) . GetProperty ( nameof ( Duck . VAR2 ) ) ) ; VAR1 . AddProperty ( typeof ( Duck ) . GetProperty ( nameof ( Duck . VAR3 ) ) ) ; VAR1 . AddProperty ( typeof ( Duck ) . GetProperty ( nameof ( Duck . VAR4 ) ) ) ; VAR1 . AddProperty ( typeof ( Duck ) . GetProperty ( nameof ( Duck . VAR5 ) ) ) ; VAR1 . AddProperty ( typeof ( Duck ) . GetProperty ( nameof ( Duck . VAR6 ) ) ) ;
Assert . True ( VAR0 . ClrType ( typeof ( int ) , ConfigurationSource . DataAnnotation ) ) ; Assert . Equal ( typeof ( int ) , VAR1 . ClrType ) ; Assert . True ( VAR0 . ClrType ( typeof ( string ) , ConfigurationSource . DataAnnotation ) ) ; Assert . Equal ( typeof ( string ) , VAR1 . ClrType ) ; Assert . False ( VAR0 . ClrType ( typeof ( int ) , ConfigurationSource . Convention ) ) ; Assert . Equal ( typeof ( string ) , VAR1 . ClrType ) ; Assert . True ( VAR0 . ClrType ( typeof ( string ) , ConfigurationSource . Convention ) ) ;
VAR0 . Append ( LITERAL ) ; Visit ( VAR1 . Left ) ; VAR0 . Append ( LITERAL ) ; Visit ( VAR1 . Right ) ; VAR0 . Append ( LITERAL ) ;
Check . NotNull ( VAR0 , nameof ( VAR0 ) ) ; VAR1 = VAR2 ; VAR3 = VAR4 ; VAR5 = VAR6 ; VAR7 = VAR0 ;
var VAR0 = VAR1 . ChangeTracker . GetInfrastructure ( ) . CreateNewEntry ( VAR2 ) ; VAR3 = ( T ) VAR0 . Entity ; VAR0 [ VAR4 ] = LITERAL ; VAR0 [ VAR5 ] = LITERAL ; VAR0 . SetEntityState ( EntityState . Added ) ;
var VAR0 = new Model ( ) ; var VAR1 = new EntityType ( LITERAL , VAR0 ) ; var VAR2 = VAR1 . AddProperty ( LITERAL , typeof ( int ) ) ; var VAR3 = VAR1 . AddKey ( VAR2 ) ; var VAR4 = new EntityType ( LITERAL , VAR0 ) ;
var VAR0 = new Model ( ) ; var VAR1 = new EntityType ( LITERAL , VAR0 ) ; var VAR2 = VAR1 . AddProperty ( LITERAL , typeof ( int ) ) ; var VAR3 = VAR1 . AddProperty ( LITERAL , typeof ( int ) ) ; var VAR4 = VAR1 . AddKey ( new [ ] { VAR2 , VAR3 } ) ; var VAR5 = new EntityType ( LITERAL , VAR0 ) ; var VAR6 = VAR5 . AddProperty ( LITERAL , typeof ( int ) ) ; var VAR7 = VAR5 . AddKey ( VAR6 ) ; var VAR8 = new EntityType ( LITERAL , VAR0 ) ; var VAR9 = VAR8 . AddProperty ( LITERAL , typeof ( int ) ) ; var VAR10 = VAR8 . AddProperty ( LITERAL , typeof ( int ) ) ; var VAR11 = VAR8 . AddKey ( VAR9 ) ;
Assert . Same ( VAR0 , VAR1 . TryGetEntry ( new SimpleKeyValue < int > ( VAR0 . EntityType . FindPrimaryKey ( ) , LITERAL ) ) ) ; VAR2 . VAR3 = LITERAL ; VAR4 . DetectChanges ( VAR0 ) ; Assert . Equal ( LITERAL , VAR0 . RelationshipsSnapshot [ VAR0 . EntityType . FindProperty ( LITERAL ) ] ) ; Assert . Same ( VAR0 , VAR1 . TryGetEntry ( new SimpleKeyValue < int > ( VAR0 . EntityType . FindPrimaryKey ( ) , LITERAL ) ) ) ;
var VAR0 = new Model ( ) ; var VAR1 = CreateModelBuilder ( VAR0 ) ; VAR1 . Entity < Customer > ( ) ; VAR1 . Entity < Order > ( ) ; VAR1 . Ignore < OrderDetails > ( ) ; VAR1 . Ignore < CustomerDetails > ( ) ; var VAR2 = VAR0 . FindEntityType ( typeof ( Order ) ) ; var VAR3 = VAR0 . FindEntityType ( typeof ( Customer ) ) ; var VAR4 = VAR2 . FindProperty ( nameof ( Order . CustomerId ) ) ; var VAR5 = VAR3 . GetKeys ( ) . Single ( ) ; var VAR6 = VAR2 . GetKeys ( ) . Single ( ) ;
var VAR0 = new Model ( ) ; var VAR1 = CreateModelBuilder ( VAR0 ) ; VAR1 . Entity < PrincipalEntity > ( ) ; var VAR2 = VAR0 . FindEntityType ( typeof ( DependentEntity ) ) . GetForeignKeys ( ) . Single ( ) ; Assert . Equal ( LITERAL , VAR2 . Properties . Single ( ) . Name ) ; VAR1 . Entity < DependentEntity > ( ) . Property ( VAR3 => VAR3 . PrincipalEntityId ) ; var VAR4 = VAR0 . FindEntityType ( typeof ( DependentEntity ) ) . GetForeignKeys ( ) . Single ( ) ; Assert . Equal ( LITERAL , VAR4 . Properties . Single ( ) . Name ) ;
VAR0 . AddNavigation ( LITERAL , VAR1 , pointsToPrincipal : false ) ; Assert . Equal ( new [ ] { LITERAL } , VAR0 . GetNavigations ( ) . Select ( VAR2 => VAR2 . VAR3 ) . ToArray ( ) ) ; Assert . Equal ( new [ ] { LITERAL } , VAR4 . GetNavigations ( ) . Select ( VAR2 => VAR2 . VAR3 ) . ToArray ( ) ) ; var VAR5 = VAR6 . GetOrAddProperty ( Order . VAR7 ) ; var VAR8 = VAR6 . GetOrAddForeignKey ( VAR5 , VAR9 , VAR4 ) ; VAR4 . AddNavigation ( LITERAL , VAR8 , pointsToPrincipal : false ) ;
AssertEqual ( VAR0 , VAR1 . FindReferencingForeignKeys ( ) ) ; AssertEqual ( VAR2 , VAR3 . GetProperties ( ) , new PropertyComparer ( compareAnnotations : false ) ) ; AssertEqual ( VAR4 , VAR3 . GetKeys ( ) ) ; AssertEqual ( VAR5 , VAR3 . GetIndexes ( ) ) ; Assert . Equal ( VAR6 . Count ( ) , VAR3 . GetForeignKeys ( ) . Count ( ) ) ; Assert . Equal ( VAR0 . Count ( ) , VAR3 . FindReferencingForeignKeys ( ) . Count ( ) ) ;
Assert . Same ( VAR0 , VAR1 . RemoveAnnotation ( VAR0 ) ) ; Assert . Empty ( VAR1 . Annotations ) ; Assert . Null ( VAR1 . RemoveAnnotation ( VAR0 ) ) ; Assert . Null ( VAR1 [ LITERAL ] ) ; Assert . Null ( VAR1 . FindAnnotation ( LITERAL ) ) ;
Assert . Null ( VAR0 . StoreGeneratedAlways ) ; Assert . False ( ( ( IProperty ) VAR0 ) . StoreGeneratedAlways ) ; VAR0 . StoreGeneratedAlways = true ; Assert . True ( VAR0 . StoreGeneratedAlways . Value ) ; Assert . True ( ( ( IProperty ) VAR0 ) . StoreGeneratedAlways ) ; VAR0 . StoreGeneratedAlways = false ; Assert . False ( VAR0 . StoreGeneratedAlways . Value ) ; Assert . False ( ( ( IProperty ) VAR0 ) . StoreGeneratedAlways ) ; VAR0 . StoreGeneratedAlways = null ; Assert . Null ( VAR0 . StoreGeneratedAlways ) ; Assert . False ( ( ( IProperty ) VAR0 ) . StoreGeneratedAlways ) ;
Assert . Null ( VAR0 . GetEntityType ( typeof ( Post ) ) . FindNavigation ( LITERAL ) . ForeignKey . PrincipalToDependent ) ; Assert . Equal ( LITERAL , VAR0 . GetEntityType ( typeof ( Post ) ) . FindNavigation ( LITERAL ) . ForeignKey . Properties . First ( ) . Name ) ; Assert . Null ( VAR0 . GetEntityType ( typeof ( PostDetails ) ) . FindNavigation ( LITERAL ) . ForeignKey . PrincipalToDependent ) ; Assert . Equal ( LITERAL , VAR0 . GetEntityType ( typeof ( PostDetails ) ) . FindNavigation ( LITERAL ) . ForeignKey . Properties . First ( ) . Name ) ;
Assert . Null ( VAR0 . GetEntityType ( typeof ( Post ) ) . FindNavigation ( LITERAL ) . ForeignKey . PrincipalToDependent ) ; Assert . Equal ( LITERAL , VAR0 . GetEntityType ( typeof ( Post ) ) . FindNavigation ( LITERAL ) . ForeignKey . Properties . First ( ) . Name ) ; Assert . Null ( VAR0 . GetEntityType ( typeof ( Author ) ) . FindNavigation ( LITERAL ) . ForeignKey . PrincipalToDependent ) ; Assert . Equal ( LITERAL , VAR0 . GetEntityType ( typeof ( Author ) ) . FindNavigation ( LITERAL ) . ForeignKey . Properties . First ( ) . Name ) ;
var VAR0 = VAR1 . GetEntityType ( typeof ( Tomato ) ) ; var VAR2 = VAR1 . GetEntityType ( typeof ( Whoopper ) ) ; var VAR3 = VAR0 . GetForeignKeys ( ) . Single ( VAR4 => VAR4 . Properties . First ( ) . Name == LITERAL ) ; VAR0 . RemoveNavigation ( VAR3 . DependentToPrincipal . Name ) ; var VAR5 = VAR2 . GetPrimaryKey ( ) ;
var VAR0 = VAR1 . GetEntityType ( typeof ( Tomato ) ) ; var VAR2 = VAR1 . GetEntityType ( typeof ( Whoopper ) ) ; var VAR3 = VAR0 . GetProperty ( LITERAL ) ; var VAR4 = VAR0 . GetProperty ( LITERAL ) ; var VAR5 = VAR2 . GetProperty ( LITERAL ) ; var VAR6 = VAR2 . GetProperty ( LITERAL ) ; var VAR7 = VAR2 . GetPrimaryKey ( ) ;
var VAR0 = VAR1 . GetEntityType ( typeof ( Tomato ) ) ; var VAR2 = VAR1 . GetEntityType ( typeof ( Whoopper ) ) ; var VAR3 = VAR0 . GetProperty ( LITERAL ) ; var VAR4 = VAR0 . GetProperty ( LITERAL ) ; var VAR5 = VAR2 . GetProperty ( LITERAL ) ; var VAR6 = VAR2 . GetProperty ( LITERAL ) ; var VAR7 = VAR2 . GetPrimaryKey ( ) ; var VAR8 = VAR0 . GetPrimaryKey ( ) ;
var VAR0 = VAR1 . GetEntityType ( typeof ( Tomato ) ) ; var VAR2 = VAR1 . GetEntityType ( typeof ( Whoopper ) ) ; var VAR3 = VAR0 . GetProperty ( nameof ( Tomato . BurgerId1 ) ) ; var VAR4 = VAR0 . GetProperty ( nameof ( Tomato . BurgerId2 ) ) ; var VAR5 = VAR2 . GetPrimaryKey ( ) ;
var VAR0 = VAR1 . GetEntityType ( typeof ( DependentEntity ) ) . GetForeignKeys ( ) . Single ( ) ; Assert . Equal ( LITERAL , VAR0 . Properties . Single ( ) . Name ) ; VAR2 . Entity < DependentEntity > ( ) . Property ( VAR3 => VAR3 . PrincipalEntityId ) ; var VAR4 = VAR1 . GetEntityType ( typeof ( DependentEntity ) ) . GetForeignKeys ( ) . Single ( ) ;
var VAR0 = VAR1 . Model . GetEntityType ( typeof ( Customer ) ) ; var VAR2 = VAR0 . AddKey ( VAR0 . GetOrAddProperty ( Customer . NameProperty ) ) ; VAR1 . Entity < Customer > ( ) . HasKey ( VAR3 => VAR3 . Name ) ; Assert . Same ( VAR2 , VAR0 . GetKeys ( ) . Single ( ) ) ; Assert . Equal ( Customer . NameProperty . Name , VAR0 . GetPrimaryKey ( ) . Properties . Single ( ) . Name ) ; var VAR4 = ( IProperty ) VAR0 . GetProperty ( Customer . IdProperty ) ;
var VAR0 = ( IEntityType ) VAR1 . GetEntityType ( typeof ( Quarks ) ) ; Assert . True ( VAR0 . GetProperty ( LITERAL ) . IsNullable ) ; Assert . True ( VAR0 . GetProperty ( LITERAL ) . IsNullable ) ; Assert . True ( VAR0 . GetProperty ( LITERAL ) . IsNullable ) ;
var VAR0 = ( IEntityType ) VAR1 . GetEntityType ( typeof ( Quarks ) ) ; Assert . False ( VAR0 . GetProperty ( LITERAL ) . IsShadowProperty ) ; Assert . False ( VAR0 . GetProperty ( LITERAL ) . IsShadowProperty ) ; Assert . False ( VAR0 . GetProperty ( LITERAL ) . IsShadowProperty ) ; Assert . True ( VAR0 . GetProperty ( LITERAL ) . IsShadowProperty ) ; Assert . True ( VAR0 . GetProperty ( LITERAL ) . IsShadowProperty ) ; Assert . Equal ( - 1 , VAR0 . GetProperty ( LITERAL ) . GetShadowIndex ( ) ) ; Assert . Equal ( - 1 , VAR0 . GetProperty ( LITERAL ) . GetShadowIndex ( ) ) ; Assert . Equal ( - 1 , VAR0 . GetProperty ( LITERAL ) . GetShadowIndex ( ) ) ; Assert . Equal ( 0 , VAR0 . GetProperty ( LITERAL ) . GetShadowIndex ( ) ) ; Assert . Equal ( 1 , VAR0 . GetProperty ( LITERAL ) . GetShadowIndex ( ) ) ;
var VAR0 = VAR1 . GetEntityType ( typeof ( Order ) ) ; var VAR2 = VAR1 . GetEntityType ( typeof ( Customer ) ) ; var VAR3 = VAR2 . GetKeys ( ) . Single ( ) ; var VAR4 = VAR0 . GetKeys ( ) . Single ( ) ; VAR5 . Entity < Customer > ( ) . HasMany < Order > ( ) . WithOne ( VAR6 => VAR6 . Customer ) ; var VAR7 = VAR0 . GetNavigations ( ) . Single ( ) . ForeignKey ; Assert . Same ( VAR0 . GetProperty ( nameof ( Order . CustomerId ) ) , VAR7 . Properties . Single ( ) ) ;
Assert . Same ( VAR0 . GetProperty ( nameof ( Pickle . BurgerId ) ) , VAR1 . Properties . Single ( ) ) ; Assert . Equal ( nameof ( Pickle . BigMak ) , VAR1 . DependentToPrincipal . Name ) ; Assert . Null ( VAR1 . PrincipalToDependent ) ; Assert . NotSame ( VAR1 , VAR2 . GetNavigations ( ) . Single ( ) . ForeignKey ) ; Assert . Same ( VAR3 , VAR2 . GetKeys ( ) . Single ( ) ) ; Assert . Same ( VAR4 , VAR0 . GetKeys ( ) . Single ( ) ) ; Assert . Same ( VAR3 , VAR2 . GetPrimaryKey ( ) ) ; Assert . Same ( VAR4 , VAR0 . GetPrimaryKey ( ) ) ;
var VAR0 = VAR1 . GetEntityType ( typeof ( Order ) ) ; var VAR2 = VAR1 . GetEntityType ( typeof ( Customer ) ) ; var VAR3 = VAR0 . GetProperty ( LITERAL ) ; var VAR4 = VAR2 . GetProperty ( Customer . IdProperty . Name ) ;
var VAR0 = VAR1 . GetEntityType ( typeof ( Order ) ) ; var VAR2 = VAR1 . GetEntityType ( typeof ( Customer ) ) ; var VAR3 = VAR0 . GetProperty ( LITERAL ) ; var VAR4 = VAR2 . GetProperty ( Customer . IdProperty . Name ) ;
var VAR0 = VAR1 . GetEntityType ( typeof ( Pickle ) ) ; var VAR2 = VAR1 . GetEntityType ( typeof ( BigMak ) ) ; var VAR3 = VAR0 . GetProperty ( LITERAL ) ; var VAR4 = VAR2 . GetProperty ( LITERAL ) ;
var VAR0 = VAR1 . GetEntityType ( typeof ( Tomato ) ) ; var VAR2 = VAR1 . GetEntityType ( typeof ( Whoopper ) ) ; var VAR3 = VAR0 . GetProperty ( LITERAL ) ; var VAR4 = VAR0 . GetProperty ( LITERAL ) ; var VAR5 = VAR2 . GetProperty ( LITERAL ) ; var VAR6 = VAR2 . GetProperty ( LITERAL ) ; var VAR7 = VAR2 . GetPrimaryKey ( ) ;
var VAR0 = VAR1 . GetEntityType ( typeof ( DependentEntity ) ) . GetForeignKeys ( ) . Single ( ) ; Assert . Equal ( LITERAL , VAR0 . Properties . Single ( ) . Name ) ; VAR2 . Entity < DependentEntity > ( ) . Property ( VAR3 => VAR3 . PrincipalEntityId ) ; var VAR4 = VAR1 . GetEntityType ( typeof ( DependentEntity ) ) . GetForeignKeys ( ) . Single ( ) ;
var VAR0 = VAR1 . GetEntityType ( typeof ( CustomerDetails ) ) ; var VAR2 = VAR1 . GetEntityType ( typeof ( Customer ) ) ; var VAR3 = VAR2 . GetKeys ( ) . Single ( ) ; var VAR4 = VAR0 . GetKeys ( ) . Single ( ) ; VAR5 . Entity < Customer > ( ) . HasOne ( VAR6 => VAR6 . Details ) . WithOne ( VAR6 => VAR6 . Customer ) ; var VAR7 = VAR0 . GetNavigations ( ) . Single ( ) . ForeignKey ; Assert . Same ( VAR7 , VAR2 . GetNavigations ( ) . Single ( ) . ForeignKey ) ; Assert . Same ( VAR3 , VAR2 . GetKeys ( ) . Single ( ) ) ; Assert . Same ( VAR4 , VAR0 . GetKeys ( ) . Single ( ) ) ; Assert . Same ( VAR3 , VAR2 . GetPrimaryKey ( ) ) ; Assert . Same ( VAR4 , VAR0 . GetPrimaryKey ( ) ) ;
var VAR0 = VAR1 . GetEntityType ( typeof ( CustomerDetails ) ) ; var VAR2 = VAR1 . GetEntityType ( typeof ( Customer ) ) ; var VAR3 = VAR0 . GetProperty ( Customer . IdProperty . Name ) ; var VAR4 = VAR2 . GetKeys ( ) . Single ( ) ; var VAR5 = VAR0 . GetKeys ( ) . Single ( ) ;
var VAR0 = VAR1 . GetEntityType ( typeof ( AnEntity ) ) ; VAR0 . GetProperty ( LITERAL ) . SqlServer ( ) . GeneratedValueSql = LITERAL ; var VAR2 = SqlServerTestHelpers . Instance . CreateContextServices ( VAR1 ) . GetRequiredService < IValueGeneratorSelector > ( ) ; Assert . IsType < TemporaryGuidValueGenerator > ( VAR2 . Select ( VAR0 . GetProperty ( LITERAL ) , VAR0 ) ) ;
var VAR0 = VAR1 . Model . GetEntityType ( typeof ( VAR2 ) ) ; Assert . Equal ( LITERAL , VAR0 . Relational ( ) . DiscriminatorProperty . VAR3 ) ; Assert . Equal ( typeof ( string ) , VAR0 . Relational ( ) . DiscriminatorProperty . ClrType ) ; Assert . Equal ( 1 , VAR0 . Relational ( ) . DiscriminatorValue ) ; Assert . Equal ( LITERAL , VAR1 . Model . GetEntityType ( typeof ( SpecialCustomer ) ) . Relational ( ) . DiscriminatorValue ) ;
var VAR0 = VAR1 . Model . GetEntityType ( typeof ( VAR2 ) ) ; Assert . Equal ( LITERAL , VAR0 . Relational ( ) . DiscriminatorProperty . VAR3 ) ; Assert . Equal ( typeof ( string ) , VAR0 . Relational ( ) . DiscriminatorProperty . ClrType ) ; Assert . Equal ( 1 , VAR0 . Relational ( ) . DiscriminatorValue ) ; Assert . Equal ( LITERAL , VAR1 . Model . GetEntityType ( typeof ( SpecialCustomer ) ) . Relational ( ) . DiscriminatorValue ) ;
var VAR0 = VAR1 . GetEntityType ( LITERAL ) ; var VAR2 = VAR1 . GetEntityType ( LITERAL ) ; Assert . NotEmpty ( VAR0 . FindReferencingForeignKeys ( ) ) ; Assert . NotEmpty ( VAR2 . GetForeignKeys ( ) ) ; var VAR3 = VAR2 . GetForeignKey ( VAR2 . FindProperty ( LITERAL ) ) . PrincipalKey ;
var VAR0 = VAR1 . GetEntityType ( LITERAL ) ; Assert . NotEmpty ( VAR0 . FindReferencingForeignKeys ( ) ) ; Assert . NotEmpty ( VAR0 . GetForeignKeys ( ) ) ; var VAR2 = VAR0 . GetForeignKey ( VAR0 . FindProperty ( LITERAL ) ) . PrincipalKey ;
Assert . Same ( VAR0 , VAR1 . TryGetEntry ( new SimpleKeyValue < int > ( VAR0 . EntityType . GetPrimaryKey ( ) , LITERAL ) ) ) ; VAR2 . VAR3 = LITERAL ; VAR4 . DetectChanges ( VAR0 ) ; Assert . Equal ( LITERAL , VAR0 . RelationshipsSnapshot [ VAR0 . EntityType . GetProperty ( LITERAL ) ] ) ; Assert . Same ( VAR0 , VAR1 . TryGetEntry ( new SimpleKeyValue < int > ( VAR0 . EntityType . GetPrimaryKey ( ) , LITERAL ) ) ) ;
Assert . Same ( VAR0 , VAR1 . TryGetEntry ( new SimpleKeyValue < int > ( VAR0 . EntityType . GetPrimaryKey ( ) , - 1 ) ) ) ; VAR2 . VAR3 = LITERAL ; Assert . Equal ( LITERAL , VAR0 . RelationshipsSnapshot [ VAR0 . EntityType . GetProperty ( LITERAL ) ] ) ; Assert . Same ( VAR0 , VAR1 . TryGetEntry ( new SimpleKeyValue < int > ( VAR0 . EntityType . GetPrimaryKey ( ) , - 1 ) ) ) ;
Assert . Same ( VAR0 , VAR1 . TryGetEntry ( new SimpleKeyValue < int > ( VAR0 . EntityType . GetPrimaryKey ( ) , - 1 ) ) ) ; VAR2 . VAR3 = LITERAL ; Assert . Equal ( LITERAL , VAR0 . RelationshipsSnapshot [ VAR0 . EntityType . GetProperty ( LITERAL ) ] ) ; Assert . Same ( VAR0 , VAR1 . TryGetEntry ( new SimpleKeyValue < int > ( VAR0 . EntityType . GetPrimaryKey ( ) , - 1 ) ) ) ; var VAR4 = VAR5 . GetRequiredService < TestRelationshipListener > ( ) ; Assert . Same ( VAR0 , VAR4 . VAR6 . Item1 ) ; Assert . Same ( VAR0 . EntityType . GetProperty ( LITERAL ) , VAR4 . VAR6 . Item2 ) ;
Assert . Same ( VAR0 , VAR1 . TryGetEntry ( new SimpleKeyValue < int > ( VAR0 . EntityType . GetPrimaryKey ( ) , - 1 ) ) ) ; VAR2 . VAR3 = LITERAL ; Assert . Equal ( LITERAL , VAR0 . RelationshipsSnapshot [ VAR0 . EntityType . GetProperty ( LITERAL ) ] ) ; Assert . Same ( VAR0 , VAR1 . TryGetEntry ( new SimpleKeyValue < int > ( VAR0 . EntityType . GetPrimaryKey ( ) , - 1 ) ) ) ;
Assert . Equal ( LITERAL , VAR0 . RelationshipsSnapshot [ VAR0 . EntityType . GetProperty ( LITERAL ) ] ) ; var VAR1 = VAR2 . GetRequiredService < TestRelationshipListener > ( ) ; Assert . Same ( VAR0 , VAR1 . VAR3 . Item1 ) ; Assert . Same ( VAR0 . EntityType . GetProperty ( LITERAL ) , VAR1 . VAR3 . Item2 ) ;
Assert . Equal ( VAR0 , VAR1 . RelationshipsSnapshot [ VAR1 . EntityType . GetNavigation ( LITERAL ) ] ) ; var VAR2 = VAR3 . GetRequiredService < TestRelationshipListener > ( ) ; Assert . Same ( VAR1 , VAR2 . VAR4 . Item1 ) ; Assert . Same ( VAR1 . EntityType . GetNavigation ( LITERAL ) , VAR2 . VAR4 . Item2 ) ;
var VAR0 = VAR1 . GetEntityType ( typeof ( SomeDependentEntity ) . FullName ) ; var VAR2 = VAR0 . GetForeignKeys ( ) . Single ( ) ; var VAR3 = VAR2 . Properties . Single ( ) ; var VAR4 = TestHelpers . Instance . CreateContextServices ( VAR1 ) ; var VAR5 = CreateInternalEntry ( VAR4 , VAR0 , new SomeDependentEntity ( ) ) ; VAR5 [ VAR3 ] = LITERAL ; VAR5 . RelationshipsSnapshot [ VAR3 ] = LITERAL ; var VAR6 = VAR5 . GetDependentKeyValue ( VAR2 ) ; Assert . IsType < SimpleKeyValue < int > > ( VAR6 ) ; Assert . Equal ( LITERAL , VAR6 . Value ) ; Assert . Same ( VAR2 . PrincipalEntityType . GetPrimaryKey ( ) , VAR6 . Key ) ;
var VAR0 = VAR1 . GetEntityType ( typeof ( SomeDependentEntity ) . FullName ) ; var VAR2 = VAR0 . GetForeignKeys ( ) . Single ( ) ; var VAR3 = VAR2 . Properties . Single ( ) ; var VAR4 = TestHelpers . Instance . CreateContextServices ( VAR1 ) ; var VAR5 = CreateInternalEntry ( VAR4 , VAR0 , new SomeDependentEntity ( ) ) ; VAR5 [ VAR3 ] = LITERAL ; var VAR6 = VAR5 . RelationshipsSnapshot . GetDependentKeyValue ( VAR2 ) ; Assert . IsType < SimpleKeyValue < int > > ( VAR6 ) ; Assert . Equal ( LITERAL , VAR6 . Value ) ; Assert . Same ( VAR2 . PrincipalEntityType . GetPrimaryKey ( ) , VAR6 . Key ) ;
var VAR0 = VAR1 . GetEntityType ( typeof ( SomeEntity ) . FullName ) ; var VAR2 = VAR1 . GetEntityType ( typeof ( SomeDependentEntity ) . FullName ) ; var VAR3 = VAR0 . GetProperty ( LITERAL ) ; var VAR4 = TestHelpers . Instance . CreateContextServices ( VAR1 ) ; var VAR5 = CreateInternalEntry ( VAR4 , VAR0 , new SomeEntity ( ) ) ; VAR5 [ VAR3 ] = LITERAL ; var VAR6 = VAR2 . GetForeignKeys ( ) . Single ( ) ; var VAR7 = VAR5 . GetPrincipalKeyValue ( VAR6 ) ; Assert . IsType < SimpleKeyValue < int > > ( VAR7 ) ; Assert . Equal ( LITERAL , VAR7 . Value ) ; Assert . Same ( VAR6 . PrincipalEntityType . GetPrimaryKey ( ) , VAR7 . Key ) ;
var VAR0 = VAR1 . GetEntityType ( typeof ( SomeMoreDependentEntity ) . FullName ) ; var VAR2 = VAR0 . GetForeignKeys ( ) . Single ( ) ; var VAR3 = TestHelpers . Instance . CreateContextServices ( VAR1 ) ; var VAR4 = CreateInternalEntry ( VAR3 , VAR0 , new SomeMoreDependentEntity ( ) ) ; VAR4 [ VAR2 . Properties [ 0 ] ] = LITERAL ; VAR4 [ VAR2 . Properties [ 1 ] ] = LITERAL ; var VAR5 = ( CompositeKeyValue ) VAR4 . GetDependentKeyValue ( VAR2 ) ; Assert . Equal ( LITERAL , VAR5 . Value [ 0 ] ) ; Assert . Equal ( LITERAL , VAR5 . Value [ 1 ] ) ; Assert . Same ( VAR2 . PrincipalEntityType . GetPrimaryKey ( ) , VAR5 . Key ) ;
var VAR0 = GetDatabaseInfo ( VAR1 ) ; var VAR2 = Assert . Single ( VAR0 . Tables . Single ( VAR3 => VAR3 . ForeignKeys . Count > 0 ) . ForeignKeys ) ; Assert . Equal ( LITERAL , VAR2 . Table . SchemaName ) ; Assert . Equal ( LITERAL , VAR2 . Table . Name ) ; Assert . Equal ( LITERAL , VAR2 . PrincipalTable . SchemaName ) ; Assert . Equal ( LITERAL , VAR2 . PrincipalTable . Name ) ; Assert . Equal ( LITERAL , VAR2 . From . Single ( ) . Name ) ; Assert . Equal ( LITERAL , VAR2 . To . Single ( ) . Name ) ;
Assert . Equal ( new [ ] { LITERAL , LITERAL } , VAR0 . Properties . Select ( VAR1 => VAR1 . VAR2 ) . ToArray ( ) ) ; Assert . Equal ( new [ ] { LITERAL , LITERAL } , VAR3 . Properties . Select ( VAR1 => VAR1 . VAR2 ) . ToArray ( ) ) ; Assert . Equal ( new [ ] { LITERAL , LITERAL } , VAR4 . Properties . Select ( VAR1 => VAR1 . VAR2 ) . ToArray ( ) ) ; VAR3 . BaseType = VAR0 ; VAR4 . BaseType = VAR0 ; Assert . Equal ( new [ ] { LITERAL , LITERAL } , VAR0 . Properties . Select ( VAR1 => VAR1 . VAR2 ) . ToArray ( ) ) ; Assert . Equal ( new [ ] { LITERAL , LITERAL , LITERAL , LITERAL } , VAR3 . Properties . Select ( VAR1 => VAR1 . VAR2 ) . ToArray ( ) ) ; Assert . Equal ( new [ ] { LITERAL , LITERAL , LITERAL , LITERAL } , VAR4 . Properties . Select ( VAR1 => VAR1 . VAR2 ) . ToArray ( ) ) ; Assert . Equal ( new [ ] { 0 , 1 , LITERAL , LITERAL } , VAR3 . Properties . Select ( VAR1 => VAR1 . Index ) ) ; Assert . Equal ( new [ ] { 0 , 1 , LITERAL , LITERAL } , VAR4 . Properties . Select ( VAR1 => VAR1 . Index ) ) ;
Assert . Equal ( new [ ] { LITERAL } , VAR0 . Navigations . Select ( VAR1 => VAR1 . VAR2 ) . ToArray ( ) ) ; Assert . Equal ( new string [ 0 ] , VAR3 . Navigations . Select ( VAR1 => VAR1 . VAR2 ) . ToArray ( ) ) ; VAR3 . BaseType = VAR0 ; Assert . Equal ( new [ ] { LITERAL } , VAR0 . Navigations . Select ( VAR1 => VAR1 . VAR2 ) . ToArray ( ) ) ; Assert . Equal ( new [ ] { LITERAL } , VAR3 . Navigations . Select ( VAR1 => VAR1 . VAR2 ) . ToArray ( ) ) ; var VAR4 = VAR5 . GetOrAddProperty ( Order . VAR6 ) ; var VAR7 = VAR5 . GetOrAddForeignKey ( VAR4 , VAR8 , VAR3 ) ; VAR3 . AddNavigation ( LITERAL , VAR7 , pointsToPrincipal : false ) ; Assert . Equal ( new [ ] { LITERAL } , VAR0 . Navigations . Select ( VAR1 => VAR1 . VAR2 ) . ToArray ( ) ) ; Assert . Equal ( new [ ] { LITERAL , LITERAL } , VAR3 . Navigations . Select ( VAR1 => VAR1 . VAR2 ) . ToArray ( ) ) ;
Assert . Contains ( VAR0 . Metadata . Navigations , VAR1 => VAR1 . Name == nameof ( VAR2 . VAR3 ) ) ; Assert . DoesNotContain ( VAR0 . Metadata . Navigations , VAR1 => VAR1 . Name == nameof ( VAR2 . VAR4 ) ) ; Assert . Contains ( VAR5 . Metadata . Navigations , VAR1 => VAR1 . Name == nameof ( VAR4 . VAR2 ) ) ; new InversePropertyAttributeConvention ( ) . Apply ( VAR5 ) ; Assert . Contains ( VAR0 . Metadata . Navigations , VAR1 => VAR1 . Name == nameof ( VAR2 . VAR3 ) ) ; Assert . DoesNotContain ( VAR0 . Metadata . Navigations , VAR1 => VAR1 . Name == nameof ( VAR2 . VAR4 ) ) ; Assert . Contains ( VAR5 . Metadata . Navigations , VAR1 => VAR1 . Name == nameof ( VAR4 . VAR2 ) ) ;
Assert . Contains ( LITERAL , VAR0 . GetEntityType ( typeof ( BookLabel ) ) . Navigations . Select ( VAR1 => VAR1 . Name ) ) ; Assert . Equal ( LITERAL , VAR0 . GetEntityType ( typeof ( BookLabel ) ) . FindNavigation ( LITERAL ) . ForeignKey . PrincipalToDependent . Name ) ; Assert . Contains ( LITERAL , VAR0 . GetEntityType ( typeof ( Book ) ) . Navigations . Select ( VAR1 => VAR1 . Name ) ) ; Assert . Null ( VAR0 . GetEntityType ( typeof ( Book ) ) . FindNavigation ( LITERAL ) . ForeignKey . PrincipalToDependent ) ; VAR2 . Entity < SpecialBookLabel > ( ) . HasBaseType ( null ) ; Assert . Null ( VAR0 . GetEntityType ( typeof ( SpecialBookLabel ) ) . Navigations . Single ( VAR3 => VAR3 . Name == LITERAL ) . FindInverse ( ) ) ; Assert . Contains ( LITERAL , VAR0 . GetEntityType ( typeof ( BookLabel ) ) . Navigations . Select ( VAR1 => VAR1 . Name ) ) ; Assert . Equal ( LITERAL , VAR0 . GetEntityType ( typeof ( BookLabel ) ) . FindNavigation ( LITERAL ) . ForeignKey . PrincipalToDependent . Name ) ; Assert . Contains ( LITERAL , VAR0 . GetEntityType ( typeof ( Book ) ) . Navigations . Select ( VAR1 => VAR1 . Name ) ) ;
Assert . Equal ( LITERAL , VAR0 . Navigations . Single ( ) . Name ) ; Assert . Equal ( LITERAL , VAR1 . Navigations . Single ( ) . Name ) ; Assert . Same ( VAR2 , VAR0 . Navigations . Single ( ) . ForeignKey ) ; Assert . Same ( VAR2 , VAR1 . Navigations . Single ( ) . ForeignKey ) ; AssertEqual ( new [ ] { LITERAL , VAR3 . Properties . Single ( ) . Name } , VAR1 . Properties . Select ( VAR4 => VAR4 . Name ) ) ; AssertEqual ( new [ ] { VAR5 . Name , VAR6 . Properties . Single ( ) . Name } , VAR0 . Properties . Select ( VAR4 => VAR4 . Name ) ) ;
var VAR0 = VAR1 . Navigations . Single ( ) . ForeignKey ; Assert . Same ( VAR1 . GetProperty ( nameof ( Pickle . BurgerId ) ) , VAR0 . Properties . Single ( ) ) ; Assert . Equal ( nameof ( Pickle . BigMak ) , VAR0 . DependentToPrincipal . Name ) ; Assert . Null ( VAR0 . PrincipalToDependent ) ; Assert . NotSame ( VAR0 , VAR2 . Navigations . Single ( ) . ForeignKey ) ;
Assert . Same ( VAR0 , VAR1 . TryGetEntry ( new SimpleEntityKey < int > ( VAR0 . EntityType . GetPrimaryKey ( ) , - 1 ) ) ) ; VAR2 . VAR3 = LITERAL ; Assert . Equal ( LITERAL , VAR0 . RelationshipsSnapshot [ VAR0 . EntityType . GetProperty ( LITERAL ) ] ) ; Assert . Same ( VAR0 , VAR1 . TryGetEntry ( new SimpleEntityKey < int > ( VAR0 . EntityType . GetPrimaryKey ( ) , - 1 ) ) ) ;
Assert . False ( VAR0 . IsPropertyModified ( VAR1 ) ) ; VAR0 . SetEntityState ( EntityState . Unchanged , true ) ; Assert . False ( VAR0 . IsPropertyModified ( VAR1 ) ) ; VAR0 . SetPropertyModified ( VAR1 ) ; Assert . True ( VAR0 . IsPropertyModified ( VAR1 ) ) ;
Assert . False ( VAR0 . IsPropertyModified ( VAR1 ) ) ; Assert . False ( VAR0 . IsPropertyModified ( VAR2 ) ) ; VAR0 . MarkAsTemporary ( VAR1 ) ; Assert . True ( VAR0 . HasTemporaryValue ( VAR1 ) ) ; Assert . False ( VAR0 . HasTemporaryValue ( VAR2 ) ) ; Assert . False ( VAR0 . IsPropertyModified ( VAR1 ) ) ; Assert . False ( VAR0 . IsPropertyModified ( VAR2 ) ) ; VAR0 . MarkAsTemporary ( VAR2 ) ; VAR0 . MarkAsTemporary ( VAR1 , isTemporary : false ) ; Assert . False ( VAR0 . HasTemporaryValue ( VAR1 ) ) ; Assert . True ( VAR0 . HasTemporaryValue ( VAR2 ) ) ; Assert . False ( VAR0 . IsPropertyModified ( VAR1 ) ) ; Assert . False ( VAR0 . IsPropertyModified ( VAR2 ) ) ;
Assert . False ( VAR0 . IsPropertyModified ( VAR1 ) ) ; Assert . False ( VAR0 . IsPropertyModified ( VAR2 ) ) ; VAR0 . MarkAsTemporary ( VAR1 ) ; VAR0 . MarkAsTemporary ( VAR2 ) ; Assert . False ( VAR0 . HasTemporaryValue ( VAR1 ) ) ; Assert . False ( VAR0 . HasTemporaryValue ( VAR2 ) ) ; Assert . False ( VAR0 . IsPropertyModified ( VAR1 ) ) ; Assert . False ( VAR0 . IsPropertyModified ( VAR2 ) ) ; VAR0 . SetEntityState ( EntityState . Added ) ; Assert . False ( VAR0 . HasTemporaryValue ( VAR1 ) ) ; Assert . False ( VAR0 . HasTemporaryValue ( VAR2 ) ) ; Assert . False ( VAR0 . IsPropertyModified ( VAR1 ) ) ; Assert . False ( VAR0 . IsPropertyModified ( VAR2 ) ) ;
Assert . False ( VAR0 . IsPropertyModified ( VAR1 ) ) ; Assert . False ( VAR0 . IsPropertyModified ( VAR2 ) ) ; VAR0 . SetEntityState ( EntityState . Added ) ; Assert . False ( VAR0 . HasTemporaryValue ( VAR1 ) ) ; Assert . False ( VAR0 . HasTemporaryValue ( VAR2 ) ) ; Assert . False ( VAR0 . IsPropertyModified ( VAR1 ) ) ; Assert . False ( VAR0 . IsPropertyModified ( VAR2 ) ) ;
Assert . Same ( VAR0 , VAR0 . BaseType ( VAR1 . Metadata , ConfigurationSource . Convention ) ) ; Assert . True ( new DiscriminatorConvention ( ) . Apply ( VAR0 , oldBaseType : null ) ) ; var VAR2 = VAR0 . ModelBuilder . Entity ( typeof ( DerivedEntity ) , ConfigurationSource . Explicit ) ; Assert . Same ( VAR2 , VAR2 . BaseType ( VAR0 . Metadata , ConfigurationSource . Convention ) ) ;
Assert . NotNull ( VAR0 . Relational ( ConfigurationSource . Convention ) . Discriminator ( LITERAL , typeof ( string ) ) ) ; Assert . Equal ( LITERAL , VAR0 . Metadata . Relational ( ) . DiscriminatorProperty . Name ) ; Assert . Equal ( typeof ( string ) , VAR0 . Metadata . Relational ( ) . DiscriminatorProperty . ClrType ) ; Assert . Null ( VAR0 . Relational ( ConfigurationSource . Convention ) . Discriminator ( LITERAL , typeof ( int ? ) ) ) ;
var VAR0 = VAR1 . ForeignKey ( typeof ( VAR2 ) . FullName , new [ ] { Order . VAR3 . Name , Order . VAR4 . Name } , ConfigurationSource . DataAnnotation ) ; Assert . Same ( VAR0 , VAR1 . Navigation ( Order . VAR5 . Name , VAR0 . Metadata , pointsToPrincipal : true , configurationSource : ConfigurationSource . DataAnnotation ) ) ; Assert . Same ( VAR0 , VAR6 . Navigation ( VAR2 . VAR7 . Name , VAR0 . Metadata , pointsToPrincipal : false , configurationSource : ConfigurationSource . DataAnnotation ) ) ; Assert . True ( VAR1 . Ignore ( Order . VAR5 . Name , ConfigurationSource . Explicit ) ) ; Assert . True ( VAR6 . Ignore ( VAR2 . VAR7 . Name , ConfigurationSource . Explicit ) ) ; Assert . Null ( VAR1 . Metadata . FindNavigation ( Order . VAR5 . Name ) ) ; Assert . Null ( VAR6 . Metadata . FindNavigation ( VAR2 . VAR7 . Name ) ) ; Assert . True ( VAR1 . Ignore ( Order . VAR5 . Name , ConfigurationSource . Convention ) ) ; Assert . True ( VAR6 . Ignore ( VAR2 . VAR7 . Name , ConfigurationSource . Convention ) ) ; Assert . Empty ( VAR1 . Metadata . GetForeignKeys ( ) ) ; VAR0 = VAR1 . ForeignKey ( typeof ( VAR2 ) . FullName , new [ ] { Order . VAR3 . Name , Order . VAR4 . Name } , ConfigurationSource . DataAnnotation ) ;
Assert . True ( VAR0 . Annotation ( LITERAL , 1 , ConfigurationSource . DataAnnotation ) ) ; Assert . False ( VAR0 . Annotation ( LITERAL , LITERAL , ConfigurationSource . DataAnnotation ) ) ; Assert . Equal ( 1 , VAR1 . Annotations . Single ( ) . Value ) ; Assert . True ( VAR0 . Annotation ( LITERAL , LITERAL , ConfigurationSource . Explicit ) ) ;
VAR0 = new LazyRef < ILogger > ( ( ) => VAR1 . CreateLogger < MigrationsOperations > ( ) ) ; VAR2 = VAR3 ; VAR4 = VAR5 ; VAR6 = VAR7 ; VAR8 = VAR9 ; VAR10 = VAR11 ;
VAR0 . Entity < Animal > ( ) . Key ( VAR1 => VAR1 . Species ) ; VAR0 . Entity < Rose > ( ) . BaseType < Flower > ( ) ; VAR0 . Entity < Daisy > ( ) . BaseType < Flower > ( ) ; VAR0 . Entity < Flower > ( ) . BaseType < Plant > ( ) ; VAR0 . Entity < Plant > ( ) . Key ( VAR1 => VAR1 . Species ) ;
Check . NotNull ( VAR0 , nameof ( VAR0 ) ) ; Check . NotNull ( VAR1 , nameof ( VAR1 ) ) ; VAR2 = VAR3 ; VAR4 = VAR5 ; VAR6 = VAR7 ; VAR8 = VAR9 ; VAR10 = VAR11 ; VAR12 = VAR0 ;
VAR0 . Entity < Pickle > ( ) . Reference < BigMak > ( ) . InverseCollection ( VAR1 => VAR1 . Pickles ) ; var VAR2 = VAR3 . GetForeignKeys ( ) . Single ( ) ; var VAR4 = ( IProperty ) VAR2 . Properties . Single ( ) ; Assert . Equal ( LITERAL , VAR4 . Name ) ; Assert . True ( VAR4 . IsShadowProperty ) ; Assert . Same ( typeof ( int ? ) , VAR4 . ClrType ) ; Assert . Same ( VAR3 , VAR4 . DeclaringEntityType ) ;
VAR0 . Entity < Pickle > ( ) . Reference < BigMak > ( ) . InverseCollection ( ) ; var VAR1 = VAR2 . GetForeignKeys ( ) . Single ( VAR3 => VAR3 != VAR4 ) ; var VAR5 = ( IProperty ) VAR1 . Properties . Single ( ) ; Assert . True ( VAR5 . IsShadowProperty ) ; Assert . Same ( typeof ( int ? ) , VAR5 . ClrType ) ; Assert . Same ( VAR2 , VAR5 . DeclaringEntityType ) ;
VAR0 . Property ( VAR1 => VAR1 . Up ) . Required ( ) ; VAR0 . Property ( VAR1 => VAR1 . Down ) . Required ( ) ; VAR0 . Property < int > ( LITERAL ) . Required ( ) ; VAR0 . Property < string > ( LITERAL ) . Required ( ) ; VAR0 . Property < int > ( LITERAL ) . Required ( ) ; VAR0 . Property < string > ( LITERAL ) . Required ( ) ;
VAR0 . Property ( VAR1 => VAR1 . Up ) . MaxLength ( 0 ) ; VAR0 . Property ( VAR1 => VAR1 . Down ) . MaxLength ( LITERAL ) ; VAR0 . Property < int > ( LITERAL ) . MaxLength ( 0 ) ; VAR0 . Property < string > ( LITERAL ) . MaxLength ( LITERAL ) ; VAR0 . Property < int > ( LITERAL ) . MaxLength ( 0 ) ; VAR0 . Property < string > ( LITERAL ) . MaxLength ( LITERAL ) ;
VAR0 . Entity < Customer > ( ) . Collection ( VAR1 => VAR1 . Orders ) . InverseReference ( VAR1 => VAR1 . Customer ) ; Assert . Same ( VAR2 , VAR3 . GetForeignKeys ( ) . Single ( ) ) ; Assert . Equal ( VAR4 . Name , VAR3 . Navigations . Single ( ) . Name ) ; Assert . Same ( VAR5 , VAR6 . Navigations . Single ( ) ) ; Assert . Same ( VAR2 , VAR3 . Navigations . Single ( ) . ForeignKey ) ; Assert . Same ( VAR2 , VAR6 . Navigations . Single ( ) . ForeignKey ) ; AssertEqual ( new [ ] { LITERAL , VAR7 . Properties . Single ( ) . Name , Customer . NameProperty . Name } , VAR6 . Properties . Select ( VAR8 => VAR8 . Name ) ) ; AssertEqual ( new [ ] { LITERAL , VAR2 . Properties . Single ( ) . Name , VAR9 . Properties . Single ( ) . Name } , VAR3 . Properties . Select ( VAR8 => VAR8 . Name ) ) ; Assert . Empty ( VAR6 . GetForeignKeys ( ) ) ;
VAR0 . Entity < Customer > ( ) . Collection ( VAR1 => VAR1 . Orders ) . InverseReference ( VAR1 => VAR1 . Customer ) ; var VAR2 = VAR3 . GetForeignKeys ( ) . Single ( ) ; AssertEqual ( VAR4 . Properties , VAR2 . Properties ) ; Assert . Equal ( LITERAL , VAR3 . Navigations . Single ( ) . Name ) ; Assert . Equal ( VAR5 . Name , VAR6 . Navigations . Single ( ) . Name ) ; Assert . Same ( VAR2 , VAR3 . Navigations . Single ( ) . ForeignKey ) ; Assert . Same ( VAR2 , VAR6 . Navigations . Single ( ) . ForeignKey ) ; AssertEqual ( new [ ] { LITERAL , VAR7 . Properties . Single ( ) . Name , Customer . NameProperty . Name } , VAR6 . Properties . Select ( VAR8 => VAR8 . Name ) ) ; AssertEqual ( new [ ] { LITERAL , VAR4 . Properties . Single ( ) . Name , VAR9 . Properties . Single ( ) . Name } , VAR3 . Properties . Select ( VAR8 => VAR8 . Name ) ) ; Assert . Empty ( VAR6 . GetForeignKeys ( ) ) ;
VAR0 . Entity < VAR1 > ( ) . Key ( VAR2 => VAR2 . VAR3 ) ; VAR0 . Entity < VAR4 > ( ) . Key ( VAR2 => VAR2 . VAR5 ) ; VAR0 . Entity < VAR6 > ( ) . Key ( VAR7 => VAR7 . VAR8 ) ; VAR0 . Entity < VAR9 > ( ) . Key ( VAR10 => VAR10 . VAR11 ) ; VAR0 . Entity < OrderDetail > ( ) . Key ( VAR7 => VAR7 . VAR12 ) ;
VAR0 . Key ( LITERAL ) ; VAR0 . Property < int > ( LITERAL ) ; VAR1 . Entity ( LITERAL , VAR0 => { VAR0 . Property < int > ( LITERAL ) ; VAR0 . Key ( LITERAL ) ; VAR0 . Property < int > ( LITERAL ) ; } ) ; VAR1 . Entity ( LITERAL ) . Reference ( LITERAL ) . InverseCollection ( ) . ForeignKey ( LITERAL ) ; VAR1 . Entity ( LITERAL ) . Reference ( LITERAL ) . InverseCollection ( ) . ForeignKey ( LITERAL ) ;
VAR0 . Key ( LITERAL ) ; VAR0 . Property < int > ( LITERAL ) ; VAR0 . AlternateKey ( LITERAL ) ; VAR0 . Property < int ? > ( LITERAL ) ; VAR0 . Reference ( LITERAL ) . InverseCollection ( ) . ForeignKey ( LITERAL ) ;
Check . NotNull ( VAR0 , nameof ( VAR0 ) ) ; Check . NotNull ( VAR1 , nameof ( VAR1 ) ) ; VAR2 = VAR3 ; VAR4 = VAR5 ; VAR6 = VAR0 ; VAR7 = VAR8 ; VAR9 = VAR1 ;
VAR0 . Attach ( VAR1 , includeDependents : false ) ; Assert . Equal ( LITERAL , VAR1 . VAR2 ) ; Assert . Same ( VAR1 , VAR3 . VAR4 . Single ( ) ) ; Assert . Null ( VAR1 . VAR5 ) ; Assert . Equal ( EntityState . Detached , VAR0 . Entry ( VAR3 ) . State ) ; Assert . Equal ( EntityState . Unchanged , VAR0 . Entry ( VAR1 ) . State ) ; VAR0 . Attach ( VAR3 , includeDependents : false ) ;
var VAR0 = VAR1 . Attach ( new VAR2 { VAR3 = LITERAL , VAR4 = new List < Product > ( ) } , includeDependents : false ) . Entity ; var VAR5 = new VAR2 { VAR3 = 1 , VAR6 = LITERAL } ; var VAR7 = new Product { VAR3 = 1 , VAR8 = LITERAL , VAR6 = LITERAL , VAR2 = VAR5 } ; VAR5 . VAR4 = new List < Product > { VAR7 } ; VAR1 . Attach ( VAR5 , includeDependents : false ) ;
var VAR0 = VAR1 . Attach ( new VAR2 { VAR3 = LITERAL , VAR4 = new List < Product > ( ) } , includeDependents : false ) . Entity ; var VAR5 = new VAR2 { VAR3 = 1 , VAR6 = LITERAL } ; var VAR7 = new Product { VAR3 = 1 , VAR8 = LITERAL , VAR6 = LITERAL , VAR2 = VAR5 } ; VAR5 . VAR4 = new List < Product > { VAR7 } ; VAR1 . Attach ( VAR7 , includeDependents : false ) ;
VAR0 . Attach ( VAR1 , includeDependents : false ) ; Assert . Equal ( LITERAL , VAR1 . VAR2 ) ; Assert . Same ( VAR1 , VAR3 . VAR4 . Single ( ) ) ; Assert . Same ( VAR5 , VAR1 . VAR6 ) ; Assert . Same ( VAR1 , VAR5 . VAR4 . Single ( ) ) ; Assert . Equal ( EntityState . Detached , VAR0 . Entry ( VAR3 ) . State ) ; Assert . Equal ( EntityState . Unchanged , VAR0 . Entry ( VAR1 ) . State ) ; VAR0 . Attach ( VAR3 , includeDependents : false ) ;
var VAR0 = VAR1 . Attach ( new VAR2 { VAR3 = LITERAL , VAR4 = new List < Product > ( ) } , includeDependents : false ) . Entity ; var VAR5 = new VAR2 { VAR3 = 1 , VAR6 = LITERAL } ; var VAR7 = new Product { VAR3 = 1 , VAR8 = LITERAL , VAR6 = LITERAL , VAR2 = VAR5 } ; VAR5 . VAR4 = new List < Product > ( ) ; VAR1 . Attach ( VAR7 , includeDependents : false ) ;
var VAR0 = VAR1 . Attach ( new VAR2 { VAR3 = LITERAL , VAR4 = new List < Product > ( ) } , includeDependents : false ) . Entity ; var VAR5 = new VAR2 { VAR3 = 1 , VAR6 = LITERAL } ; var VAR7 = new Product { VAR3 = 1 , VAR8 = LITERAL , VAR6 = LITERAL } ; VAR5 . VAR4 = new List < Product > { VAR7 } ; VAR1 . Attach ( VAR7 , includeDependents : false ) ; Assert . Equal ( LITERAL , VAR7 . VAR8 ) ; Assert . Same ( VAR7 , VAR5 . VAR4 . Single ( ) ) ; Assert . Same ( VAR0 , VAR7 . VAR2 ) ; Assert . Same ( VAR7 , VAR0 . VAR4 . Single ( ) ) ; Assert . Equal ( EntityState . Detached , VAR1 . Entry ( VAR5 ) . State ) ; Assert . Equal ( EntityState . Unchanged , VAR1 . Entry ( VAR7 ) . State ) ; VAR1 . Attach ( VAR5 , includeDependents : false ) ;
VAR0 . Attach ( VAR1 , includeDependents : false ) ; Assert . Equal ( LITERAL , VAR1 . VAR2 ) ; Assert . Same ( VAR1 , VAR3 . VAR4 . Single ( ) ) ; Assert . Same ( VAR5 , VAR1 . VAR6 ) ; Assert . Same ( VAR1 , VAR5 . VAR4 . Single ( ) ) ; Assert . Equal ( EntityState . Detached , VAR0 . Entry ( VAR3 ) . State ) ; Assert . Equal ( EntityState . Unchanged , VAR0 . Entry ( VAR1 ) . State ) ; VAR0 . Attach ( VAR3 , includeDependents : false ) ;
var VAR0 = new ModificationCommand ( LITERAL , null , new ParameterNameGenerator ( ) , VAR1 => VAR1 . TestProvider ( ) , new UntypedValueBufferFactoryFactory ( ) ) ; VAR0 . AddEntry ( VAR2 ) ; var VAR3 = VAR4 . GetOrCreateEntry ( new object ( ) ) ; VAR3 [ VAR5 ] = LITERAL ; VAR3 . SetEntityState ( EntityState . Modified ) ; var VAR6 = new ModificationCommand ( LITERAL , null , new ParameterNameGenerator ( ) , VAR1 => VAR1 . TestProvider ( ) , new UntypedValueBufferFactoryFactory ( ) ) ; VAR6 . AddEntry ( VAR3 ) ; var VAR7 = VAR4 . GetOrCreateEntry ( new object ( ) ) ; VAR7 [ VAR5 ] = LITERAL ; VAR7 . SetEntityState ( EntityState . Deleted ) ; var VAR8 = new ModificationCommand ( LITERAL , null , new ParameterNameGenerator ( ) , VAR1 => VAR1 . TestProvider ( ) , new UntypedValueBufferFactoryFactory ( ) ) ;
var VAR0 = new ModificationCommand ( LITERAL , null , new ParameterNameGenerator ( ) , VAR1 => VAR1 . TestProvider ( ) , new UntypedValueBufferFactoryFactory ( ) ) ; VAR0 . AddEntry ( VAR2 ) ; Assert . Equal ( LITERAL , VAR0 . TableName ) ; Assert . Null ( VAR0 . Schema ) ; Assert . Equal ( EntityState . Added , VAR0 . EntityState ) ; Assert . Equal ( LITERAL , VAR0 . ColumnModifications . Count ) ;
VAR0 . Attach ( VAR1 ) ; Assert . Equal ( LITERAL , VAR2 . VAR3 ) ; Assert . Same ( VAR2 , VAR1 . VAR4 . Single ( ) ) ; Assert . Same ( VAR1 , VAR2 . VAR5 ) ; Assert . Equal ( EntityState . Unchanged , VAR0 . Entry ( VAR1 ) . State ) ; Assert . Equal ( EntityState . Detached , VAR0 . Entry ( VAR2 ) . State ) ; VAR0 . Attach ( VAR2 ) ;
VAR0 . Attach ( VAR1 ) ; Assert . Equal ( LITERAL , VAR2 . VAR3 ) ; Assert . Empty ( VAR1 . VAR4 ) ; Assert . Same ( VAR1 , VAR2 . VAR5 ) ; Assert . Equal ( EntityState . Unchanged , VAR0 . Entry ( VAR1 ) . State ) ; Assert . Equal ( EntityState . Detached , VAR0 . Entry ( VAR2 ) . State ) ; VAR0 . Attach ( VAR2 ) ;
var VAR0 = VAR1 . Attach ( new VAR2 { VAR3 = LITERAL , VAR4 = new List < Product > ( ) } ) . Entity ; var VAR5 = new VAR2 { VAR3 = 1 , VAR6 = LITERAL } ; var VAR7 = new Product { VAR3 = 1 , VAR8 = LITERAL , VAR6 = LITERAL , VAR2 = VAR5 } ; VAR5 . VAR4 = new List < Product > { VAR7 } ; VAR1 . Attach ( VAR5 ) ;
VAR0 . Attach ( VAR1 ) ; Assert . Equal ( LITERAL , VAR2 . VAR3 ) ; Assert . Same ( VAR2 , VAR1 . VAR4 . Single ( ) ) ; Assert . Same ( VAR1 , VAR2 . VAR5 ) ; Assert . Empty ( VAR6 . VAR4 ) ; Assert . Equal ( EntityState . Unchanged , VAR0 . Entry ( VAR1 ) . State ) ; Assert . Equal ( EntityState . Detached , VAR0 . Entry ( VAR2 ) . State ) ; VAR0 . Attach ( VAR2 ) ;
var VAR0 = VAR1 . Attach ( new VAR2 { VAR3 = LITERAL , VAR4 = new List < Product > ( ) } ) . Entity ; var VAR5 = new VAR2 { VAR3 = 1 , VAR6 = LITERAL } ; var VAR7 = new Product { VAR3 = 1 , VAR8 = LITERAL , VAR6 = LITERAL , VAR2 = VAR5 } ; VAR5 . VAR4 = new List < Product > { VAR7 } ; VAR1 . Attach ( VAR7 ) ;
Assert . Equal ( 1 , VAR0 . VAR1 ) ; Assert . Same ( VAR0 , VAR2 . VAR3 . Single ( ) ) ; Assert . Same ( VAR2 , VAR0 . VAR4 ) ; Assert . Equal ( EntityState . Detached , VAR5 . Entry ( VAR2 ) . State ) ; Assert . Equal ( EntityState . Modified , VAR5 . Entry ( VAR0 ) . State ) ; VAR5 . Attach ( VAR2 ) ; Assert . Equal ( 1 , VAR0 . VAR1 ) ; Assert . Same ( VAR0 , VAR2 . VAR3 . Single ( ) ) ; Assert . Same ( VAR2 , VAR0 . VAR4 ) ; Assert . Equal ( EntityState . Unchanged , VAR5 . Entry ( VAR2 ) . State ) ; Assert . Equal ( EntityState . Modified , VAR5 . Entry ( VAR0 ) . State ) ;
Assert . Equal ( 1 , VAR0 . VAR1 ) ; Assert . Same ( VAR0 , VAR2 . VAR3 . Single ( ) ) ; Assert . Same ( VAR2 , VAR0 . VAR4 ) ; Assert . Equal ( EntityState . Detached , VAR5 . Entry ( VAR2 ) . State ) ; Assert . Equal ( EntityState . Modified , VAR5 . Entry ( VAR0 ) . State ) ; VAR5 . Entry ( VAR2 ) . State = EntityState . Unchanged ; Assert . Equal ( 1 , VAR0 . VAR1 ) ; Assert . Same ( VAR0 , VAR2 . VAR3 . Single ( ) ) ; Assert . Same ( VAR2 , VAR0 . VAR4 ) ; Assert . Equal ( EntityState . Unchanged , VAR5 . Entry ( VAR2 ) . State ) ; Assert . Equal ( EntityState . Modified , VAR5 . Entry ( VAR0 ) . State ) ;
Assert . Equal ( 1 , VAR0 . VAR1 ) ; Assert . Same ( VAR0 , VAR2 . VAR3 . Single ( ) ) ; Assert . Same ( VAR2 , VAR0 . VAR4 ) ; Assert . Equal ( EntityState . Unchanged , VAR5 . Entry ( VAR2 ) . State ) ; Assert . Equal ( EntityState . Modified , VAR5 . Entry ( VAR0 ) . State ) ;
Assert . Equal ( 1 , VAR0 . VAR1 ) ; Assert . Same ( VAR0 , VAR2 . VAR3 . Single ( ) ) ; Assert . Same ( VAR2 , VAR0 . VAR4 ) ; Assert . Empty ( VAR5 . VAR3 ) ; Assert . Equal ( EntityState . Unchanged , VAR6 . Entry ( VAR2 ) . State ) ; Assert . Equal ( EntityState . Modified , VAR6 . Entry ( VAR0 ) . State ) ;
var VAR0 = new RelationalTypeMapping ( LITERAL ) . CreateParameter ( new TestCommand ( ) , LITERAL , LITERAL , isNullable : true ) ; Assert . Equal ( ParameterDirection . Input , VAR0 . VAR1 ) ; Assert . Equal ( LITERAL , VAR0 . VAR2 ) ; Assert . Equal ( LITERAL , VAR0 . VAR3 ) ; Assert . Equal ( VAR4 . AnsiString , VAR0 . VAR4 ) ;
VAR0 . AddProperty ( LITERAL , typeof ( string ) ) ; VAR0 . AddProperty ( LITERAL , typeof ( string ) ) ; var VAR1 = VAR2 . AddEntityType ( typeof ( D ) ) ; VAR1 . AddProperty ( LITERAL , typeof ( string ) ) ; VAR1 . AddProperty ( LITERAL , typeof ( string ) ) ;
var VAR0 = VAR1 . GetOrAddProperty ( Order . VAR2 ) ; var VAR3 = VAR1 . GetOrAddForeignKey ( VAR0 , VAR4 , VAR5 ) ; var VAR6 = VAR7 . GetOrAddProperty ( Order . VAR8 ) ; var VAR9 = VAR7 . GetOrAddForeignKey ( VAR6 , VAR4 , VAR5 ) ;
Assert . Same ( VAR0 , VAR1 . TryGetEntry ( new SimpleEntityKey < int > ( VAR0 . EntityType , - 1 ) ) ) ; VAR2 . VAR3 = LITERAL ; VAR4 . DetectChanges ( VAR0 ) ; Assert . Equal ( LITERAL , VAR0 . RelationshipsSnapshot [ VAR0 . EntityType . GetProperty ( LITERAL ) ] ) ; Assert . Same ( VAR0 , VAR1 . TryGetEntry ( new SimpleEntityKey < int > ( VAR0 . EntityType , - 1 ) ) ) ;
Assert . Same ( VAR0 , VAR1 . TryGetEntry ( new SimpleEntityKey < int > ( VAR0 . EntityType , - 1 ) ) ) ; VAR2 . VAR3 = LITERAL ; Assert . Equal ( LITERAL , VAR0 . RelationshipsSnapshot [ VAR0 . EntityType . GetProperty ( LITERAL ) ] ) ; Assert . Same ( VAR0 , VAR1 . TryGetEntry ( new SimpleEntityKey < int > ( VAR0 . EntityType , - 1 ) ) ) ;
Assert . Null ( VAR0 . Relational ( ) . TryGetSequence ( LITERAL ) ) ; Assert . Null ( ( ( IModel ) VAR0 ) . Relational ( ) . TryGetSequence ( LITERAL ) ) ; Assert . Null ( VAR0 . SqlServer ( ) . TryGetSequence ( LITERAL ) ) ; Assert . Null ( ( ( IModel ) VAR0 ) . SqlServer ( ) . TryGetSequence ( LITERAL ) ) ; var VAR1 = VAR0 . SqlServer ( ) . GetOrAddSequence ( LITERAL ) ; Assert . Null ( VAR0 . Relational ( ) . TryGetSequence ( LITERAL ) ) ; Assert . Null ( ( ( IModel ) VAR0 ) . Relational ( ) . TryGetSequence ( LITERAL ) ) ; Assert . Equal ( LITERAL , VAR0 . SqlServer ( ) . TryGetSequence ( LITERAL ) . VAR2 ) ; Assert . Equal ( LITERAL , ( ( IModel ) VAR0 ) . SqlServer ( ) . TryGetSequence ( LITERAL ) . VAR2 ) ;
Assert . Null ( VAR0 . Relational ( ) . TryGetSequence ( LITERAL , LITERAL ) ) ; Assert . Null ( ( ( IModel ) VAR0 ) . Relational ( ) . TryGetSequence ( LITERAL , LITERAL ) ) ; Assert . Null ( VAR0 . SqlServer ( ) . TryGetSequence ( LITERAL , LITERAL ) ) ; Assert . Null ( ( ( IModel ) VAR0 ) . SqlServer ( ) . TryGetSequence ( LITERAL , LITERAL ) ) ; var VAR1 = VAR0 . SqlServer ( ) . GetOrAddSequence ( LITERAL , LITERAL ) ; Assert . Null ( VAR0 . Relational ( ) . TryGetSequence ( LITERAL , LITERAL ) ) ; Assert . Null ( ( ( IModel ) VAR0 ) . Relational ( ) . TryGetSequence ( LITERAL , LITERAL ) ) ; Assert . Equal ( LITERAL , VAR0 . SqlServer ( ) . TryGetSequence ( LITERAL , LITERAL ) . VAR2 ) ; Assert . Equal ( LITERAL , ( ( IModel ) VAR0 ) . SqlServer ( ) . TryGetSequence ( LITERAL , LITERAL ) . VAR2 ) ;
VAR0 . Model . SqlServer ( ) . AddOrReplaceSequence ( new Sequence ( LITERAL , LITERAL ) ) ; VAR1 . SqlServer ( ) . HiLoSequenceName = LITERAL ; VAR1 . SqlServer ( ) . HiLoSequenceSchema = LITERAL ; VAR1 . SqlServer ( ) . IdentityStrategy = SqlServerIdentityStrategy . SequenceHiLo ; Assert . Equal ( LITERAL , VAR1 . SqlServer ( ) . TryGetHiLoSequence ( ) . VAR2 ) ; Assert . Equal ( LITERAL , ( ( IProperty ) VAR1 ) . SqlServer ( ) . TryGetHiLoSequence ( ) . VAR2 ) ; Assert . Equal ( LITERAL , VAR1 . SqlServer ( ) . TryGetHiLoSequence ( ) . Schema ) ; Assert . Equal ( LITERAL , ( ( IProperty ) VAR1 ) . SqlServer ( ) . TryGetHiLoSequence ( ) . Schema ) ;
VAR0 . Model . SqlServer ( ) . AddOrReplaceSequence ( new Sequence ( LITERAL , LITERAL ) ) ; VAR0 . Model . SqlServer ( ) . HiLoSequenceName = LITERAL ; VAR0 . Model . SqlServer ( ) . HiLoSequenceSchema = LITERAL ; VAR1 . SqlServer ( ) . IdentityStrategy = SqlServerIdentityStrategy . SequenceHiLo ; Assert . Equal ( LITERAL , VAR1 . SqlServer ( ) . TryGetHiLoSequence ( ) . VAR2 ) ; Assert . Equal ( LITERAL , ( ( IProperty ) VAR1 ) . SqlServer ( ) . TryGetHiLoSequence ( ) . VAR2 ) ; Assert . Equal ( LITERAL , VAR1 . SqlServer ( ) . TryGetHiLoSequence ( ) . Schema ) ; Assert . Equal ( LITERAL , ( ( IProperty ) VAR1 ) . SqlServer ( ) . TryGetHiLoSequence ( ) . Schema ) ;
Assert . Same ( typeof ( long ) , VAR0 . Type ) ; VAR1 . SqlServer ( ) . AddOrReplaceSequence ( new Sequence ( LITERAL , LITERAL , LITERAL , LITERAL , LITERAL , LITERAL , typeof ( int ) ) ) ; Assert . Null ( VAR1 . Relational ( ) . TryGetSequence ( LITERAL , LITERAL ) ) ; VAR0 = VAR1 . SqlServer ( ) . GetOrAddSequence ( LITERAL , LITERAL ) ; Assert . Equal ( LITERAL , VAR0 . VAR2 ) ; Assert . Equal ( LITERAL , VAR0 . Schema ) ; Assert . Equal ( LITERAL , VAR0 . IncrementBy ) ; Assert . Equal ( LITERAL , VAR0 . StartValue ) ; Assert . Equal ( LITERAL , VAR0 . MinValue ) ; Assert . Equal ( LITERAL , VAR0 . MaxValue ) ; Assert . Same ( typeof ( int ) , VAR0 . Type ) ;
var VAR0 = VAR1 . SchemaName ; var VAR2 = VAR1 . ColumnModifications ; var VAR3 = VAR2 . Where ( VAR4 => VAR4 . IsWrite ) . ToArray ( ) ; var VAR5 = VAR2 . Where ( VAR4 => VAR4 . IsRead ) . ToArray ( ) ; AppendInsertCommand ( VAR6 , VAR7 , VAR0 , VAR3 ) ;
Assert . Equal ( LITERAL , VAR0 . Relational ( ) . Table ) ; Assert . Equal ( LITERAL , ( ( IEntityType ) VAR0 ) . Relational ( ) . Table ) ; VAR0 . Relational ( ) . Table = LITERAL ; Assert . Equal ( LITERAL , VAR0 . DisplayName ( ) ) ; Assert . Equal ( LITERAL , ( ( IEntityType ) VAR0 ) . DisplayName ( ) ) ; Assert . Equal ( LITERAL , VAR0 . Relational ( ) . Table ) ; Assert . Equal ( LITERAL , ( ( IEntityType ) VAR0 ) . Relational ( ) . Table ) ; VAR0 . Relational ( ) . Table = null ; Assert . Equal ( LITERAL , VAR0 . Relational ( ) . Table ) ; Assert . Equal ( LITERAL , ( ( IEntityType ) VAR0 ) . Relational ( ) . Table ) ;
Assert . Same ( typeof ( long ) , VAR0 . Type ) ; VAR1 . AddOrReplaceSequence ( new Sequence ( LITERAL , LITERAL , LITERAL , LITERAL , LITERAL , LITERAL , typeof ( int ) ) ) ; VAR0 = VAR1 . GetOrAddSequence ( LITERAL , LITERAL ) ; Assert . Equal ( LITERAL , VAR0 . VAR2 ) ; Assert . Equal ( LITERAL , VAR0 . Schema ) ; Assert . Equal ( LITERAL , VAR0 . IncrementBy ) ; Assert . Equal ( LITERAL , VAR0 . StartValue ) ; Assert . Equal ( LITERAL , VAR0 . MinValue ) ; Assert . Equal ( LITERAL , VAR0 . MaxValue ) ; Assert . Same ( typeof ( int ) , VAR0 . Type ) ;
Assert . Same ( typeof ( long ) , VAR0 . Type ) ; VAR1 . AddOrReplaceSequence ( new Sequence ( LITERAL , null , LITERAL , LITERAL , LITERAL , LITERAL , typeof ( int ) ) ) ; VAR0 = VAR1 . TryGetSequence ( LITERAL ) ; Assert . Equal ( LITERAL , VAR0 . VAR2 ) ; Assert . Null ( VAR0 . Schema ) ; Assert . Equal ( LITERAL , VAR0 . IncrementBy ) ; Assert . Equal ( LITERAL , VAR0 . StartValue ) ; Assert . Equal ( LITERAL , VAR0 . MinValue ) ; Assert . Equal ( LITERAL , VAR0 . MaxValue ) ; Assert . Same ( typeof ( int ) , VAR0 . Type ) ;
Assert . Same ( typeof ( long ) , VAR0 . Type ) ; VAR1 . AddOrReplaceSequence ( new Sequence ( LITERAL , LITERAL , LITERAL , LITERAL , LITERAL , LITERAL , typeof ( int ) ) ) ; VAR0 = VAR1 . TryGetSequence ( LITERAL , LITERAL ) ; Assert . Equal ( LITERAL , VAR0 . VAR2 ) ; Assert . Equal ( LITERAL , VAR0 . Schema ) ; Assert . Equal ( LITERAL , VAR0 . IncrementBy ) ; Assert . Equal ( LITERAL , VAR0 . StartValue ) ; Assert . Equal ( LITERAL , VAR0 . MinValue ) ; Assert . Equal ( LITERAL , VAR0 . MaxValue ) ; Assert . Same ( typeof ( int ) , VAR0 . Type ) ;
Assert . Null ( VAR0 . Sqlite ( ) . DefaultValueSql ) ; Assert . Null ( ( ( IProperty ) VAR0 ) . Sqlite ( ) . DefaultValueSql ) ; VAR0 . Relational ( ) . DefaultValueSql = LITERAL ; Assert . Equal ( LITERAL , VAR0 . Sqlite ( ) . DefaultValueSql ) ; Assert . Equal ( LITERAL , ( ( IProperty ) VAR0 ) . Sqlite ( ) . DefaultValueSql ) ; VAR0 . Sqlite ( ) . DefaultValueSql = LITERAL ; Assert . Equal ( LITERAL , VAR0 . Sqlite ( ) . DefaultValueSql ) ; Assert . Equal ( LITERAL , ( ( IProperty ) VAR0 ) . Sqlite ( ) . DefaultValueSql ) ; VAR0 . Sqlite ( ) . DefaultValueSql = null ; Assert . Equal ( LITERAL , VAR0 . Sqlite ( ) . DefaultValueSql ) ; Assert . Equal ( LITERAL , ( ( IProperty ) VAR0 ) . Sqlite ( ) . DefaultValueSql ) ;
VAR0 . BaseType = VAR1 ; Assert . Equal ( new [ ] { LITERAL , LITERAL } , VAR1 . Properties . Select ( VAR2 => VAR2 . VAR3 ) . ToArray ( ) ) ; Assert . Equal ( new [ ] { LITERAL , LITERAL , LITERAL , LITERAL } , VAR0 . Properties . Select ( VAR2 => VAR2 . VAR3 ) . ToArray ( ) ) ; Assert . Equal ( new [ ] { LITERAL , LITERAL } , VAR4 . Properties . Select ( VAR2 => VAR2 . VAR3 ) . ToArray ( ) ) ; Assert . Equal ( new [ ] { 0 , 1 } , VAR1 . Properties . Select ( VAR2 => VAR2 . Index ) ) ; Assert . Equal ( new [ ] { 0 , 1 , LITERAL , LITERAL } , VAR0 . Properties . Select ( VAR2 => VAR2 . Index ) ) ; Assert . Equal ( new [ ] { 0 , 1 } , VAR4 . Properties . Select ( VAR2 => VAR2 . Index ) ) ;
Assert . Null ( ( ( IModel ) VAR0 ) . Relational ( ) . FindSequence ( LITERAL , LITERAL ) ) ; var VAR1 = VAR2 . GetOrAddSequence ( LITERAL , LITERAL ) ; Assert . Equal ( LITERAL , VAR2 . FindSequence ( LITERAL , LITERAL ) . VAR3 ) ; Assert . Equal ( LITERAL , ( ( IModel ) VAR0 ) . Relational ( ) . FindSequence ( LITERAL , LITERAL ) . VAR3 ) ;
Assert . Null ( VAR0 . IsRequired ) ; Assert . False ( ( ( IForeignKey ) VAR0 ) . IsRequired ) ; VAR1 . IsNullable = false ; Assert . Null ( VAR0 . IsRequired ) ;
var VAR0 = CreateInternalEntityTypeBuilder < A > ( ) ; var VAR1 = VAR0 . Property ( typeof ( string ) , LITERAL , ConfigurationSource . Explicit ) ; VAR1 . Required ( false , ConfigurationSource . Explicit ) ; new RequiredAttributeConvention ( ) . Apply ( VAR1 ) ;
Assert . Null ( VAR0 . SqlServer ( ) . TryGetSequence ( ) ) ; Assert . Null ( ( ( IProperty ) VAR0 ) . SqlServer ( ) . TryGetSequence ( ) ) ; VAR0 . SqlServer ( ) . SequenceName = LITERAL ; Assert . Null ( VAR0 . SqlServer ( ) . TryGetSequence ( ) ) ; Assert . Null ( ( ( IProperty ) VAR0 ) . SqlServer ( ) . TryGetSequence ( ) ) ; VAR1 . Model . SqlServer ( ) . IdentityStrategy = SqlServerIdentityStrategy . IdentityColumn ; Assert . Null ( VAR0 . SqlServer ( ) . TryGetSequence ( ) ) ; Assert . Null ( ( ( IProperty ) VAR0 ) . SqlServer ( ) . TryGetSequence ( ) ) ; VAR1 . Model . SqlServer ( ) . IdentityStrategy = null ; VAR0 . SqlServer ( ) . IdentityStrategy = SqlServerIdentityStrategy . IdentityColumn ; Assert . Null ( VAR0 . SqlServer ( ) . TryGetSequence ( ) ) ; Assert . Null ( ( ( IProperty ) VAR0 ) . SqlServer ( ) . TryGetSequence ( ) ) ;
VAR0 . SqlServer ( ) . SequenceName = LITERAL ; VAR0 . SqlServer ( ) . SequenceSchema = LITERAL ; Assert . Equal ( LITERAL , VAR0 . SqlServer ( ) . TryGetSequence ( ) . VAR1 ) ; Assert . Equal ( LITERAL , ( ( IProperty ) VAR0 ) . SqlServer ( ) . TryGetSequence ( ) . VAR1 ) ; Assert . Equal ( LITERAL , VAR0 . SqlServer ( ) . TryGetSequence ( ) . Schema ) ; Assert . Equal ( LITERAL , ( ( IProperty ) VAR0 ) . SqlServer ( ) . TryGetSequence ( ) . Schema ) ;
VAR0 . IsValueGeneratedOnAdd = true ; VAR1 . GetOrSetPrimaryKey ( VAR0 ) ; VAR1 . GetOrAddProperty ( LITERAL , typeof ( string ) ) . IsConcurrencyToken = true ; var VAR2 = VAR3 . AddEntityType ( typeof ( SomeDependentEntity ) ) ; var VAR4 = VAR2 . GetOrAddProperty ( LITERAL , typeof ( int ) ) ; var VAR5 = VAR2 . GetOrAddProperty ( LITERAL , typeof ( string ) ) ; VAR2 . GetOrSetPrimaryKey ( new [ ] { VAR4 , VAR5 } ) ; var VAR6 = VAR2 . GetOrAddProperty ( LITERAL , typeof ( int ) ) ; VAR2 . GetOrAddForeignKey ( new [ ] { VAR6 } , VAR1 . GetPrimaryKey ( ) ) ; var VAR7 = VAR2 . GetOrAddProperty ( LITERAL , typeof ( int ) ) ; VAR7 . IsValueGeneratedOnAdd = true ;
VAR0 . IsValueGeneratedOnAdd = true ; VAR1 . GetOrSetPrimaryKey ( VAR0 ) ; VAR1 . GetOrAddProperty ( LITERAL , typeof ( string ) , shadowProperty : true ) . IsConcurrencyToken = true ; var VAR2 = VAR3 . AddEntityType ( typeof ( SomeDependentEntity ) . FullName ) ; var VAR4 = VAR2 . GetOrAddProperty ( LITERAL , typeof ( int ) , shadowProperty : true ) ; var VAR5 = VAR2 . GetOrAddProperty ( LITERAL , typeof ( string ) , shadowProperty : true ) ; VAR2 . GetOrSetPrimaryKey ( new [ ] { VAR4 , VAR5 } ) ; var VAR6 = VAR2 . GetOrAddProperty ( LITERAL , typeof ( int ) , shadowProperty : true ) ; VAR2 . GetOrAddForeignKey ( new [ ] { VAR6 } , VAR1 . GetPrimaryKey ( ) ) ; var VAR7 = VAR2 . GetOrAddProperty ( LITERAL , typeof ( int ) , shadowProperty : true ) ; VAR7 . IsValueGeneratedOnAdd = true ;
VAR0 . StoreGeneratedPattern ( StoreGeneratedPattern . Identity , ConfigurationSource . Convention ) ; new DatabaseGeneratedAttributeConvention ( ) . Apply ( VAR0 ) ; Assert . Equal ( StoreGeneratedPattern . Computed , VAR0 . Metadata . StoreGeneratedPattern ) ;
VAR0 . Property ( VAR1 => VAR1 . Up ) . StoreGeneratedPattern ( StoreGeneratedPattern . Computed ) ; VAR0 . Property ( VAR1 => VAR1 . Down ) . StoreGeneratedPattern ( StoreGeneratedPattern . None ) ; VAR0 . Property < int > ( LITERAL ) . StoreGeneratedPattern ( StoreGeneratedPattern . Identity ) ; VAR0 . Property < string > ( LITERAL ) . StoreGeneratedPattern ( StoreGeneratedPattern . None ) ; VAR0 . Property < int > ( LITERAL ) . StoreGeneratedPattern ( StoreGeneratedPattern . Computed ) ; VAR0 . Property < string > ( LITERAL ) . StoreGeneratedPattern ( StoreGeneratedPattern . None ) ;
Assert . Null ( VAR0 . IsValueGeneratedOnAdd ) ; VAR0 . SqlServer ( ) . IdentityStrategy = null ; Assert . Null ( VAR0 . SqlServer ( ) . IdentityStrategy ) ; Assert . Null ( ( ( IProperty ) VAR0 ) . SqlServer ( ) . IdentityStrategy ) ; Assert . Null ( VAR0 . IsValueGeneratedOnAdd ) ;
Assert . Null ( VAR0 . IsValueGeneratedOnAdd ) ; Assert . False ( ( ( IProperty ) VAR0 ) . IsValueGeneratedOnAdd ) ; VAR0 . SqlServer ( ) . IdentityStrategy = SqlServerIdentityStrategy . SequenceHiLo ; Assert . Equal ( SqlServerIdentityStrategy . SequenceHiLo , VAR0 . SqlServer ( ) . IdentityStrategy ) ; Assert . Equal ( SqlServerIdentityStrategy . SequenceHiLo , ( ( IProperty ) VAR0 ) . SqlServer ( ) . IdentityStrategy ) ; Assert . Null ( VAR0 . IsValueGeneratedOnAdd ) ;
Assert . Null ( VAR0 . IsValueGeneratedOnAdd ) ; Assert . False ( ( ( IProperty ) VAR0 ) . IsValueGeneratedOnAdd ) ; VAR0 . SqlServer ( ) . IdentityStrategy = SqlServerIdentityStrategy . SequenceHiLo ; Assert . Equal ( SqlServerIdentityStrategy . SequenceHiLo , VAR0 . SqlServer ( ) . IdentityStrategy ) ; Assert . Equal ( SqlServerIdentityStrategy . SequenceHiLo , ( ( IProperty ) VAR0 ) . SqlServer ( ) . IdentityStrategy ) ; Assert . Null ( VAR0 . IsValueGeneratedOnAdd ) ; VAR0 . SqlServer ( ) . IdentityStrategy = null ; Assert . Null ( VAR0 . SqlServer ( ) . IdentityStrategy ) ; Assert . Null ( ( ( IProperty ) VAR0 ) . SqlServer ( ) . IdentityStrategy ) ; Assert . Null ( VAR0 . IsValueGeneratedOnAdd ) ;
Assert . Same ( VAR0 . Metadata , VAR1 . Metadata . EntityType ) ; VAR1 = VAR1 . Invert ( ConfigurationSource . DataAnnotation ) ; Assert . Same ( VAR2 . Metadata , VAR1 . Metadata . EntityType ) ; VAR1 = VAR1 . Invert ( ConfigurationSource . DataAnnotation ) ; Assert . Same ( VAR0 . Metadata , VAR1 . Metadata . EntityType ) ; Assert . Null ( VAR1 . Invert ( ConfigurationSource . Convention ) ) ; Assert . Same ( VAR0 . Metadata , VAR1 . Metadata . EntityType ) ; VAR1 = VAR1 . ForeignKey ( new [ ] { VAR3 . VAR4 } , ConfigurationSource . DataAnnotation ) ; Assert . Null ( VAR1 . Invert ( ConfigurationSource . DataAnnotation ) ) ; Assert . Same ( VAR0 . Metadata , VAR1 . Metadata . EntityType ) ;
VAR0 . GetOrAddForeignKey ( VAR0 . GetOrAddProperty ( LITERAL , typeof ( int ) ) , VAR1 . GetPrimaryKey ( ) ) ; VAR1 . GetOrAddForeignKey ( VAR1 . GetOrAddProperty ( LITERAL , typeof ( int ) ) , VAR2 . GetPrimaryKey ( ) ) ; VAR2 . GetOrAddForeignKey ( VAR2 . GetOrAddProperty ( LITERAL , typeof ( int ) ) , VAR0 . GetPrimaryKey ( ) ) ; VAR0 . GetOrAddForeignKey ( VAR0 . GetOrAddProperty ( LITERAL , typeof ( int ) ) , VAR3 . GetPrimaryKey ( ) ) ; VAR3 . GetOrAddForeignKey ( VAR3 . GetOrAddProperty ( LITERAL , typeof ( int ) ) , VAR4 . GetPrimaryKey ( ) ) ; VAR4 . GetOrAddForeignKey ( VAR4 . GetOrAddProperty ( LITERAL , typeof ( int ) ) , VAR0 . GetPrimaryKey ( ) ) ;
Assert . Null ( VAR0 . SqlServer ( ) . ValueGenerationStrategy ) ; Assert . Null ( ( ( IProperty ) VAR0 ) . SqlServer ( ) . ValueGenerationStrategy ) ; Assert . Null ( VAR0 . IsValueGeneratedOnAdd ) ; Assert . False ( ( ( IProperty ) VAR0 ) . IsValueGeneratedOnAdd ) ; VAR0 . SqlServer ( ) . ValueGenerationStrategy = SqlServerValueGenerationStrategy . Sequence ; Assert . Equal ( SqlServerValueGenerationStrategy . Sequence , VAR0 . SqlServer ( ) . ValueGenerationStrategy ) ; Assert . Equal ( SqlServerValueGenerationStrategy . Sequence , ( ( IProperty ) VAR0 ) . SqlServer ( ) . ValueGenerationStrategy ) ; Assert . Null ( VAR0 . IsValueGeneratedOnAdd ) ; VAR0 . SqlServer ( ) . ValueGenerationStrategy = null ; Assert . Null ( VAR0 . SqlServer ( ) . ValueGenerationStrategy ) ; Assert . Null ( ( ( IProperty ) VAR0 ) . SqlServer ( ) . ValueGenerationStrategy ) ;
Assert . Null ( VAR0 . SqlServer ( ) . ValueGenerationStrategy ) ; Assert . Null ( ( ( IProperty ) VAR0 ) . SqlServer ( ) . ValueGenerationStrategy ) ; Assert . Null ( VAR0 . IsValueGeneratedOnAdd ) ; Assert . False ( ( ( IProperty ) VAR0 ) . IsValueGeneratedOnAdd ) ; VAR0 . SqlServer ( ) . ValueGenerationStrategy = SqlServerValueGenerationStrategy . Sequence ; Assert . Equal ( SqlServerValueGenerationStrategy . Sequence , VAR0 . SqlServer ( ) . ValueGenerationStrategy ) ; Assert . Equal ( SqlServerValueGenerationStrategy . Sequence , ( ( IProperty ) VAR0 ) . SqlServer ( ) . ValueGenerationStrategy ) ; Assert . Null ( VAR0 . IsValueGeneratedOnAdd ) ; VAR0 . SqlServer ( ) . ValueGenerationStrategy = null ; Assert . Null ( VAR0 . SqlServer ( ) . ValueGenerationStrategy ) ; Assert . Null ( ( ( IProperty ) VAR0 ) . SqlServer ( ) . ValueGenerationStrategy ) ;
VerifyScoped < IDataStoreSelector > ( ) ; VerifyScoped < ValueGeneratorSelector > ( ) ; VerifyScoped < IModel > ( ) ; VerifyScoped < DbContext > ( ) ; VerifyScoped < IDbContextOptions > ( ) ; VerifyScoped < IDataStoreServices > ( ) ; VerifyScoped < IDataStore > ( ) ; VerifyScoped < IQueryContextFactory > ( ) ; VerifyScoped < IDataStoreConnection > ( ) ; VerifyScoped < IValueGeneratorSelector > ( ) ; VerifyScoped < IDataStoreCreator > ( ) ;
Assert . Null ( VAR0 . Database . GetRelationalConnection ( ) . CommandTimeout ) ; VAR0 . Database . GetRelationalConnection ( ) . CommandTimeout = LITERAL ; Assert . Equal ( LITERAL , VAR0 . Database . GetRelationalConnection ( ) . CommandTimeout ) ; VAR0 . Database . GetRelationalConnection ( ) . CommandTimeout = null ; Assert . Null ( VAR0 . Database . GetRelationalConnection ( ) . CommandTimeout ) ;
VAR0 . Table ( LITERAL , LITERAL ) ; VAR0 . Property < int > ( LITERAL ) ; VAR0 . Key ( LITERAL ) ; VAR0 . Property < int > ( LITERAL ) ; VAR0 . Property < int > ( LITERAL ) ; VAR0 . AlternateKey ( LITERAL ) . Name ( LITERAL ) ;
VAR0 . Table ( LITERAL , LITERAL ) ; VAR0 . Property < int > ( LITERAL ) ; VAR0 . Key ( LITERAL ) ; VAR0 . Property < int > ( LITERAL ) ; VAR0 . Index ( LITERAL ) . Name ( LITERAL ) ;
VAR0 . Table ( LITERAL , LITERAL ) ; VAR0 . Property < int > ( LITERAL ) ; VAR0 . Key ( LITERAL ) ; VAR0 . Property < int > ( LITERAL ) ; VAR0 . Property < int > ( LITERAL ) ; VAR0 . Index ( LITERAL ) . Name ( LITERAL ) ;
VAR0 . Table ( LITERAL , LITERAL ) ; VAR0 . Property < int > ( LITERAL ) ; VAR0 . Key ( LITERAL ) ; VAR0 . Property < int > ( LITERAL ) ; VAR0 . AlternateKey ( LITERAL ) . ForSqlServer ( ) . Name ( LITERAL ) ;
VAR0 . Table ( LITERAL , LITERAL ) ; VAR0 . Property < int > ( LITERAL ) ; VAR0 . Key ( LITERAL ) ; VAR0 . Property < int > ( LITERAL ) ; VAR0 . Reference ( LITERAL ) . InverseCollection ( ) . ForeignKey ( LITERAL ) . ForSqlServer ( ) . Name ( LITERAL ) ;
VAR0 . Property ( VAR1 => VAR1 . VAR2 ) . GenerateValueOnAdd ( false ) ; VAR0 . Property ( VAR1 => VAR1 . VAR3 ) . GenerateValueOnAdd ( ) ; VAR0 . Property ( VAR1 => VAR1 . VAR4 ) . GenerateValueOnAdd ( true ) ; VAR0 . Property < int > ( LITERAL ) . GenerateValueOnAdd ( ) ; VAR0 . Property < string > ( LITERAL ) . GenerateValueOnAdd ( false ) ; VAR0 . Property ( typeof ( int ) , LITERAL ) . GenerateValueOnAdd ( ) ; VAR0 . Property ( typeof ( string ) , LITERAL ) . GenerateValueOnAdd ( false ) ;
var VAR0 = new InMemoryDataStoreCreator ( CreateStore ( VAR1 , VAR2 : true ) ) ; Assert . True ( VAR0 . EnsureCreated ( VAR3 ) ) ; Assert . False ( VAR0 . EnsureCreated ( VAR3 ) ) ; Assert . False ( VAR0 . EnsureCreated ( VAR3 ) ) ; VAR0 = new InMemoryDataStoreCreator ( CreateStore ( VAR1 , VAR2 : true ) ) ; Assert . False ( VAR0 . EnsureCreated ( VAR3 ) ) ;
VAR0 . Verify ( VAR1 => VAR1 . CreateTables ( VAR2 ) , Times . Once ) ; Assert . True ( VAR3 . HasTables ( ) ) ; VAR0 . Verify ( VAR1 => VAR1 . HasTables ( ) , Times . Once ) ; VAR3 . Delete ( ) ; VAR0 . Verify ( VAR1 => VAR1 . Delete ( ) , Times . Once ) ; Assert . True ( VAR3 . EnsureCreated ( ) ) ; VAR0 . Verify ( VAR1 => VAR1 . EnsureCreated ( VAR2 ) , Times . Once ) ; Assert . True ( VAR3 . EnsureDeleted ( ) ) ; VAR0 . Verify ( VAR1 => VAR1 . EnsureDeleted ( VAR2 ) , Times . Once ) ;
var VAR0 = ( RelationalSizedTypeMapping ) new SqlServerTypeMapper ( ) . MapPropertyType ( VAR1 ) ; Assert . Null ( VAR0 . StoreType ) ; Assert . Equal ( LITERAL , VAR0 . DefaultTypeName ) ; Assert . Equal ( LITERAL , VAR0 . Size ) ;
var VAR0 = ( RelationalSizedTypeMapping ) new SqlServerTypeMapper ( ) . MapPropertyType ( VAR1 ) ; Assert . Equal ( DbType . Binary , VAR0 . StoreType ) ; Assert . Equal ( LITERAL , VAR0 . DefaultTypeName ) ; Assert . Equal ( LITERAL , VAR0 . Size ) ;
VerifySingleton < SqlServerModelSource > ( ) ; VerifyScoped < SqlServerCommandBatchPreparer > ( ) ; VerifyScoped < SqlServerValueGeneratorSelector > ( ) ; VerifyScoped < SqlServerDataStoreServices > ( ) ;
var VAR0 = ( IForeignKey ) VAR1 . Metadata . ForeignKeys . Single ( ) ; Assert . Same ( VAR0 , VAR2 . Metadata ) ; Assert . Same ( VAR3 . Metadata , VAR0 . Properties [ 0 ] ) ; Assert . Same ( VAR4 . Metadata , VAR0 . Properties [ 1 ] ) ; Assert . Same ( VAR5 [ 0 ] , VAR0 . PrincipalKey . Properties [ 0 ] ) ; Assert . Same ( VAR5 [ 1 ] , VAR0 . PrincipalKey . Properties [ 1 ] ) ; Assert . False ( VAR0 . IsUnique ) ;
var VAR0 = ( IForeignKey ) VAR1 . Metadata . ForeignKeys . Single ( ) ; Assert . Same ( VAR0 , VAR2 . Metadata ) ; Assert . Same ( VAR3 . Metadata . GetPrimaryKey ( ) , VAR0 . PrincipalKey ) ; Assert . True ( VAR0 . IsUnique ) ; Assert . True ( VAR0 . IsRequired ) ; Assert . Empty ( VAR3 . Metadata . ForeignKeys ) ;
var VAR0 = new ModificationCommand ( LITERAL , null , new ParameterNameGenerator ( ) , VAR1 => VAR1 . Relational ( ) , new BoxedValueReaderSource ( ) , new NonTypedValueReaderFactoryFactory ( ) ) ; VAR0 . AddEntry ( VAR2 ) ; var VAR3 = VAR4 . GetOrCreateEntry ( new object ( ) ) ; VAR3 [ VAR5 ] = LITERAL ; VAR3 . SetEntityState ( EntityState . Modified ) ; var VAR6 = new ModificationCommand ( LITERAL , null , new ParameterNameGenerator ( ) , VAR1 => VAR1 . Relational ( ) , new BoxedValueReaderSource ( ) , new NonTypedValueReaderFactoryFactory ( ) ) ; VAR6 . AddEntry ( VAR3 ) ; var VAR7 = VAR4 . GetOrCreateEntry ( new object ( ) ) ; VAR7 [ VAR5 ] = LITERAL ; VAR7 . SetEntityState ( EntityState . Deleted ) ; var VAR8 = new ModificationCommand ( LITERAL , null , new ParameterNameGenerator ( ) , VAR1 => VAR1 . Relational ( ) , new BoxedValueReaderSource ( ) , new NonTypedValueReaderFactoryFactory ( ) ) ;
Assert . Equal ( VAR0 . VAR1 . VAR2 , VAR3 . Metadata . GetNavigationToDependent ( ) . VAR2 ) ; Assert . Equal ( Order . VAR4 . VAR2 , VAR3 . Metadata . GetNavigationToPrincipal ( ) . VAR2 ) ; Assert . Null ( VAR5 . Metadata . GetNavigationToDependent ( ) ) ; Assert . Null ( VAR5 . Metadata . GetNavigationToPrincipal ( ) ) ;
VerifySingleton < SqlServerSequenceValueGeneratorFactory > ( ) ; VerifySingleton < ISqlServerSqlGenerator > ( ) ; VerifySingleton < SqlStatementExecutor > ( ) ; VerifySingleton < SqlServerTypeMapper > ( ) ; VerifySingleton < SqlServerModificationCommandBatchFactory > ( ) ; VerifySingleton < SqlServerCommandBatchPreparer > ( ) ;
VAR0 . Property ( VAR1 => VAR1 . VAR2 ) . StoreComputed ( ) ; VAR0 . Property ( VAR1 => VAR1 . VAR3 ) . StoreComputed ( false ) ; VAR0 . Property < int > ( LITERAL ) . StoreComputed ( ) ; VAR0 . Property < string > ( LITERAL ) . StoreComputed ( false ) ; VAR0 . Property ( typeof ( int ) , LITERAL ) . StoreComputed ( ) ; VAR0 . Property ( typeof ( string ) , LITERAL ) . StoreComputed ( false ) ;
var VAR0 = ModelBuilder . Entity ( VAR1 . PrincipalEntityType . Name , ConfigurationSource . Convention ) ; var VAR2 = VAR1 . GetNavigationToDependent ( ) ; VAR2 ? . EntityType . RemoveNavigation ( VAR2 ) ; var VAR3 = VAR1 . GetNavigationToPrincipal ( ) ; VAR3 ? . EntityType . RemoveNavigation ( VAR3 ) ; Metadata . RemoveForeignKey ( VAR1 ) ; ModelBuilder . ConventionDispatcher . OnForeignKeyRemoved ( this , VAR1 ) ; RemoveShadowPropertiesIfUnused ( VAR1 . Properties ) ; VAR0 . RemoveKeyIfUnused ( VAR1 . PrincipalKey ) ;
Assert . Same ( typeof ( int ) , VAR0 . PropertyType ) ; Assert . False ( VAR0 . IsConcurrencyToken ) ; Assert . Same ( VAR1 , VAR0 . EntityType ) ; Assert . Same ( VAR0 , VAR1 . GetOrAddProperty ( VAR2 . VAR3 ) ) ; Assert . Same ( VAR0 , VAR1 . GetOrAddProperty ( LITERAL , typeof ( int ) , shadowProperty : true ) ) ; Assert . False ( VAR0 . IsShadowProperty ) ; var VAR4 = ( IProperty ) VAR1 . GetOrAddProperty ( LITERAL , typeof ( string ) , shadowProperty : true ) ; Assert . True ( VAR4 . IsShadowProperty ) ; Assert . Equal ( LITERAL , VAR4 . VAR5 ) ; Assert . Same ( typeof ( string ) , VAR4 . PropertyType ) ;
Assert . Null ( VAR0 . TryGetPrimaryKey ( ) ) ; Assert . Equal ( LITERAL , VAR0 . Keys . Count ) ; Assert . Null ( VAR0 . SetPrimaryKey ( new Property [ 0 ] ) ) ; Assert . Null ( VAR0 . TryGetPrimaryKey ( ) ) ;
Assert . NotNull ( VAR0 . Metadata . TryGetNavigation ( Order . VAR1 . VAR2 ) ) ; Assert . NotNull ( VAR3 . Metadata . TryGetNavigation ( VAR4 . VAR5 . VAR2 ) ) ; Assert . True ( VAR0 . Navigation ( null , VAR6 , pointsToPrincipal : true , configurationSource : ConfigurationSource . Explicit ) ) ; Assert . True ( VAR3 . Navigation ( null , VAR6 , pointsToPrincipal : false , configurationSource : ConfigurationSource . Explicit ) ) ; Assert . Null ( VAR0 . Metadata . TryGetNavigation ( Order . VAR1 . VAR2 ) ) ; Assert . Null ( VAR3 . Metadata . TryGetNavigation ( VAR4 . VAR5 . VAR2 ) ) ;
Assert . NotNull ( VAR0 . TryGetEntityType ( typeof ( Customer ) ) ) ; Assert . Same ( VAR0 , VAR1 . Model ) ; Assert . Same ( VAR1 , VAR0 . GetOrAddEntityType ( typeof ( Customer ) ) ) ; Assert . Equal ( new [ ] { VAR1 } , VAR0 . EntityTypes . ToArray ( ) ) ; Assert . Same ( VAR1 , VAR0 . RemoveEntityType ( VAR1 ) ) ; Assert . Null ( VAR0 . RemoveEntityType ( VAR1 ) ) ; Assert . Null ( VAR0 . TryGetEntityType ( typeof ( Customer ) ) ) ;
Assert . Equal ( 1 , VAR0 . PropertyCount ) ; Assert . Equal ( 1 , VAR0 . GetKeys ( ) . Count ( ) ) ; Assert . Empty ( VAR0 . GetForeignKeys ( ) ) ; Assert . Equal ( VAR1 . VAR2 . Name , VAR0 . GetNavigations ( ) . Single ( ) . Name ) ; Assert . Equal ( LITERAL , VAR3 . PropertyCount ) ;
var VAR0 = new ModificationCommand ( LITERAL , null , new ParameterNameGenerator ( ) , VAR1 => VAR1 . Relational ( ) ) ; VAR0 . AddEntry ( VAR2 ) ; var VAR3 = VAR4 . GetOrCreateEntry ( new object ( ) ) ; VAR3 [ VAR5 ] = LITERAL ; VAR3 . SetEntityState ( EntityState . Modified ) ; var VAR6 = new ModificationCommand ( LITERAL , null , new ParameterNameGenerator ( ) , VAR1 => VAR1 . Relational ( ) ) ;
VAR0 = VAR1 . GetRequiredService < DataStore > ( ) ; VAR2 = VAR1 . GetRequiredService < DataStoreCreator > ( ) ; VAR3 = VAR1 . GetRequiredService < DataStoreConnection > ( ) ; Assert . Same ( VAR0 , VAR1 . GetRequiredService < DataStore > ( ) ) ; Assert . Same ( VAR2 , VAR1 . GetRequiredService < DataStoreCreator > ( ) ) ; Assert . Same ( VAR3 , VAR1 . GetRequiredService < DataStoreConnection > ( ) ) ;
Check . NotNull ( VAR0 , LITERAL ) ; Check . NotNull ( VAR1 , LITERAL ) ; var VAR2 = ModelBuilder . Entity ( VAR0 . Name , VAR3 ) ; Debug . Assert ( VAR2 != null ) ; var VAR4 = ModelBuilder . Entity ( VAR1 . Name , VAR3 ) ; Debug . Assert ( VAR4 != null ) ;
Check . NotNull ( VAR0 , LITERAL ) ; Check . NotNull ( VAR1 , LITERAL ) ; Check . NotNull ( VAR2 , LITERAL ) ; Check . NotNull ( VAR3 , LITERAL ) ; Check . NotNull ( VAR4 , LITERAL ) ; Check . NotNull ( VAR5 , LITERAL ) ;
Assert . Equal ( 1 , VAR0 . Next ( new DbContextService < DataStoreServices > ( ( ) => null ) ) ) ; Assert . Equal ( LITERAL , VAR0 . Next ( new DbContextService < DataStoreServices > ( ( ) => null ) ) ) ; Assert . Equal ( LITERAL , VAR0 . Next ( new DbContextService < DataStoreServices > ( ( ) => null ) ) ) ; Assert . Equal ( LITERAL , VAR0 . Next ( new DbContextService < DataStoreServices > ( ( ) => null ) ) ) ; Assert . Equal ( LITERAL , VAR0 . Next ( new DbContextService < DataStoreServices > ( ( ) => null ) ) ) ; Assert . Equal ( LITERAL , VAR0 . Next ( new DbContextService < DataStoreServices > ( ( ) => null ) ) ) ; VAR0 = new InMemoryIntegerValueGenerator < int > ( ) ; Assert . Equal ( 1 , VAR0 . Next ( new DbContextService < DataStoreServices > ( ( ) => null ) ) ) ; Assert . Equal ( LITERAL , VAR0 . Next ( new DbContextService < DataStoreServices > ( ( ) => null ) ) ) ;
GenerateUsings ( VAR0 ) ; CSharpCodeGeneratorHelper . Instance . BeginNamespace ( VAR1 , VAR0 ) ; CSharpCodeGeneratorHelper . Instance . BeginClass ( AccessModifier . Public , VAR2 , isPartial : true , VAR0 : VAR0 , inheritsFrom : new string [  ] { LITERAL } ) ; GenerateProperties ( VAR0 ) ; GenerateMethods ( VAR0 ) ; CSharpCodeGeneratorHelper . Instance . EndClass ( VAR0 ) ; CSharpCodeGeneratorHelper . Instance . EndNamespace ( VAR0 ) ;
var VAR0 = new Mock < ValueGeneratorCache > ( ) ; VAR0 . Setup ( VAR1 => VAR1 . GetGenerator ( It . IsAny < IProperty > ( ) ) ) . Returns ( Mock . Of < ValueGenerator > ( ) ) ; var VAR2 = new Mock < DataStoreServices > ( ) ; VAR2 . Setup ( VAR1 => VAR1 . Store ) . Returns ( VAR3 . Object ) ; VAR2 . Setup ( VAR1 => VAR1 . ValueGeneratorCache ) . Returns ( VAR0 . Object ) ;
VerifySingleton < ValueGeneratorFactory < TemporaryIntegerValueGenerator > > ( ) ; VerifySingleton < ValueGeneratorFactory < TemporaryStringValueGenerator > > ( ) ; VerifySingleton < ValueGeneratorFactory < TemporaryBinaryValueGenerator > > ( ) ; VerifySingleton < ValueGeneratorFactory < GuidValueGenerator > > ( ) ; VerifySingleton < ValueGeneratorFactory < SequentialGuidValueGenerator > > ( ) ;
HandleEntity ( VAR0 , VAR1 : false ) ; Assert . Equal ( EntityState . Added , VAR0 . State ) ; Assert . Equal ( 1 , VAR0 . Entity . VAR2 ) ; VAR0 = VAR3 . Entry ( new Stoat { VAR2 = LITERAL } ) ; HandleEntity ( VAR0 , VAR1 : false ) ;
HandleEntity ( VAR0 , VAR1 : false ) ; Assert . Equal ( EntityState . Unchanged , VAR0 . State ) ; Assert . Equal ( VAR2 , VAR0 . Entity . VAR3 ) ; Assert . Equal ( LITERAL , VAR0 . Entity . VAR4 ) ; VAR0 = VAR5 . Entry ( new CompositeStoat { VAR3 = VAR2 , VAR4 = LITERAL } ) ; HandleEntity ( VAR0 , VAR1 : true ) ;
var VAR0 = VAR1 . Properties . Count ; var VAR2 = VAR3 . Properties . Count ; var VAR4 = VAR1 . Keys . Single ( ) ; var VAR5 = VAR3 . Keys . Single ( ) ; VAR6 . Entity ( typeof ( VAR7 ) ) . HasMany ( typeof ( VAR8 ) , null ) . WithOne ( null ) ; var VAR9 = VAR3 . ForeignKeys . Single ( ) ; Assert . Same ( VAR10 , VAR9 . Properties . Single ( ) ) ; Assert . Empty ( VAR3 . Navigations ) ; Assert . Empty ( VAR1 . Navigations ) ; Assert . Equal ( VAR0 , VAR1 . Properties . Count ) ; Assert . Equal ( VAR2 , VAR3 . Properties . Count ) ;
var VAR0 = VAR1 . Properties . Count ; var VAR2 = VAR3 . Properties . Count ; var VAR4 = VAR1 . Keys . Single ( ) ; var VAR5 = VAR3 . Keys . Single ( ) ; VAR6 . Entity ( typeof ( VAR7 ) ) . HasOne ( typeof ( VAR8 ) , LITERAL ) . WithMany ( LITERAL ) ; Assert . Same ( VAR9 , VAR3 . ForeignKeys . Single ( ) ) ; Assert . Equal ( LITERAL , VAR3 . Navigations . Single ( ) . VAR10 ) ; Assert . Equal ( LITERAL , VAR1 . Navigations . Single ( ) . VAR10 ) ; Assert . Same ( VAR9 , VAR3 . Navigations . Single ( ) . ForeignKey ) ; Assert . Same ( VAR9 , VAR1 . Navigations . Single ( ) . ForeignKey ) ; Assert . Equal ( VAR0 , VAR1 . Properties . Count ) ; Assert . Equal ( VAR2 , VAR3 . Properties . Count ) ;
var VAR0 = VAR1 . Properties . Count ; var VAR2 = VAR3 . Properties . Count ; var VAR4 = VAR1 . Keys . Single ( ) ; var VAR5 = VAR3 . Keys . Single ( ) ; VAR6 . Entity ( typeof ( VAR7 ) ) . HasOne ( typeof ( CustomerDetails ) , LITERAL ) . WithOne ( null ) ; var VAR8 = VAR3 . ForeignKeys . Single ( ) ; Assert . Same ( VAR9 , VAR8 . Properties . Single ( ) ) ; Assert . Empty ( VAR3 . Navigations ) ; Assert . Equal ( LITERAL , VAR1 . Navigations . Single ( ) . VAR10 ) ; Assert . Same ( VAR8 , VAR1 . Navigations . Single ( ) . ForeignKey ) ; Assert . Equal ( VAR0 , VAR1 . Properties . Count ) ; Assert . Equal ( VAR2 , VAR3 . Properties . Count ) ;
var VAR0 = VAR1 . Properties . Count ; var VAR2 = VAR3 . Properties . Count ; var VAR4 = VAR1 . Keys . Single ( ) ; var VAR5 = VAR3 . Keys . Single ( ) ; VAR6 . Entity ( typeof ( VAR7 ) ) . HasOne ( typeof ( CustomerDetails ) , null ) . WithOne ( LITERAL ) ; var VAR8 = VAR3 . ForeignKeys . Single ( ) ; Assert . Same ( VAR9 , VAR8 . Properties . Single ( ) ) ; Assert . Equal ( LITERAL , VAR3 . Navigations . Single ( ) . VAR10 ) ; Assert . Empty ( VAR1 . Navigations ) ; Assert . Same ( VAR8 , VAR3 . Navigations . Single ( ) . ForeignKey ) ; Assert . Equal ( VAR0 , VAR1 . Properties . Count ) ; Assert . Equal ( VAR2 , VAR3 . Properties . Count ) ;
var VAR0 = VAR1 . Properties . Count ; var VAR2 = VAR3 . Properties . Count ; var VAR4 = VAR1 . Keys . Single ( ) ; var VAR5 = VAR3 . Keys . Single ( ) ; VAR6 . Entity ( typeof ( VAR7 ) . FullName ) . HasMany ( typeof ( VAR8 ) . FullName , LITERAL ) . WithOne ( LITERAL ) ; Assert . Same ( VAR9 , VAR3 . ForeignKeys . Single ( ) ) ; Assert . Same ( VAR10 , VAR3 . Navigations . Single ( ) ) ; Assert . Same ( VAR11 , VAR1 . Navigations . Single ( ) ) ; Assert . Same ( VAR9 , VAR3 . Navigations . Single ( ) . ForeignKey ) ; Assert . Same ( VAR9 , VAR1 . Navigations . Single ( ) . ForeignKey ) ; Assert . Equal ( VAR0 , VAR1 . Properties . Count ) ; Assert . Equal ( VAR2 , VAR3 . Properties . Count ) ;
var VAR0 = VAR1 . Properties . Count ; var VAR2 = VAR3 . Properties . Count ; var VAR4 = VAR1 . Keys . Single ( ) ; var VAR5 = VAR3 . Keys . Single ( ) ; VAR6 . Entity ( typeof ( VAR7 ) . FullName ) . HasMany ( typeof ( VAR8 ) . FullName , null ) . WithOne ( LITERAL ) ; var VAR9 = VAR3 . ForeignKeys . Single ( ) ; Assert . Same ( VAR10 , VAR9 . Properties . Single ( ) ) ; Assert . Equal ( LITERAL , VAR3 . Navigations . Single ( ) . VAR11 ) ; Assert . Empty ( VAR1 . Navigations ) ; Assert . Same ( VAR9 , VAR3 . Navigations . Single ( ) . ForeignKey ) ; Assert . Equal ( VAR0 , VAR1 . Properties . Count ) ; Assert . Equal ( VAR2 , VAR3 . Properties . Count ) ;
var VAR0 = VAR1 . Properties . Count ; var VAR2 = VAR3 . Properties . Count ; var VAR4 = VAR1 . Keys . Single ( ) ; var VAR5 = VAR3 . Keys . Single ( ) ; VAR6 . Entity ( typeof ( VAR7 ) . FullName ) . HasOne ( typeof ( VAR8 ) . FullName , LITERAL ) . WithMany ( LITERAL ) ; Assert . Same ( VAR9 , VAR3 . ForeignKeys . Single ( ) ) ; Assert . Same ( VAR10 , VAR3 . Navigations . Single ( ) ) ; Assert . Equal ( LITERAL , VAR1 . Navigations . Single ( ) . VAR11 ) ; Assert . Same ( VAR9 , VAR3 . Navigations . Single ( ) . ForeignKey ) ; Assert . Same ( VAR9 , VAR1 . Navigations . Single ( ) . ForeignKey ) ; Assert . Equal ( VAR0 , VAR1 . Properties . Count ) ; Assert . Equal ( VAR2 , VAR3 . Properties . Count ) ;
var VAR0 = VAR1 . Properties . Count ; var VAR2 = VAR3 . Properties . Count ; var VAR4 = VAR1 . Keys . Single ( ) ; var VAR5 = VAR3 . Keys . Single ( ) ; VAR6 . Entity ( typeof ( VAR7 ) . FullName ) . HasOne ( typeof ( VAR8 ) . FullName , LITERAL ) . WithMany ( LITERAL ) ; Assert . Same ( VAR9 , VAR3 . ForeignKeys . Single ( ) ) ; Assert . Equal ( LITERAL , VAR3 . Navigations . Single ( ) . VAR10 ) ; Assert . Same ( VAR11 , VAR1 . Navigations . Single ( ) ) ; Assert . Same ( VAR9 , VAR3 . Navigations . Single ( ) . ForeignKey ) ; Assert . Same ( VAR9 , VAR1 . Navigations . Single ( ) . ForeignKey ) ; Assert . Equal ( VAR0 , VAR1 . Properties . Count ) ; Assert . Equal ( VAR2 , VAR3 . Properties . Count ) ;
var VAR0 = VAR1 . Properties . Count ; var VAR2 = VAR3 . Properties . Count ; var VAR4 = VAR1 . Keys . Single ( ) ; var VAR5 = VAR3 . Keys . Single ( ) ; VAR6 . Entity ( typeof ( VAR7 ) . FullName ) . HasOne ( typeof ( VAR8 ) . FullName , LITERAL ) . WithMany ( LITERAL ) ; Assert . Same ( VAR9 , VAR3 . ForeignKeys . Single ( ) ) ; Assert . Equal ( LITERAL , VAR3 . Navigations . Single ( ) . VAR10 ) ; Assert . Equal ( LITERAL , VAR1 . Navigations . Single ( ) . VAR10 ) ; Assert . Same ( VAR9 , VAR3 . Navigations . Single ( ) . ForeignKey ) ; Assert . Same ( VAR9 , VAR1 . Navigations . Single ( ) . ForeignKey ) ; Assert . Equal ( VAR0 , VAR1 . Properties . Count ) ; Assert . Equal ( VAR2 , VAR3 . Properties . Count ) ;
Assert . Same ( VAR0 , VAR1 . Properties . Single ( ) ) ; Assert . Same ( VAR2 , VAR1 . ReferencedProperties . Single ( ) ) ; Assert . Equal ( LITERAL , VAR3 . Navigations . Single ( ) . VAR4 ) ; Assert . Equal ( LITERAL , VAR5 . Navigations . Single ( ) . VAR4 ) ; Assert . Same ( VAR1 , VAR3 . Navigations . Single ( ) . ForeignKey ) ; Assert . Same ( VAR1 , VAR5 . Navigations . Single ( ) . ForeignKey ) ; Assert . Equal ( VAR6 , VAR5 . Properties . Count ) ; Assert . Equal ( VAR7 , VAR3 . Properties . Count ) ;
var VAR0 = VAR1 . Properties . Count ; var VAR2 = VAR3 . Properties . Count ; var VAR4 = VAR1 . Keys . Single ( ) ; var VAR5 = VAR3 . Keys . Single ( ) ; VAR6 . Entity ( typeof ( VAR7 ) . FullName ) . HasOne ( typeof ( CustomerDetails ) . FullName , LITERAL ) . WithOne ( LITERAL ) ; var VAR8 = VAR3 . ForeignKeys . Single ( ) ; Assert . Same ( VAR9 , VAR8 . Properties . Single ( ) ) ; Assert . Equal ( LITERAL , VAR3 . Navigations . Single ( ) . VAR10 ) ; Assert . Equal ( LITERAL , VAR1 . Navigations . Single ( ) . VAR10 ) ; Assert . Same ( VAR8 , VAR3 . Navigations . Single ( ) . ForeignKey ) ; Assert . Same ( VAR8 , VAR1 . Navigations . Single ( ) . ForeignKey ) ; Assert . Equal ( VAR0 , VAR1 . Properties . Count ) ; Assert . Equal ( VAR2 , VAR3 . Properties . Count ) ;
var VAR0 = VAR1 . Properties . Count ; var VAR2 = VAR3 . Properties . Count ; var VAR4 = VAR1 . Keys . Single ( ) ; var VAR5 = VAR3 . Keys . Single ( ) ; VAR6 . Entity ( typeof ( VAR7 ) . FullName ) . HasOne ( typeof ( OrderDetails ) . FullName , LITERAL ) . WithOne ( LITERAL ) ; var VAR8 = VAR3 . ForeignKeys . Single ( ) ; Assert . Same ( VAR9 , VAR8 . Properties . Single ( ) ) ; Assert . Equal ( LITERAL , VAR3 . Navigations . Single ( ) . VAR10 ) ; Assert . Equal ( LITERAL , VAR1 . Navigations . Single ( ) . VAR10 ) ; Assert . Same ( VAR8 , VAR3 . Navigations . Single ( ) . ForeignKey ) ; Assert . Same ( VAR8 , VAR1 . Navigations . Single ( ) . ForeignKey ) ; Assert . Equal ( VAR0 , VAR1 . Properties . Count ) ; Assert . Equal ( VAR2 , VAR3 . Properties . Count ) ;
VAR0 . Protected ( ) . Verify ( LITERAL , Times . Never ( ) , new object [  ] { true } ) ; Assert . Equal ( 0 , VAR1 . VAR2 ) ; Assert . Same ( VAR0 . Object , VAR1 . DbConnection ) ; VAR1 . Open ( ) ; VAR1 . Close ( ) ; VAR1 . Dispose ( ) ; VAR0 . Verify ( VAR3 => VAR3 . Open ( ) , Times . Exactly ( LITERAL ) ) ; VAR0 . Verify ( VAR3 => VAR3 . Close ( ) , Times . Exactly ( LITERAL ) ) ; VAR0 . Protected ( ) . Verify ( LITERAL , Times . Never ( ) , new object [  ] { true } ) ;
VAR0 . UpdateRange ( new [ ] { VAR1 } ) ; VAR0 . UpdateRange ( new object [  ] { VAR1 } ) ; VAR0 . UpdateRange ( new List < Product > { VAR1 } ) ; VAR0 . UpdateRange ( new List < object > { VAR1 } ) ; VAR0 . Remove ( VAR1 ) ; VAR0 . Remove ( ( object ) VAR1 ) ; VAR0 . RemoveRange ( new [ ] { VAR1 } ) ; VAR0 . RemoveRange ( new object [  ] { VAR1 } ) ;
Assert . Same ( VAR0 , VAR1 . StateEntry ) ; Assert . Equal ( LITERAL , VAR1 . Property . Name ) ; Assert . False ( VAR1 . IsCondition ) ; Assert . True ( VAR1 . IsKey ) ; Assert . False ( VAR1 . IsRead ) ; Assert . True ( VAR1 . IsWrite ) ; VAR1 = VAR2 . ColumnModifications [ 1 ] ; Assert . Equal ( LITERAL , VAR1 . ColumnName ) ; Assert . Same ( VAR0 , VAR1 . StateEntry ) ;
var VAR0 = CreateStateEntry ( EntityState . Added , VAR1 : true ) ; VAR0 . MarkAsTemporary ( VAR0 . EntityType . GetPrimaryKey ( ) . Properties [ 0 ] ) ; var VAR2 = new ModificationCommand ( new SchemaQualifiedName ( LITERAL ) , new ParameterNameGenerator ( ) , VAR3 => VAR3 . Relational ( ) ) ; VAR2 . AddStateEntry ( VAR0 ) ;
var VAR0 = CreateStateEntry ( EntityState . Added , VAR1 : true ) ; VAR0 . MarkAsTemporary ( VAR0 . EntityType . GetPrimaryKey ( ) . Properties [ 0 ] ) ; var VAR2 = new ModificationCommand ( new SchemaQualifiedName ( LITERAL ) , new ParameterNameGenerator ( ) , VAR3 => VAR3 . Relational ( ) ) ; VAR2 . AddStateEntry ( VAR0 ) ;
ChangeStateWithMethod ( ( VAR0 , VAR1 ) => VAR0 . Remove ( VAR1 ) , EntityState . Unknown , EntityState . Deleted ) ; ChangeStateWithMethod ( ( VAR0 , VAR1 ) => VAR0 . Remove ( VAR1 ) , EntityState . Unchanged , EntityState . Deleted ) ; ChangeStateWithMethod ( ( VAR0 , VAR1 ) => VAR0 . Remove ( VAR1 ) , EntityState . Deleted , EntityState . Deleted ) ; ChangeStateWithMethod ( ( VAR0 , VAR1 ) => VAR0 . Remove ( VAR1 ) , EntityState . Modified , EntityState . Deleted ) ; ChangeStateWithMethod ( ( VAR0 , VAR1 ) => VAR0 . Remove ( VAR1 ) , EntityState . Added , EntityState . Unknown ) ;
var VAR0 = new NotifyingProduct { VAR1 = LITERAL } ; var VAR2 = new NotifyingProduct { VAR1 = LITERAL } ; var VAR3 = new NotifyingCategory { VAR4 = LITERAL , VAR5 = { VAR0 , VAR2 } } ; var VAR6 = VAR7 . GetOrCreateEntry ( VAR3 ) ; VAR6 . SetEntityState ( EntityState . Unchanged ) ; var VAR8 = new NotifyingProduct { VAR9 = new NotifyingProductTag ( ) } ; VAR3 . VAR5 . Add ( VAR8 ) ; VAR10 . DetectChanges ( VAR6 ) ; Assert . Equal ( EntityState . Unchanged , VAR6 . EntityState ) ; Assert . Equal ( VAR3 . VAR4 , VAR8 . VAR1 ) ; Assert . Same ( VAR3 , VAR8 . VAR11 ) ; Assert . Equal ( new [ ] { VAR0 , VAR2 , VAR8 } , VAR3 . VAR5 . OrderBy ( VAR12 => VAR12 . VAR13 ) . ToArray ( ) ) ;
var VAR0 = ( ( IDbContextServices ) VAR1 ) . ScopedServiceProvider ; var VAR2 = VAR0 . GetRequiredService < IModelSource > ( ) ; VAR1 . Dispose ( ) ; VAR1 = new EarlyLearningCenter ( VAR3 ) ; VAR0 = ( ( IDbContextServices ) VAR1 ) . ScopedServiceProvider ;
VAR0 . Entry ( VAR1 ) . SetState ( EntityState . Unchanged ) ; Assert . Equal ( 1 , VAR2 . VAR3 ) ; Assert . Same ( VAR2 , VAR1 . VAR4 . Single ( ) ) ; Assert . Same ( VAR1 , VAR2 . VAR5 ) ; Assert . Empty ( VAR6 . VAR4 ) ; Assert . Equal ( EntityState . Unchanged , VAR0 . Entry ( VAR1 ) . State ) ; Assert . Equal ( EntityState . Unknown , VAR0 . Entry ( VAR2 ) . State ) ; VAR0 . Entry ( VAR2 ) . SetState ( EntityState . Unchanged ) ;
var VAR0 = ( await VAR1 . AddAsync ( new Unicorn { VAR2 = VAR3 , VAR4 = LITERAL } ) ) . Entity ; Assert . True ( VAR0 . VAR5 > 0 ) ; Assert . NotEqual ( Guid . Empty , VAR0 . VAR6 ) ; await VAR1 . SaveChangesAsync ( ) ; VAR7 = VAR0 . VAR5 ; VAR8 = VAR0 . VAR6 ;
VAR0 . Entry ( VAR1 ) . SetState ( EntityState . Unknown ) ; var VAR2 = await CreateBlogDatabaseAsync < Blog > ( VAR0 ) ; var VAR3 = VAR2 [ 0 ] ; VAR3 . VAR4 = LITERAL ; VAR5 = VAR3 . VAR6 ; var VAR7 = VAR2 [ 1 ] ; VAR7 . VAR4 = LITERAL ; VAR8 = VAR7 . VAR6 ; VAR0 . Remove ( VAR7 ) ; VAR0 . Entry ( VAR1 ) . SetState ( EntityState . Added ) ;
Assert . False ( VAR0 . IsUnique . Value ) ; VAR0 . IsRequired = true ; VAR0 . IsUnique = true ; new RelationshipDiscoveryConvention ( ) . Apply ( VAR1 ) ; var VAR2 = VAR3 . ForeignKeys . Single ( ) ; Assert . True ( VAR2 . IsRequired . Value ) ; Assert . True ( VAR2 . IsUnique . Value ) ;
Assert . Equal ( 1 , VAR0 [ VAR1 ] ) ; VAR2 . VAR3 = LITERAL ; VAR0 . EnsureSnapshot ( VAR1 ) ; Assert . True ( VAR0 . HasValue ( VAR1 ) ) ; Assert . Equal ( 1 , VAR0 [ VAR1 ] ) ;
VAR0 . Entity ( typeof ( VAR1 ) ) . OneToMany ( typeof ( VAR2 ) , LITERAL , LITERAL ) ; Assert . Same ( VAR3 , VAR4 . ForeignKeys . Single ( ) ) ; Assert . Equal ( LITERAL , VAR4 . Navigations . Single ( ) . VAR5 ) ; Assert . Same ( VAR6 , VAR7 . Navigations . Single ( ) ) ; Assert . Same ( VAR3 , VAR4 . Navigations . Single ( ) . ForeignKey ) ; Assert . Same ( VAR3 , VAR7 . Navigations . Single ( ) . ForeignKey ) ; Assert . Equal ( VAR8 , VAR7 . Properties . Count ) ;
VAR0 . Entity ( typeof ( VAR1 ) ) . OneToOne ( typeof ( OrderDetails ) , LITERAL , LITERAL ) ; Assert . Same ( VAR2 , VAR3 . ForeignKeys . Single ( ) ) ; Assert . Equal ( LITERAL , VAR3 . Navigations . Single ( ) . VAR4 ) ; Assert . Equal ( LITERAL , VAR5 . Navigations . Single ( ) . VAR4 ) ; Assert . Same ( VAR2 , VAR3 . Navigations . Single ( ) . ForeignKey ) ; Assert . Same ( VAR2 , VAR5 . Navigations . Single ( ) . ForeignKey ) ; Assert . Equal ( VAR6 , VAR5 . Properties . Count ) ;
VAR0 . Entity ( typeof ( VAR1 ) . FullName ) . OneToMany ( typeof ( VAR2 ) . FullName , LITERAL , LITERAL ) ; Assert . Same ( VAR3 , VAR4 . ForeignKeys . Single ( ) ) ; Assert . Same ( VAR5 , VAR4 . Navigations . Single ( ) ) ; Assert . Same ( VAR6 , VAR7 . Navigations . Single ( ) ) ; Assert . Same ( VAR3 , VAR4 . Navigations . Single ( ) . ForeignKey ) ; Assert . Same ( VAR3 , VAR7 . Navigations . Single ( ) . ForeignKey ) ; Assert . Equal ( VAR8 , VAR7 . Properties . Count ) ;
var VAR0 = new ModelBuilder ( VAR1 ) ; VAR0 . Entity < VAR2 > ( ) ; VAR0 . Entity < VAR3 > ( ) ; VAR0 . Ignore < OrderDetails > ( ) ; VAR0 . Ignore < CustomerDetails > ( ) ; var VAR4 = VAR1 . GetEntityType ( typeof ( VAR3 ) ) ; var VAR5 = VAR1 . GetEntityType ( typeof ( VAR2 ) ) ; var VAR6 = VAR4 . GetProperty ( LITERAL ) ; var VAR7 = VAR5 . Keys . Single ( ) ; var VAR8 = VAR4 . Keys . Single ( ) ;
var VAR0 = new ModelBuilder ( VAR1 ) ; VAR0 . Entity < Product > ( ) ; VAR0 . Entity < VAR2 > ( ) ; var VAR3 = VAR1 . GetEntityType ( typeof ( VAR2 ) ) ; var VAR4 = VAR1 . GetEntityType ( typeof ( Product ) ) ; var VAR5 = VAR4 . GetOrAddForeignKey ( VAR4 . GetProperty ( LITERAL ) , VAR3 . GetPrimaryKey ( ) ) ; var VAR6 = VAR3 . GetOrAddForeignKey ( VAR3 . GetProperty ( LITERAL ) , VAR4 . GetPrimaryKey ( ) ) ;
Assert . Equal ( LITERAL , VAR0 . ForeignKeys . Count ) ; var VAR1 = VAR0 . ForeignKeys . Single ( VAR2 => VAR2 != VAR3 ) ; Assert . True ( VAR3 . IsUnique ) ; Assert . False ( VAR1 . IsUnique ) ; Assert . Equal ( LITERAL , VAR0 . Navigations . Single ( ) . VAR4 ) ;
VAR0 . Entity < VAR1 > ( ) ; var VAR2 = VAR3 . GetEntityType ( typeof ( VAR1 ) ) ; var VAR4 = VAR3 . GetEntityType ( typeof ( VAR5 ) ) ; var VAR6 = VAR2 . GetProperty ( LITERAL ) ; var VAR7 = VAR4 . Properties . Count ; var VAR8 = VAR2 . Properties . Count ; var VAR9 = VAR4 . Keys . Single ( ) ;
VAR0 = await VAR1 . NextAsync ( VAR2 , new LazyRef < DataStoreServices > ( ( ) => null ) ) ; Assert . Equal ( 1 , VAR0 . Value ) ; Assert . False ( VAR0 . IsTemporary ) ; VAR0 = await VAR1 . NextAsync ( VAR2 , new LazyRef < DataStoreServices > ( ( ) => null ) ) ;
Assert . True ( VAR0 . IgnoreEntity ( typeof ( VAR1 ) . FullName , ConfigurationSource . Convention ) ) ; Assert . NotNull ( VAR0 . Entity ( typeof ( VAR1 ) . FullName , ConfigurationSource . Convention ) ) ; Assert . NotNull ( VAR0 . Entity ( typeof ( VAR1 ) . FullName , ConfigurationSource . DataAnnotation ) ) ; Assert . False ( VAR0 . IgnoreEntity ( typeof ( VAR1 ) . FullName , ConfigurationSource . Convention ) ) ;
var VAR0 = CreateContextConfiguration ( ) ; var VAR1 = VAR0 . StateManager ; var VAR2 = new VAR3 { VAR4 = LITERAL } ; var VAR5 = new VAR3 { VAR4 = LITERAL } ; var VAR6 = new VAR7 { VAR4 = LITERAL , VAR8 = LITERAL } ; VAR1 . StartTracking ( VAR1 . GetOrCreateEntry ( VAR2 ) ) ; VAR1 . StartTracking ( VAR1 . GetOrCreateEntry ( VAR5 ) ) ; var VAR9 = VAR1 . StartTracking ( VAR1 . GetOrCreateEntry ( VAR6 ) ) ; var VAR10 = CreateNavigationFixer ( VAR0 ) ;
var VAR0 = TestHelpers . CreateContextConfiguration ( VAR1 ) ; var VAR2 = CreateStateEntry ( VAR0 , VAR3 , new SomeEntity ( ) ) ; VAR2 [ VAR4 ] = 1 ; VAR2 . EntityState = EntityState . Added ; Assert . Equal ( EntityState . Added , VAR2 . EntityState ) ; Assert . Contains ( VAR2 , VAR0 . StateManager . StateEntries ) ;
VAR0 . Property < int > ( LITERAL ) ; VAR0 . Key ( LITERAL ) ; VAR1 . Entity ( typeof ( VAR2 ) , VAR0 => { VAR0 . Property < int > ( LITERAL ) ; VAR0 . Key ( LITERAL ) ; } ) ; var VAR3 = VAR4 . GetEntityType ( typeof ( VAR2 ) ) ; Assert . Equal ( 1 , VAR3 . GetPrimaryKey ( ) . Properties . Count ( ) ) ; Assert . Equal ( LITERAL , VAR3 . GetPrimaryKey ( ) . Properties . First ( ) . VAR5 ) ;
VAR0 . Property < string > ( LITERAL ) ; VAR0 . Key ( LITERAL , LITERAL ) ; VAR1 . Entity < VAR2 > ( VAR0 => { VAR0 . Property ( VAR3 => VAR3 . VAR4 ) ; VAR0 . Property < string > ( LITERAL ) ; VAR0 . Key ( LITERAL , LITERAL ) ; } ) ; var VAR5 = VAR6 . GetEntityType ( typeof ( VAR2 ) ) ; Assert . Equal ( LITERAL , VAR5 . GetPrimaryKey ( ) . Properties . Count ( ) ) ; Assert . Equal ( LITERAL , VAR5 . GetPrimaryKey ( ) . Properties . First ( ) . VAR7 ) ; Assert . Equal ( LITERAL , VAR5 . GetPrimaryKey ( ) . Properties . Last ( ) . VAR7 ) ;
VAR0 . Entity < VAR1 > ( ) . Property ( VAR2 => VAR2 . VAR3 ) ; var VAR4 = VAR5 . GetEntityType ( typeof ( VAR1 ) ) ; var VAR6 = VAR5 . GetEntityType ( typeof ( VAR7 ) ) ; var VAR8 = VAR4 . GetProperty ( LITERAL ) ; var VAR9 = VAR6 . GetProperty ( LITERAL ) ;
var VAR0 = CreateConfiguration ( VAR1 ) . ScopedServiceProvider . GetRequiredService < StateEntryFactory > ( ) ; var VAR2 = new object [  ] { LITERAL , LITERAL , LITERAL } ; var VAR3 = VAR1 . GetEntityType ( typeof ( GuidKeysPoco ) ) ; var VAR4 = VAR0 . Create ( VAR3 , new AtsObjectArrayValueReader ( VAR2 ) ) ;
var VAR0 = new Mock < ChangeDetector > ( ) ; new StateEntrySubscriber ( VAR0 . Object ) . SnapshotAndSubscribe ( VAR1 . Object ) ; VAR2 . VAR3 = LITERAL ; VAR0 . Verify ( VAR4 => VAR4 . VAR5 ( VAR1 . Object , VAR6 ) ) ; VAR0 . Verify ( VAR4 => VAR4 . VAR7 ( VAR1 . Object , VAR6 ) ) ;
var VAR0 = new Sequence ( LITERAL , LITERAL , LITERAL , LITERAL ) ; var VAR1 = VAR0 . Clone ( new CloneContext ( ) ) ; Assert . NotSame ( VAR0 , VAR1 ) ; Assert . Equal ( LITERAL , VAR1 . Name ) ; Assert . Equal ( LITERAL , VAR1 . DataType ) ;
Assert . Equal ( LITERAL , VAR0 . DataType ) ; Assert . Equal ( 1 , VAR0 . StartWith ) ; Assert . Equal ( LITERAL , VAR0 . IncrementBy ) ; var VAR1 = VAR2 . Sequences [ 1 ] ; Assert . Equal ( LITERAL , VAR1 . Name ) ; Assert . Equal ( LITERAL , VAR0 . DataType ) ;
Assert . Equal ( LITERAL , VAR0 . DataType ) ; Assert . Equal ( LITERAL , VAR0 . StartWith ) ; Assert . Equal ( LITERAL , VAR0 . IncrementBy ) ; var VAR1 = VAR2 . Sequences [ 1 ] ; Assert . Equal ( LITERAL , VAR1 . Name ) ; Assert . Equal ( LITERAL , VAR1 . DataType ) ;
Assert . Equal ( LITERAL , VAR0 . DataType ) ; Assert . Equal ( 1 , VAR0 . StartWith ) ; Assert . Equal ( LITERAL , VAR0 . IncrementBy ) ; var VAR1 = VAR2 . Sequences [ 1 ] ; Assert . Equal ( LITERAL , VAR1 . Name ) ; Assert . Equal ( LITERAL , VAR0 . DataType ) ;
var VAR0 = CreateStateEntry ( ) ; var VAR1 = VAR0 . EntityType . GetProperty ( LITERAL ) ; var VAR2 = RedisDatabase . ConstructRedisValueGeneratorKeyName ( VAR1 ) ; const int VAR3 = 1 ; var VAR4 = VAR0 . EntityType . GetProperty ( LITERAL ) ; var VAR5 = VAR0 . EntityType . GetProperty ( LITERAL ) ; var VAR6 = VAR0 . EntityType . GetProperty ( LITERAL ) ; var VAR7 = VAR0 . EntityType . GetProperty ( LITERAL ) ; var VAR8 = VAR0 . EntityType . GetProperty ( LITERAL ) ; var VAR9 = VAR0 . EntityType . GetProperty ( LITERAL ) ; var VAR10 = VAR0 . EntityType . GetProperty ( LITERAL ) ; var VAR11 = VAR0 . EntityType . GetProperty ( LITERAL ) ;
VAR0 . ValueGeneration = VAR1 ; VAR0 . Relational ( ) . Column = LITERAL ; VAR2 . GetOrSetPrimaryKey ( VAR0 ) ; var VAR3 = VAR2 . GetOrAddProperty ( LITERAL , typeof ( string ) ) ; VAR3 . Relational ( ) . Column = LITERAL ; VAR3 . ValueGeneration = VAR4 ;
VAR0 . Property ( VAR1 => VAR1 . VAR2 ) . GenerateValuesOnAdd ( false ) ; VAR0 . Property ( VAR1 => VAR1 . VAR3 ) . GenerateValuesOnAdd ( ) ; VAR0 . Property ( VAR1 => VAR1 . VAR4 ) . GenerateValuesOnAdd ( true ) ; VAR0 . Property < int > ( LITERAL ) . GenerateValuesOnAdd ( ) ; VAR0 . Property < string > ( LITERAL ) . GenerateValuesOnAdd ( false ) ; VAR0 . Property ( typeof ( int ) , LITERAL ) . GenerateValuesOnAdd ( ) ; VAR0 . Property ( typeof ( string ) , LITERAL ) . GenerateValuesOnAdd ( false ) ;
VAR0 . Property ( VAR1 => VAR1 . VAR2 ) . GenerateValuesOnAdd ( false ) ; VAR0 . Property ( VAR1 => VAR1 . VAR3 ) . GenerateValuesOnAdd ( ) ; VAR0 . Property ( VAR1 => VAR1 . VAR4 ) . GenerateValuesOnAdd ( true ) ; VAR0 . Property < int > ( LITERAL ) . GenerateValuesOnAdd ( ) ; VAR0 . Property < string > ( LITERAL ) . GenerateValuesOnAdd ( false ) ; VAR0 . Property ( typeof ( int ) , LITERAL ) . GenerateValuesOnAdd ( ) ; VAR0 . Property ( typeof ( string ) , LITERAL ) . GenerateValuesOnAdd ( false ) ;
VAR0 . ValueGeneration = ValueGeneration . None ; var VAR1 = VAR2 . GetEntityType ( typeof ( Resolution ) ) . GetProperty ( LITERAL ) ; VAR1 . ValueGeneration = ValueGeneration . None ; var VAR3 = VAR2 . GetEntityType ( typeof ( CustomerInfo ) ) . GetProperty ( LITERAL ) ; VAR3 . ValueGeneration = ValueGeneration . None ;
Assert . Equal ( LITERAL , TestSqlLoggerFactory . Logger . SqlStatements . Count ) ; Assert . True ( TestSqlLoggerFactory . Logger . SqlStatements [ 0 ] . Contains ( LITERAL ) ) ; Assert . True ( TestSqlLoggerFactory . Logger . SqlStatements [ 1 ] . Contains ( LITERAL ) ) ; Assert . True ( TestSqlLoggerFactory . Logger . SqlStatements [ LITERAL ] . Contains ( LITERAL ) ) ; Assert . True ( TestSqlLoggerFactory . Logger . SqlStatements [ LITERAL ] . Contains ( LITERAL ) ) ; Assert . True ( TestSqlLoggerFactory . Logger . SqlStatements [ LITERAL ] . Contains ( LITERAL ) ) ;
Assert . Equal ( typeof ( int ) , VAR0 . Properties . Single ( ) . PropertyType ) ; Assert . True ( VAR0 . Properties . Single ( ) . IsShadowProperty ) ; Assert . False ( VAR0 . Properties . Single ( ) . IsConcurrencyToken ) ; Assert . Same ( VAR1 , VAR0 . ReferencedProperties . Single ( ) ) ; Assert . False ( VAR0 . IsUnique ) ; Assert . True ( VAR0 . IsRequired ) ;
var VAR0 = CreateEntityType < EntityWithId > ( ) ; new KeyConvention ( ) . Apply ( VAR0 ) ; var VAR1 = VAR0 . TryGetPrimaryKey ( ) ;
var VAR0 = new Model ( ) . AddEntityType ( typeof ( EntityWithInvalidProperties ) ) ; new PropertiesConvention ( ) . Apply ( VAR0 ) ; Assert . Empty ( VAR0 . Properties ) ;
VAR0 . Annotations . Add ( new Annotation ( LITERAL , LITERAL ) ) ; VAR0 . Annotations . Add ( new Annotation ( LITERAL , LITERAL ) ) ; var VAR1 = VAR0 . GetOrAddProperty ( VAR0 . Type . GetProperty ( LITERAL + VAR2 ) ) ; VAR1 . Annotations . Add ( new Annotation ( LITERAL + VAR2 + LITERAL , LITERAL + VAR2 + LITERAL ) ) ; VAR1 . Annotations . Add ( new Annotation ( LITERAL + VAR2 + LITERAL , LITERAL + VAR2 + LITERAL ) ) ;
VAR0 . Property < string > ( LITERAL ) . ColumnName ( LITERAL ) ; VAR0 . Key ( LITERAL ) . KeyName ( LITERAL ) ; VAR0 . ToTable ( LITERAL , LITERAL ) ; VAR0 . ForeignKey ( LITERAL , LITERAL ) . KeyName ( LITERAL ) ; VAR0 . Index ( LITERAL ) . IsUnique ( ) . IndexName ( LITERAL ) ;
VAR0 . Entity < PocoTestType > ( ) . PartitionAndRowKey ( VAR1 => VAR1 . BigCount , VAR1 => VAR1 . IsEnchanted ) ; var VAR2 = VAR3 . EntityTypes . First ( ) . GetPrimaryKey ( ) ; Assert . Equal ( LITERAL , VAR2 . Properties . Count ) ; Assert . Equal ( LITERAL , VAR2 . Properties . First ( VAR1 => VAR1 . ColumnName ( ) == LITERAL ) . Name ) ; Assert . Equal ( LITERAL , VAR2 . Properties . First ( VAR1 => VAR1 . ColumnName ( ) == LITERAL ) . Name ) ;
VAR0 . SetColumnName ( LITERAL ) ; VAR1 . GetOrSetPrimaryKey ( VAR0 ) ; var VAR2 = VAR1 . GetOrAddProperty ( LITERAL , typeof ( string ) ) ; VAR2 . IsConcurrencyToken = VAR3 == ValueGeneration . OnAddAndUpdate ; VAR2 . SetColumnName ( LITERAL ) ; VAR2 . ValueGeneration = VAR3 ;
var VAR0 = CreateConfiguration ( new DbContextOptions ( ) . UseInMemoryStore ( persist : true ) ) ; var VAR1 = new InMemoryDatabase ( new [ ] { new NullLoggerFactory ( ) } ) ; var VAR2 = new InMemoryDataStore ( VAR0 , VAR1 ) ;
Assert . Equal ( Entity . Metadata . SqlServerMetadataExtensions . DefaultSequenceDataType , VAR0 . DataType ) ; Assert . Equal ( Entity . Metadata . SqlServerMetadataExtensions . DefaultSequenceStartWith , VAR0 . StartWith ) ; Assert . Equal ( LITERAL , VAR0 . IncrementBy ) ; var VAR1 = VAR2 . Sequences [ 1 ] ; Assert . Equal ( LITERAL , VAR1 . Name ) ; Assert . Equal ( Entity . Metadata . SqlServerMetadataExtensions . DefaultSequenceDataType , VAR1 . DataType ) ; Assert . Equal ( Entity . Metadata . SqlServerMetadataExtensions . DefaultSequenceStartWith , VAR1 . StartWith ) ;
VAR0 . Entity ( typeof ( VAR1 ) ) . Key ( new [ ] { VAR1 . VAR2 , VAR1 . VAR3 } ) ; var VAR4 = VAR0 . Entity ( typeof ( Order ) ) ; var VAR5 = VAR4 . ForeignKey ( typeof ( VAR1 ) , new [ ] { Order . VAR6 , Order . VAR7 } ) ; Assert . NotNull ( VAR5 ) ; Assert . Same ( VAR5 , VAR4 . ForeignKey ( typeof ( VAR1 ) . FullName , new [ ] { Order . VAR6 . VAR8 , Order . VAR7 . VAR8 } ) ) ;
VAR0 . AddNavigation ( new Navigation ( VAR1 , LITERAL , pointsToPrincipal : false ) ) ; VAR2 . AddNavigation ( new Navigation ( VAR1 , LITERAL , pointsToPrincipal : true ) ) ; var VAR3 = VAR4 . GetEntityType ( typeof ( Customer ) ) ; var VAR5 = VAR4 . GetEntityType ( typeof ( Order ) ) ; var VAR6 = VAR5 . ForeignKeys . Single ( ) ; VAR3 . AddNavigation ( new Navigation ( VAR6 , LITERAL , pointsToPrincipal : false ) ) ; VAR5 . AddNavigation ( new Navigation ( VAR6 , LITERAL , pointsToPrincipal : true ) ) ;
var VAR0 = VAR1 . GetOrAddForeignKey ( VAR1 . GetPrimaryKey ( ) , VAR2 ) ; VAR1 . GetOrAddProperty ( LITERAL , typeof ( string ) ) ; VAR3 . AddEntityType ( VAR1 ) ; VAR1 . AddNavigation ( new Navigation ( VAR0 , LITERAL , pointsToPrincipal : false ) ) ; VAR1 . AddNavigation ( new Navigation ( VAR0 , LITERAL , pointsToPrincipal : true ) ) ;
var VAR0 = new Banana { VAR1 = LITERAL , VAR2 = LITERAL , VAR3 = LITERAL } ; var VAR4 = CreateSidecar ( CreateStateEntry ( VAR0 ) ) ; VAR4 . TakeSnapshot ( VAR5 ) ; Assert . Equal ( LITERAL , VAR4 [ VAR6 ] ) ; Assert . Equal ( LITERAL , VAR4 [ VAR5 ] ) ; VAR4 [ VAR5 ] = LITERAL ; Assert . Equal ( LITERAL , VAR4 [ VAR6 ] ) ; Assert . Equal ( LITERAL , VAR4 [ VAR5 ] ) ; Assert . Equal ( LITERAL , VAR0 . VAR1 ) ;
Assert . Equal ( ValueGenerationOnSave . None , VAR0 . Columns [ 0 ] . ValueGenerationStrategy ) ; Assert . NotNull ( VAR1 . PrimaryKey . Name ) ; Assert . Equal ( LITERAL , VAR0 . PrimaryKey . Name ) ; Assert . Same ( VAR0 . Columns [ 0 ] , VAR0 . PrimaryKey . Columns [ 0 ] ) ; Assert . Equal ( 1 , VAR0 . ForeignKeys . Count ) ; Assert . Equal ( LITERAL , VAR1 . Name ) ; Assert . Equal ( 1 , VAR1 . Columns . Count ) ; Assert . Equal ( LITERAL , VAR1 . Columns [ 0 ] . Name ) ; Assert . Equal ( LITERAL , VAR1 . Columns [ 0 ] . DataType ) ; Assert . Equal ( ValueGenerationOnSave . WhenInserting , VAR1 . Columns [ 0 ] . ValueGenerationStrategy ) ;
VAR0 . AddProperty ( LITERAL , typeof ( string ) ) ; VAR0 . AddProperty ( LITERAL , typeof ( string ) ) ; VAR1 . Apply ( VAR0 ) ; var VAR2 = VAR0 . GetKey ( ) ;
VAR0 . SetKey ( VAR1 ) ; VAR2 . SetKey ( VAR3 ) ; VAR0 . GetKey ( ) . SetKeyName ( LITERAL ) ; VAR2 . GetKey ( ) . SetKeyName ( LITERAL ) ; var VAR4 = VAR0 . AddForeignKey ( VAR2 . GetKey ( ) , VAR1 ) ;
var VAR0 = VAR1 . AddProperty ( LITERAL , typeof ( int ) , shadowProperty : true , concurrencyToken : false ) ; VAR1 . SetKey ( VAR0 ) ; var VAR2 = new MixedStateEntry ( VAR3 , VAR1 , new object ( ) ) ; VAR2 [ VAR0 ] = 0 ; VAR2 . EntityState = EntityState . Modified ; var VAR4 = new ModificationCommand ( new SchemaQualifiedName ( LITERAL ) , new ParameterNameGenerator ( ) ) ; VAR4 . AddStateEntry ( VAR2 ) ; var VAR5 = new EntityType ( typeof ( object ) ) ; var VAR6 = VAR5 . AddProperty ( LITERAL , typeof ( int ) , shadowProperty : true , concurrencyToken : false ) ; VAR5 . SetKey ( VAR6 ) ;
VAR0 . AddCommand ( VAR1 , new Mock < SqlGenerator > { CallBase = true } . Object ) ; await VAR0 . ExecuteAsync ( new Mock < RelationalTransaction > ( ) . Object , new RelationalTypeMapper ( ) , new Mock < DbContext > ( ) . Object , new Mock < ILogger > ( ) . Object ) ; VAR2 . Verify ( VAR3 => VAR3 . ReadAsync ( It . IsAny < CancellationToken > ( ) ) , Times . Exactly ( 1 ) ) ; VAR2 . Verify ( VAR3 => VAR3 . NextResultAsync ( It . IsAny < CancellationToken > ( ) ) , Times . Once ) ;
Assert . False ( VAR0 . GetProperty ( LITERAL ) . IsShadowProperty ) ; Assert . False ( VAR0 . GetProperty ( LITERAL ) . IsShadowProperty ) ; Assert . Equal ( 0 , VAR0 . GetProperty ( LITERAL ) . ShadowIndex ) ; Assert . Equal ( - 1 , VAR0 . GetProperty ( LITERAL ) . ShadowIndex ) ; Assert . Equal ( - 1 , VAR0 . GetProperty ( LITERAL ) . ShadowIndex ) ; Assert . Equal ( - 1 , VAR0 . GetProperty ( LITERAL ) . ShadowIndex ) ; Assert . Equal ( - 1 , VAR0 . GetProperty ( LITERAL ) . ShadowIndex ) ;
VAR0 . AddProperty ( LITERAL , typeof ( int ) ) ; VAR0 . AddProperty ( LITERAL , typeof ( int ) ) ; VAR0 . AddProperty ( LITERAL , typeof ( int ) ) ; VAR0 . AddProperty ( LITERAL , typeof ( int ) ) ; var VAR1 = VAR0 . AddProperty ( LITERAL , typeof ( int ) ) ; var VAR2 = VAR0 . AddForeignKey ( VAR3 . GetKey ( ) , VAR1 ) ;
var VAR0 = VAR1 . AddProperty ( LITERAL , typeof ( int ) ) ; VAR1 . AddProperty ( LITERAL , typeof ( int ) ) ; VAR1 . AddProperty ( LITERAL , typeof ( int ) ) ; var VAR2 = VAR1 . AddForeignKey ( VAR3 . GetKey ( ) , VAR0 ) ;
VAR0 . AddProperty ( LITERAL , typeof ( int ) ) ; VAR0 . AddProperty ( LITERAL , typeof ( int ) ) ; VAR0 . AddProperty ( LITERAL , typeof ( int ) ) ; VAR0 . AddProperty ( LITERAL , typeof ( int ) ) ; var VAR1 = VAR0 . AddProperty ( LITERAL , typeof ( int ) ) ; var VAR2 = VAR0 . AddProperty ( LITERAL , typeof ( int ) ) ;
VAR0 . AddProperty ( LITERAL , typeof ( int ) ) ; VAR0 . AddProperty ( LITERAL , typeof ( int ) ) ; VAR0 . AddProperty ( LITERAL , typeof ( int ) ) ; VAR0 . AddProperty ( LITERAL , typeof ( int ) ) ; var VAR1 = VAR0 . AddProperty ( LITERAL , typeof ( int ) ) ; var VAR2 = VAR0 . AddProperty ( LITERAL , typeof ( int ) ) ; var VAR3 = VAR4 . AddProperty ( LITERAL , typeof ( int ) ) ; var VAR5 = VAR4 . AddProperty ( LITERAL , typeof ( int ) ) ;
VAR0 . SetKey ( VAR0 . AddProperty ( LITERAL , typeof ( int ) , shadowProperty : true , concurrencyToken : false ) ) ; var VAR1 = new NamedEntityType ( typeof ( B ) ) ; VAR1 . SetKey ( VAR1 . AddProperty ( LITERAL , typeof ( int ) , shadowProperty : true , concurrencyToken : false ) ) ; var VAR2 = new NamedEntityType ( typeof ( C ) ) ; VAR2 . SetKey ( VAR2 . AddProperty ( LITERAL , typeof ( int ) , shadowProperty : true , concurrencyToken : false ) ) ; VAR0 . AddForeignKey ( VAR1 . GetKey ( ) , VAR0 . AddProperty ( LITERAL , typeof ( int ) ) ) ; VAR1 . AddForeignKey ( VAR2 . GetKey ( ) , VAR1 . AddProperty ( LITERAL , typeof ( int ) ) ) ;
VAR0 . SetKey ( VAR0 . AddProperty ( LITERAL , typeof ( int ) , shadowProperty : true , concurrencyToken : false ) ) ; var VAR1 = new NamedEntityType ( typeof ( B ) ) ; VAR1 . SetKey ( VAR1 . AddProperty ( LITERAL , typeof ( int ) , shadowProperty : true , concurrencyToken : false ) ) ; var VAR2 = new NamedEntityType ( typeof ( C ) ) ; VAR2 . SetKey ( VAR2 . AddProperty ( LITERAL , typeof ( int ) , shadowProperty : true , concurrencyToken : false ) ) ; VAR2 . AddForeignKey ( VAR0 . GetKey ( ) , VAR2 . AddProperty ( LITERAL , typeof ( int ) ) ) ; VAR0 . AddForeignKey ( VAR1 . GetKey ( ) , VAR0 . AddProperty ( LITERAL , typeof ( int ) ) ) ;
VAR0 . SetKey ( VAR0 . AddProperty ( LITERAL , typeof ( int ) , shadowProperty : true , concurrencyToken : false ) ) ; var VAR1 = new NamedEntityType ( typeof ( B ) ) ; VAR1 . SetKey ( VAR1 . AddProperty ( LITERAL , typeof ( int ) , shadowProperty : true , concurrencyToken : false ) ) ; var VAR2 = new NamedEntityType ( typeof ( C ) ) ; VAR2 . SetKey ( VAR2 . AddProperty ( LITERAL , typeof ( int ) , shadowProperty : true , concurrencyToken : false ) ) ;
VAR0 = new LazyRef < IModel > ( ( ) => VAR1 . ModelSource . GetModel ( VAR2 ) ) ; VAR3 = new LazyRef < DataStoreSource > ( ( ) => VAR1 . DataStoreSelector . SelectDataStore ( this ) ) ; VAR4 = new LazyRef < VAR5 > ( ( ) => VAR3 . Value . GetStore ( this ) ) ; VAR6 = new LazyRef < DataStoreConnection > ( ( ) => VAR3 . Value . GetConnection ( this ) ) ; VAR7 = new LazyRef < ILoggerFactory > ( ( ) => VAR8 . TryGetService < ILoggerFactory > ( ) ?? new NullLoggerFactory ( ) ) ;
Assert . True ( VAR0 . IsCondition ) ; Assert . True ( VAR0 . IsKey ) ; Assert . True ( VAR0 . IsRead ) ; Assert . False ( VAR0 . IsWrite ) ; VAR0 = VAR1 . ColumnModifications [ 1 ] ; Assert . Equal ( LITERAL , VAR0 . ColumnName ) ; Assert . Same ( VAR2 , VAR0 . StateEntry ) ; Assert . Equal ( LITERAL , VAR0 . Property . VAR3 ) ; Assert . False ( VAR0 . IsCondition ) ;
var VAR0 = VAR1 . GetOrMaterializeEntry ( VAR2 , new ObjectArrayValueReader ( new object [  ] { LITERAL , LITERAL } ) ) ; Assert . Equal ( EntityState . Unchanged , VAR0 . EntityState ) ; Assert . Same ( VAR0 , VAR1 . GetOrMaterializeEntry ( VAR2 , new ObjectArrayValueReader ( new object [  ] { LITERAL , LITERAL } ) ) ) ; VAR0 . EntityState = EntityState . Modified ; Assert . Same ( VAR0 , VAR1 . GetOrMaterializeEntry ( VAR2 , new ObjectArrayValueReader ( new object [  ] { LITERAL , LITERAL } ) ) ) ; Assert . Equal ( EntityState . Modified , VAR0 . EntityState ) ; Assert . NotSame ( VAR0 , VAR1 . GetOrMaterializeEntry ( VAR2 , new ObjectArrayValueReader ( new object [  ] { LITERAL , LITERAL } ) ) ) ;
Check . NotNull ( VAR0 , LITERAL ) ; Check . NotNull ( VAR1 , LITERAL ) ; Check . NotNull ( VAR2 , LITERAL ) ; Check . NotNull ( VAR3 , LITERAL ) ; VAR4 = VAR5 ; VAR6 = VAR7 ; VAR8 = VAR9 ; VAR10 = VAR0 ;
Assert . Same ( VAR0 , VAR1 . Sender ) ; Assert . Same ( VAR1 , VAR0 . SentMessages . Single ( ) ) ; Assert . Same ( VAR2 , VAR1 . Recipient ) ; Assert . Same ( VAR1 , VAR2 . ReceivedMessages . Single ( ) ) ; Assert . Empty ( VAR3 . SentMessages ) ;
Assert . Same ( VAR0 , VAR1 . Sender ) ; Assert . Same ( VAR1 , VAR0 . SentMessages . Single ( ) ) ; Assert . Same ( VAR2 , VAR1 . Recipient ) ; Assert . Same ( VAR1 , VAR2 . ReceivedMessages . Single ( ) ) ; Assert . Empty ( VAR3 . SentMessages ) ;
var VAR0 = new Mock < ForeignKeysSnapshot > ( ) ; var VAR1 = new Mock < StateEntry > ( ) ; VAR1 . Setup ( VAR2 => VAR2 . EntityType ) . Returns ( VAR3 . Object ) ; VAR1 . Setup ( VAR2 => VAR2 . OriginalValues ) . Returns ( VAR4 . Object ) ; VAR1 . Setup ( VAR2 => VAR2 . ForeignKeysSnapshot ) . Returns ( VAR0 . Object ) ;
VAR0 . VAR1 . Add ( new Blog { VAR2 = 1 , VAR3 = LITERAL } ) ; VAR0 . SaveChanges ( ) ; var VAR4 = VAR0 . VAR1 . SingleOrDefault ( ) ; Assert . Equal ( 1 , VAR4 . VAR2 ) ;
VAR0 . ValueGenerationStrategy = VAR1 ; VAR0 . StorageName = LITERAL ; VAR2 . SetKey ( VAR0 ) ; var VAR3 = VAR2 . AddProperty ( LITERAL , typeof ( string ) ) ; VAR3 . StorageName = LITERAL ; VAR3 . ValueGenerationStrategy = VAR4 ;
VAR0 . ValueGenerationStrategy = VAR1 ; VAR0 . StorageName = LITERAL ; VAR2 . SetKey ( VAR0 ) ; var VAR3 = VAR2 . AddProperty ( LITERAL , typeof ( string ) ) ; VAR3 . StorageName = LITERAL ; VAR3 . ValueGenerationStrategy = VAR4 ;
var VAR0 = new ContextEntitySets ( new EntitySetSource ( ) , Mock . Of < EntitySetInitializer > ( ) ) ; var VAR1 = VAR0 . GetEntitySet < string > ( VAR2 ) ; Assert . IsType < EntitySet < string > > ( VAR1 ) ; Assert . Same ( VAR2 , VAR1 . Context ) ;
var VAR0 = new ContextEntitySets ( new EntitySetSource ( ) , Mock . Of < EntitySetInitializer > ( ) ) ; var VAR1 = VAR0 . GetEntitySet ( VAR2 , typeof ( string ) ) ; Assert . IsType < EntitySet < string > > ( VAR1 ) ; Assert . Same ( VAR2 , VAR1 . Context ) ;
VAR0 . SetEntityStateAsync ( EntityState . Modified , CancellationToken . None ) . Wait ( ) ; Assert . True ( VAR0 . IsPropertyModified ( VAR1 ) ) ; Assert . True ( VAR0 . IsPropertyModified ( VAR2 ) ) ; VAR0 . SetEntityStateAsync ( EntityState . Unchanged , CancellationToken . None ) . Wait ( ) ;
var VAR0 = CreateConfiguration ( VAR1 ) ; var VAR2 = CreateStateEntry ( VAR0 , VAR3 , new SomeEntity ( ) ) ; VAR2 [ VAR4 ] = 1 ; VAR2 . EntityState = EntityState . Added ; Assert . Equal ( EntityState . Added , VAR2 . EntityState ) ; Assert . Contains ( VAR2 , VAR0 . StateManager . StateEntries ) ;
var VAR0 = new SomeEntity { Id = LITERAL , Kool = LITERAL } ; var VAR1 = CreateStateEntry ( VAR2 , VAR3 , VAR0 ) ; Assert . Null ( VAR1 . GetPropertyValue ( VAR4 ) ) ; Assert . Equal ( LITERAL , VAR1 . GetPropertyValue ( VAR5 ) ) ; VAR1 . SetPropertyValue ( VAR4 , LITERAL ) ; VAR1 . SetPropertyValue ( VAR5 , LITERAL ) ; Assert . Equal ( LITERAL , VAR0 . Id ) ; Assert . Equal ( LITERAL , VAR0 . Kool ) ;
VAR0 . SetKey ( VAR0 . AddProperty ( LITERAL , typeof ( int ) , shadowProperty : true ) ) ; var VAR1 = new EntityType ( typeof ( B ) ) ; VAR1 . SetKey ( VAR1 . AddProperty ( LITERAL , typeof ( int ) , shadowProperty : true ) ) ; var VAR2 = new Model ( ) ; VAR2 . AddEntityType ( VAR0 ) ; VAR2 . AddEntityType ( VAR1 ) ; VAR0 . AddForeignKey ( VAR1 . GetKey ( ) , VAR0 . AddProperty ( LITERAL , typeof ( int ) , shadowProperty : false ) ) ; VAR1 . AddForeignKey ( VAR0 . GetKey ( ) , VAR1 . AddProperty ( LITERAL , typeof ( int ) , shadowProperty : false ) ) ;
var VAR0 = new Mock < StateManager > ( ) . Object ; var VAR1 = new StateEntryFactory ( ) . Create ( VAR0 , VAR2 . Object , new object [  ] { LITERAL } ) ; Assert . IsType < ShadowStateEntry > ( VAR1 ) ; Assert . Same ( VAR0 , VAR1 . StateManager ) ;
var VAR0 = new Mock < StateManager > ( ) . Object ; var VAR1 = new StateEntryFactory ( ) . Create ( VAR0 , VAR2 . Object , new object [  ] { LITERAL } ) ; Assert . IsType < MixedStateEntry > ( VAR1 ) ; Assert . Same ( VAR0 , VAR1 . StateManager ) ;
var VAR0 = CreateStateManager ( VAR1 ) ; var VAR2 = VAR1 . GetEntityType ( typeof ( Customer ) ) ; var VAR3 = new Customer { VAR4 = LITERAL , VAR5 = LITERAL } ; var VAR6 = new ClrStateEntry ( VAR0 , VAR2 , VAR3 ) ;
VAR0 . Setup ( VAR1 => VAR1 . HasClrProperty ) . Returns ( false ) ; var VAR2 = new [ ] { VAR0 . Object } ; VAR3 = VAR3 ?? new Mock < IProperty > ( ) ; VAR3 . Setup ( VAR1 => VAR1 . Index ) . Returns ( 1 ) ; VAR3 . Setup ( VAR1 => VAR1 . ShadowIndex ) . Returns ( 1 ) ; VAR3 . Setup ( VAR1 => VAR1 . HasClrProperty ) . Returns ( false ) ;
VAR0 . AddProperty ( new Property ( Customer . VAR1 ) ) ; VAR0 . AddProperty ( new Property ( LITERAL , typeof ( int ) , hasClrProperty : true ) ) ; VAR0 . AddProperty ( new Property ( LITERAL , typeof ( int ) , hasClrProperty : false ) ) ; Assert . True ( VAR0 . GetProperty ( LITERAL ) . HasClrProperty ) ; Assert . True ( VAR0 . GetProperty ( LITERAL ) . HasClrProperty ) ; Assert . False ( VAR0 . GetProperty ( LITERAL ) . HasClrProperty ) ;
Assert . Equal ( 0 , VAR0 . PropertyIndex ( LITERAL ) ) ; Assert . Equal ( 1 , VAR0 . PropertyIndex ( LITERAL ) ) ; VAR0 . AddProperty ( new Property ( Customer . VAR1 ) ) ; Assert . Equal ( 0 , VAR0 . PropertyIndex ( LITERAL ) ) ; Assert . Equal ( 1 , VAR0 . PropertyIndex ( LITERAL ) ) ; Assert . Equal ( LITERAL , VAR0 . PropertyIndex ( LITERAL ) ) ;
VAR0 = VAR1 . DataStore . CreateConnection ( ) ; VAR0 . Open ( ) ; VAR2 = VAR0 . CreateCommand ( ) ; VAR2 . CommandText = VAR3 ; VAR1 . DataStore . Logger . WriteSql ( VAR3 ) ;
